<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="cccs7">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2023/01/03/计算机网络/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://example.com/2023/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="cccs7&#39;s blog">
<meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/redefine-og.webp">
<meta property="article:published_time" content="2023-01-03T07:38:21.000Z">
<meta property="article:modified_time" content="2024-09-13T03:07:59.000Z">
<meta property="article:author" content="cccs7 - csq020611@gmail.com">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/redefine-og.webp">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-favicon.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.svg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/redefine-favicon.svg">
    <!--- Page Info-->
    
    <title>
        
            计算机网络 | cccs7&#39;s blog
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
    
        <link href="" rel="stylesheet">
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"example.com","root":"/","language":"en"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":"enable","family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":{"enable":true,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"cccs7's blog","subtitle":{"text":[],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":"enable","color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"About":{"icon":"fa-regular fa-user","submenus":{"Me":"/about","Github":"https://github.com/EvanNotFound/hexo-theme-redefine","Blog":"https://ohevan.com"}}},"search":{"enable":"enable","preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2022/8/17 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                cccs7&#39;s blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-user fa-fw"></i>
                                    ABOUT
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a href="/about">
                                                    ME
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://github.com/EvanNotFound/hexo-theme-redefine">
                                                    GITHUB
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://ohevan.com">
                                                    BLOG
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-About"
                        >
                            <span>
                                ABOUT
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-About">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           href="/about">ME</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://github.com/EvanNotFound/hexo-theme-redefine">GITHUB</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://ohevan.com">BLOG</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">53</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">75</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">71</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">计算机网络</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/redefine-avatar.svg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">cccs7</span>
					
					<span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv5</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-01-03 15:38:21</span>
        <span class="mobile">2023-01-03 15:38:21</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-09-13 11:07:59</span>
            <span class="mobile">2024-09-13 11:07:59</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/CS/">CS</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/CS/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<p> 计算机网络</p>
<p><strong>中国科学技术大学  郑烇老师 - 计算机网络</strong></p>
<p>参考教材 ： <strong>计算机网络-自顶向下方法 原书第7版</strong></p>
<br>

<h2 id="计算机网络与因特网"><a href="#计算机网络与因特网" class="headerlink" title="计算机网络与因特网"></a>计算机网络与因特网</h2><p>这一章的目标是从整体上粗线条地勾勒出计算机网络的概貌，并且描述计算机网络的框架。包括大量的背景知识，讨论大量的计算机网络构件，而且将他们放在整个网络的大环境中进行讨论</p>
<br>

<p>目标： </p>
<ul>
<li>了解基本术语和概念</li>
<li>掌握网络的基本原理</li>
</ul>
<br>

<h3 id="什么是-Internet？"><a href="#什么是-Internet？" class="headerlink" title="什么是 Internet？"></a>什么是 Internet？</h3><hr>
<h4 id="从具体构成角度描述"><a href="#从具体构成角度描述" class="headerlink" title="从具体构成角度描述"></a>从具体构成角度描述</h4><p>节点</p>
<ul>
<li>主机及其上运行的应用程序</li>
<li>路由器、交换机等网络交换设备</li>
</ul>
<br>

<p>边 ： 通信链路 (communication link)</p>
<ul>
<li>接入网链路 ：  主机连接到互联网的链路 </li>
<li>主干链路： 路由器间的链路</li>
</ul>
<br>

<p>数以亿计的、互联网的计算设备：</p>
<ul>
<li><strong><font color='red'>主机（host） &#x3D; 端系统 (end system)</font></strong></li>
<li>运行 <strong><font color='red'>网络应用程序</font></strong></li>
</ul>
<br>

<p>通信链路：</p>
<ul>
<li>光纤、同轴电缆、无线电、卫星</li>
<li>传输速率 &#x3D; <strong><font color='red'>带宽 （bps)</font></strong></li>
</ul>
<br>

<p>分组交换设备 ： 转发分组（packets）</p>
<ul>
<li>路由器和交换机</li>
</ul>
<br>

<p>**<font color='red'>协议</font>**控制发送、接收消息</p>
<ul>
<li>如 TCP、IP、HTTP、FTP、PPP</li>
</ul>
<br>

<p><strong><font color='red'>Internet ： “网络的网络”</font></strong></p>
<ul>
<li>松散的层次结构，互连的 ISP</li>
<li>公共 Internet vs. 专用 intranet</li>
</ul>
<br>

<p>Internet 标准</p>
<ul>
<li>RFC ： Request for comments</li>
<li>IETF ： Internet Engineering Task Force</li>
</ul>
<br>

<h4 id="从服务角度描述"><a href="#从服务角度描述" class="headerlink" title="从服务角度描述"></a>从服务角度描述</h4><p><font color='red'>使用通信设施进行通信的</font><strong><font color='red'>分布式应用</font></strong></p>
<ul>
<li>Web、VoIP、email、分布式游戏、电子商务、社交游戏…</li>
<li>…</li>
</ul>
<br>

<p><strong><font color='red'>通信基础设施为 apps 提供编程接口（通信服务）</font></strong></p>
<ul>
<li>将发送和接收数据的app与互联网连接起来</li>
<li>为APP 应用提供服务选择，类似于邮政服务<ul>
<li>无连接不可靠服务</li>
<li>面向连接的可靠服务</li>
</ul>
</li>
</ul>
<br>

<h4 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h4><p>人类协议和计算机网络协议示例</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230107153146149.png"
                      alt="image-20230107153146149" style="zoom:50%;" 
                >

<br>

<h5 id="人类协议"><a href="#人类协议" class="headerlink" title="人类协议"></a>人类协议</h5><p>发送特定的消息</p>
<p>收到消息时采取特定的行动或其他事件</p>
<br>

<h5 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h5><ul>
<li>类似人类协议</li>
<li>机器之间的协议而非人与人之间的协议</li>
<li>Internet 中所有的通信行为都受协议制约</li>
</ul>
<br>

<blockquote>
<p>协议（<strong>protocol</strong>）定义了在两个或多个通信实体之间交换的 <strong><font color='red'>报文格式</font></strong> 和 <strong><font color='red'>次序</font></strong>，以及 在 报文传输和 &#x2F;  或接收 或 其他事件方面所采取的 <strong><font color='red'>动作</font></strong></p>
</blockquote>
<br>

<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><hr>
<ul>
<li>网络边缘：<ul>
<li>主机</li>
<li>应用程序（客户端和服务端）</li>
</ul>
</li>
<li>网络核心<ul>
<li>互连着的路由器</li>
<li>网络的网络 以 中国科学技术大学 郑烇老师的计算机网络为主线，&lt;计算机网络-自顶向下方法&gt;第7版、自己查阅资料辅助总结的学习笔记。内容包括 计算机网络概述、应用层、运输层、网络层、数据链路层、物理层等知识。</li>
</ul>
</li>
<li>接入网、物理媒体<ul>
<li>有线或者无线通信链路</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230107154757291.png"
                      alt="image-20230107154757291" style="zoom:50%;" 
                >

<br>

<h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><hr>
<ul>
<li>端系统（主机）<ul>
<li>运行 应用程序</li>
<li>如 web、email</li>
<li>在 “ 网络的边缘”</li>
</ul>
</li>
<li>客户&#x2F;服务器模式<ul>
<li>客户端向服务器端请求&#x2F;接收服务</li>
<li>如  web 浏览器&#x2F;服务器 ： email 客户端&#x2F;服务器</li>
</ul>
</li>
<li>对等（peer-peer） 模式<ul>
<li>很少（甚至没有）专门的服务器</li>
<li>如 GnutElla、KaZaA、Emule</li>
</ul>
</li>
</ul>
<br>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230107154324733.png"
                      alt="image-20230107154324733" style="zoom:67%;" 
                >

<br>

<h4 id="采用-网络设施的面向连接服务"><a href="#采用-网络设施的面向连接服务" class="headerlink" title="采用 网络设施的面向连接服务"></a>采用 网络设施的面向连接服务</h4><p><strong><font color='red'>目标</font></strong> ： 在 端系统之间传输数据</p>
<br>

<h5 id="握手："><a href="#握手：" class="headerlink" title="握手："></a>握手：</h5><p>在数据传输之前做好准备</p>
<ul>
<li>人类协议中 ： 你好、你好</li>
<li>两个通信主机之间为 <strong><font color='red'>连接建立状态</font></strong></li>
</ul>
<br>

<h5 id="TCP-传输控制协议（Transmission-Control-Protocol）"><a href="#TCP-传输控制协议（Transmission-Control-Protocol）" class="headerlink" title="TCP - 传输控制协议（Transmission Control Protocol）"></a>TCP - 传输控制协议（Transmission Control Protocol）</h5><p>Internet 上面向连接的服务</p>
<ul>
<li>可靠地、按顺序地传送数据<ul>
<li>确认和重传</li>
</ul>
</li>
<li>流量控制<ul>
<li>发送方 不会淹没接收方</li>
</ul>
</li>
<li>拥塞控制<ul>
<li>当网络拥塞时，发送方降低发送速率</li>
</ul>
</li>
</ul>
<br>

<h4 id="采用基础设施的无连接服务"><a href="#采用基础设施的无连接服务" class="headerlink" title="采用基础设施的无连接服务"></a>采用基础设施的无连接服务</h4><p><strong><font color='red'>目标</font></strong>：在端系统之间传输数据</p>
<br>

<p><strong><font color='red'>UDP</font></strong> - 用户数据报协议 （User Datagram Protocol )</p>
<ul>
<li>无连接</li>
<li>不可靠数据传输</li>
<li>无流量控制</li>
<li>无拥塞控制</li>
</ul>
<br>

<h4 id="使用-TCP-的应用"><a href="#使用-TCP-的应用" class="headerlink" title="使用 TCP 的应用"></a>使用 TCP 的应用</h4><ul>
<li>HTTP（web）</li>
<li>FTP（文件传送）</li>
<li>Telnet（远程登录）</li>
<li>SMTP（email）</li>
</ul>
<br>

<h4 id="使用-UDP-的应用"><a href="#使用-UDP-的应用" class="headerlink" title="使用 UDP  的应用"></a>使用 UDP  的应用</h4><ul>
<li>流媒体</li>
<li>远程会议</li>
<li>DNS</li>
<li>Internet 电话</li>
</ul>
<br>

<h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><hr>
<p>网络核心： 路由器的网状网络（即由互联因特网端系统的分组交换机和链路构成的网状网络）</p>
<br>

<h4 id="数据怎样通过网络进行传输？"><a href="#数据怎样通过网络进行传输？" class="headerlink" title="数据怎样通过网络进行传输？"></a>数据怎样通过网络进行传输？</h4><ul>
<li><font color='red'><strong>电路交换</strong></font>：为每个呼叫预留一条专有电路：如 电话网</li>
<li><strong><font color='red'>分组交换</font></strong>：<ul>
<li>将要传送的数据分成一个个单位： 分组</li>
<li>将分组从一个路由器传到相邻路由器（hop ），一段段最终从源端传到 目标端</li>
<li>每段 ： 采用链路的  <strong>最大传输能力</strong>（带宽）</li>
</ul>
</li>
</ul>
<br>

<h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>在电路交换网络中，在端系统间通信会话期间，预留了端系统间沿路径通所需要的资源（缓存、链路传输速率）</p>
<h5 id="端到端的资源被分配给从源端到目标端的呼叫-“-call-”"><a href="#端到端的资源被分配给从源端到目标端的呼叫-“-call-”" class="headerlink" title="端到端的资源被分配给从源端到目标端的呼叫 “ call ”"></a><strong><font color='red'>端到端的资源被分配给从源端到目标端的呼叫 “ call ”</font></strong></h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230203162504963.png"
                      alt="image-20230203162504963"
                ></p>
<ul>
<li>图中 ，每段链路有四条线路：<ul>
<li>该呼叫采用了上面链路的第二个线路，右边线路的第一个线路（piece）</li>
</ul>
</li>
<li>独享资源： 不共享<ul>
<li>每个呼叫一旦建立起来就能够保证性能</li>
</ul>
</li>
<li>如果 呼叫没有数据发送，被分配的资源将被浪费 （<strong><font color='cornflowerblue'>no sharing</font></strong>）</li>
<li>通常被传统电话网络采用</li>
</ul>
<br>

<h5 id="为-呼叫-预留端-端资源"><a href="#为-呼叫-预留端-端资源" class="headerlink" title="为 呼叫 预留端-端资源"></a><strong><font color='red'>为 呼叫 预留端-端资源</font></strong></h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230203163124768.png"
                      alt="image-20230203163124768" style="zoom:50%;" 
                >

<ul>
<li>链路带宽、交换能力</li>
<li>专用资源 ： 不共享</li>
<li>保证性能</li>
<li>要求建立呼叫连接</li>
</ul>
<br>

<h5 id="网络资源（如带宽）被分成-片"><a href="#网络资源（如带宽）被分成-片" class="headerlink" title="网络资源（如带宽）被分成 片"></a><strong>网络资源（如带宽）被分成 <font color='red'>片</font></strong></h5><ul>
<li>为呼叫分配片</li>
<li>如果某个资源处于**<font color='red'>空闲状态</font>**（不共享）</li>
<li>将 带宽分成片<ul>
<li>频分（Frequency - division multiplexing）</li>
<li>时分（Time - division multiplexing）</li>
<li>波分（Wave - division multiplexing）</li>
</ul>
</li>
</ul>
<br>

<h5 id="FDM-与-TDM"><a href="#FDM-与-TDM" class="headerlink" title="FDM 与 TDM"></a><strong>FDM 与 TDM</strong></h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230203170710095.png"
                      alt="image-20230203170710095" style="zoom:50%;" 
                >

<br>

<p>链路中的电路是通过 <strong><font color='red'>频分复用（Frequency - Division Multiplexing，FDM）</font></strong> 或  <strong><font color='red'>时分复用（Time - Division Multiplexing， TDM）</font></strong>  来实现的。</p>
<p>对于 FDM，链路的频谱是由 跨越链路创建的所有连接共享。特别是，在连接期间链路为每条连接专用一个频段。</p>
<p>对于一条 TDM  链路，时间被划分为 固定期间的帧，并且每个帧又被划分为固定数量的时隙。当网络跨越一条链路创建一条连接时，网络在每个帧中为该连接指定一个时隙。这些时隙专门由该连接单独使用，一个时隙（在每个帧中）可用于传输该连接的数据</p>
<h5 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h5><h6 id="计算示例"><a href="#计算示例" class="headerlink" title="计算示例"></a>计算示例</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230203184136268.png"
                      alt="image-20230203184136268" style="zoom: 50%;" 
                >

<br>

<h6 id="电路交换不适合计算机之间的通信的原因"><a href="#电路交换不适合计算机之间的通信的原因" class="headerlink" title="电路交换不适合计算机之间的通信的原因"></a>电路交换不适合计算机之间的通信的原因</h6><ul>
<li>连接建立时间长</li>
<li>计算机之间的通信有突发性，如果使用线路交换，则浪费的片比较多<ul>
<li>即使 这个呼叫没有数据传输，其所占据的片也不能够被别的呼叫使用</li>
</ul>
</li>
<li>可靠性不高 <strong>？</strong></li>
</ul>
<br>

<h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230203191342603.png"
                      alt="image-20230203191342603" style="zoom:50%;" 
                >

<br>

<p><strong><font color='red'>以分组为单位存储-转发方式</font></strong></p>
<ul>
<li>网络带宽资源不再分为一个一个片，传输时使用全部带宽</li>
<li>主机之间传输的数据 被划分为一个个分组</li>
</ul>
<br>

<p><font color='red'><strong>资源共享，按需使用</strong></font></p>
<ul>
<li>存储 - 转发 ： 分组每次移动一跳（hop）<ul>
<li>在转发之前，节点必须收到整个分组</li>
<li>延迟比线路交换要大</li>
<li>排队时间</li>
</ul>
</li>
</ul>
<br>

<h5 id="统计多路复用"><a href="#统计多路复用" class="headerlink" title="统计多路复用"></a>统计多路复用</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230203195457036.png"
                      alt="image-20230203195457036" style="zoom:67%;" 
                >

<br>

<p>A &amp; B 时分复用 链路资源</p>
<p>A &amp; B 分组没有固定模式  -&gt; <strong><font color='red'>统计 多路复用</font></strong></p>
<br>

<h4 id="网络核心的关键功能"><a href="#网络核心的关键功能" class="headerlink" title="网络核心的关键功能"></a>网络核心的关键功能</h4><h5 id="存储-转发"><a href="#存储-转发" class="headerlink" title="存储 - 转发"></a>存储 - 转发</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230203191846192.png"
                      alt="image-20230203191846192"
                ></p>
<br>

<p><strong><font color='red'>分组交换</font></strong>：分组的存储转发一段一段从源端传到目标端，按照有无网络层的连接，分成：</p>
<ul>
<li><strong><font color='red'>数据报网络</font></strong>：<ul>
<li>分组的目标地址决定下一跳</li>
<li>在不同的阶段，路由可以改变</li>
<li>类似 ： 问路</li>
<li>Internet</li>
</ul>
</li>
<li><strong><font color='red'>虚电路网络</font></strong>：<ul>
<li>每个分组都带标签（虚电路标识 VCID），标签决定下一跳</li>
<li>在 <strong><font color='red'>呼叫建立时</font></strong> 决定 路径，在整个呼叫中路径保持不变</li>
<li><strong><font color='red'>路由器维持每个呼叫的状态信息</font></strong></li>
<li>X.25 和  ATM</li>
</ul>
</li>
</ul>
<br>

<h6 id="数据报的工作原理"><a href="#数据报的工作原理" class="headerlink" title="数据报的工作原理"></a>数据报的工作原理</h6><ul>
<li>在通信之前，无须建立一个连接，有数据就传输</li>
<li>每一个分组都独立路由（路径不一样，可能会失序）</li>
<li>路由器 根据分组的目标地址进行路由</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230203201649104.png"
                      alt="image-20230203201649104" style="zoom:67%;" 
                >

<br>

<h6 id="虚电路的工作原理"><a href="#虚电路的工作原理" class="headerlink" title="虚电路的工作原理"></a>虚电路的工作原理</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230203201720173.png"
                      alt="image-20230203201720173" style="zoom: 50%;" 
                >

<br>

<ul>
<li>被传输到下一个链路之前，整个分组必须到达路由器 ： <strong><font color='red'>存储 - 转发</font></strong></li>
<li>在 一个速率为 R bps 的链路，一个长度为 L bits 的 分组的存储转发延时 ： L&#x2F;R s<ul>
<li>L &#x3D; 7.5 Mbits</li>
<li>R &#x3D; 1.5 Mbps </li>
<li>三次 存储转发延时 ： 15 s</li>
</ul>
</li>
</ul>
<br>

<h5 id="排队延迟和丢失"><a href="#排队延迟和丢失" class="headerlink" title="排队延迟和丢失"></a>排队延迟和丢失</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230203192515257.png"
                      alt="image-20230203192515257" style="zoom:67%;" 
                >

<br>

<p><strong><font color='red'>排队和延迟</font></strong></p>
<p>每台分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个<strong>输出缓存</strong>（output buffer,也称为<strong>输出队列</strong>（output queue)),它用于存储路由器准备发往那条链路的分组。该输出缓存在分组交换中起着重要的作用。如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待。因此，除了存储转发时延以外，分组还要承受输出缓存的<strong>排队时延</strong>（queuing delay)。这些时延是变化的，变化的程度取决于<strong>网络的拥塞程度</strong>。因为缓存空间的大小是有限的，一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。在此情况下，将出现**<font color='red'>分组丢失（丢包）</font>**(packet loss),到达的分组或已经排队的分组之一将被丢弃。</p>
<br>

<p>如果 到达速率 &gt; 链路的输出速率</p>
<ul>
<li>分组将会排队，等待传输</li>
<li>如果 路由器的缓存用完了，分组将会被抛弃</li>
</ul>
<br>

<h5 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h5><p><strong><font color='red'>路由</font></strong>： 决定分组采用的源到目标的路径</p>
<p><strong><font color='red'>转发</font></strong>:    将分组从路由器的输入链路转移到输出链路</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230203194139308.png"
                      alt="image-20230203194139308" style="zoom:80%;" 
                >

<br>

<p>在因特网中，每个端系统具有一个称为 IP 地址的 地址。当源主机要向目标主机要向目的端系统发送一个分组时，源在该分组的首部包含了目的地的 IP 地址，如同 邮政地址那样，该地址具有一种等级结构。当一个分组到达网络中的路由器时，路由器检查该分组的目的地址的一部分，并向一台相邻路由器转发该分组。 特别的是，每台路由器具有一个 <strong>转发表</strong>（forwarding table），用于将目的地址（或者目的地址的一部分）映射成为输出链路。当某分组 到达一台路由器时，路由器检查该地址，并用这个地址搜索其转发表，以发现适当的输出链路。路由器则将分组导向该出链路。</p>
<br>

<p>以上解释了 路由器使用分组的目的地址来索引转发表并决定适当的出链路。但是  转发表是如何进行设置的呢 ？</p>
<p>因特网 具有一些特殊的 <strong>路由选择协议（routing protocol）</strong>，用于 自动地设置这些转发表。</p>
<p>例如 ： 一个路由选择协议 可以决定从每台路由器到每个目的地的最短路径，并使用这些最短路径的结果来配置 路由器中的转发表。</p>
<br>

<h4 id="分组交换-和-电路交换的-对比"><a href="#分组交换-和-电路交换的-对比" class="headerlink" title="分组交换 和 电路交换的 对比"></a>分组交换 和 电路交换的 对比</h4><h5 id="同样的网络资源，分组交允许更多的用户使用-网络"><a href="#同样的网络资源，分组交允许更多的用户使用-网络" class="headerlink" title="同样的网络资源，分组交允许更多的用户使用 网络"></a><strong><font color='red'>同样的网络资源，分组交允许更多的用户使用 网络</font></strong></h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230203200215763.png"
                      alt="image-20230203200215763" style="zoom:50%;" 
                >

<ul>
<li>1 Mb&#x2F;s 链路</li>
<li>每个用户<ul>
<li>活动时 100 kb&#x2F;s</li>
<li>10 % 的时间是活动的</li>
</ul>
</li>
</ul>
<br>

<p>电路交换：</p>
<ul>
<li>10 用户</li>
</ul>
<br>

<p>分组交换：</p>
<ul>
<li>35 用户时</li>
<li><code>&gt;= 10</code> 用户活动的概率为 0.0004</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230203200502312.png"
                      alt="image-20230203200502312" style="zoom:50%;" 
                >

<br>

<h5 id="分组交换是-“突发数据的胜利者”？"><a href="#分组交换是-“突发数据的胜利者”？" class="headerlink" title="分组交换是 “突发数据的胜利者”？"></a><font color='red'>分组交换是 “突发数据的胜利者”？</font></h5><ul>
<li>适用于对 突发式数据传输<ul>
<li>资源共享</li>
<li>简单，不必建立呼叫</li>
</ul>
</li>
<li><strong><font color='red'>过度使用会造成网络瘫痪</font></strong> ：分组延迟和 丢失<ul>
<li>对可靠地数据传输需要协议来约束 ： 拥塞控制</li>
</ul>
</li>
<li><strong><font color='red'>怎样提供 类似电路交换的 服务 ？</font></strong><ul>
<li>保证 音频&#x2F;视频应用需要的带宽</li>
<li>一个 仍未解决的问题 （chapter 7）</li>
</ul>
</li>
</ul>
<br>

<h4 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230203201803329.png"
                      alt="image-20230203201803329" style="zoom:67%;" 
                >

<br>





<h3 id="接入网和物理媒体"><a href="#接入网和物理媒体" class="headerlink" title="接入网和物理媒体"></a>接入网和物理媒体</h3><hr>
<p><strong><font color='red'>怎样将端系统和边缘路由器连接 ？</font></strong></p>
<ul>
<li>住宅接入网络</li>
<li>单位接入网络（学校、公司）</li>
<li>无线接入网络</li>
</ul>
<br>

<p><strong><font color='red'>注意</font></strong></p>
<ul>
<li>接入网络的带宽（bits per second）?</li>
<li>共享&#x2F;专用</li>
</ul>
<br>

<h4 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h4><p>考虑了位于 “网络边缘” 的应用程序 和  端系统后，下面考虑 <strong>接入网</strong> ，这是指将端系统物理连接到其 <strong>边缘路由器（edge route）</strong> 的网络。 </p>
<p><strong>边缘路由器</strong>是指 端系统到任何其他远程端系统的路径上的第一台路由器。</p>
<br>

<h5 id="住宅接入-：-modem"><a href="#住宅接入-：-modem" class="headerlink" title="住宅接入 ： modem"></a>住宅接入 ： modem</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230204194410976.png"
                      alt="image-20230204194410976" style="zoom:67%;" 
                >

<p>将 上网数据 <strong><font color='red'>调制</font></strong> 加载音频信号上，在电话线上传输，在局端将其中的数据 <strong><font color='red'>解调</font></strong> 出来；反之亦然</p>
<ul>
<li>调频</li>
<li>调幅</li>
<li>调相位</li>
<li>综合调制</li>
</ul>
<br>

<p><strong><font color='red'>拨号调制器</font></strong></p>
<ul>
<li>56 kbps 的速率直接接入路由器（通常更低）</li>
<li>不能同时上网和打电话：不能 总是在线</li>
</ul>
<br>

<h5 id="住宅接入-：线缆模式"><a href="#住宅接入-：线缆模式" class="headerlink" title="住宅接入 ：线缆模式"></a>住宅接入 ：线缆模式</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230204195618627.png"
                      alt="image-20230204195618627" style="zoom:67%;" 
                >

<br>



<h5 id="数字用户线-digital-subscriber-line-（DSL）"><a href="#数字用户线-digital-subscriber-line-（DSL）" class="headerlink" title="数字用户线  digital subscriber line （DSL）"></a>数字用户线  digital subscriber line （DSL）</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230204194436253.png"
                      alt="image-20230204194436253" style="zoom:67%;" 
                >

<ul>
<li>采用 <strong>现存的</strong> 到交换局 DSLAM（数字用户线接入复用器） 的电话线<ul>
<li>DSL 线路上的数据被传到互联网</li>
<li>DSL 线路上的语音被传到电话网</li>
</ul>
</li>
<li>&lt; 2.5 Mbps 上行传输速率 （typical &lt; 1 Mbps）</li>
<li>&lt; 24 Mbps 下行传输速率 （typical &lt; 10 Mbps）</li>
</ul>
<br>

<h5 id="线缆网络"><a href="#线缆网络" class="headerlink" title="线缆网络"></a>线缆网络</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230204194808592.png"
                      alt="image-20230204194808592" style="zoom:67%;" 
                >

<p>有线电视信号线缆双向改造</p>
<p><strong><font color='red'>FDM</font></strong> ： 在 不同频段传输不同信道的数据，数字电视和 上网数据（上下行）</p>
<br>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230204195056606.png"
                      alt="image-20230204195056606" style="zoom:80%;" 
                >

<ul>
<li><strong><font color='cornflowerblue'>HFC</font></strong> ： hybrid fiber coax<ul>
<li>非对称 ： 最高 30 Mbps 的下行传输速率， 2 Mbps 的上行传输速率</li>
</ul>
</li>
<li><strong><font color='cornflowerblue'>线缆和 光纤网络</font></strong> 将每个家庭用户 接入到 ISP 路由器</li>
<li>各用户 <strong><font color='red'>共享</font></strong> 到 线缆头端的接入网络<ul>
<li>与 DSL 不同，DSL 的每个用户 一个专用线路到 CO （central office）</li>
</ul>
</li>
</ul>
<br>

<h5 id="家庭网络"><a href="#家庭网络" class="headerlink" title="家庭网络"></a>家庭网络</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230204195719113.png"
                      alt="image-20230204195719113" style="zoom:67%;" 
                >



<br>

<h5 id="企业接入网络（Ethernet）"><a href="#企业接入网络（Ethernet）" class="headerlink" title="企业接入网络（Ethernet）"></a>企业接入网络（Ethernet）</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230204195814334.png"
                      alt="image-20230204195814334" style="zoom:67%;" 
                >

<ul>
<li>经常被企业和大学等机构采用<ul>
<li>10 Mbps，100 Mbps，1 Gbps，10 Gbps 传输速率</li>
<li>现在，端系统经常直接接到 以太网络交换机上</li>
</ul>
</li>
</ul>
<br>

<h5 id="无线接入网络"><a href="#无线接入网络" class="headerlink" title="无线接入网络"></a>无线接入网络</h5><ul>
<li>各无线端系统共享接入网络（端系统到 无线路由器）<ul>
<li>通过基站或者叫 接入点</li>
</ul>
</li>
</ul>
<br>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230204200300116.png"
                      alt="image-20230204200300116" style="zoom:50%;" 
                >

<br>

<h4 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h4><ul>
<li><strong><font color='red'>Bit</font></strong>：在发送-接收对 间传播</li>
<li><strong><font color='red'>物理链路</font></strong>：连接每个发送-接收对 之间的物理媒体</li>
<li><strong><font color='red'>导引型媒体</font></strong><ul>
<li>信号沿固体媒介被导引<ul>
<li>同轴电缆</li>
<li>光纤</li>
<li>双绞线</li>
</ul>
</li>
</ul>
</li>
<li><strong><font color='red'>非导引型媒体</font></strong><ul>
<li>开放的空间传输电磁波或者光信号，在电磁或者光信号中承载数字数据</li>
</ul>
</li>
</ul>
<br>

<p><strong><font color='red'>双绞线</font></strong>：</p>
<p>两根绝缘铜导线拧合</p>
<ul>
<li>5 类 ：100 Mbps 以太网，Gbps 千兆以太网</li>
<li>6 类 ： 10 Gbps 万兆以太网</li>
</ul>
<br>

<h5 id="同轴电缆、光纤"><a href="#同轴电缆、光纤" class="headerlink" title="同轴电缆、光纤"></a>同轴电缆、光纤</h5><h6 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h6><ul>
<li>两根同轴的铜导线</li>
<li>双向</li>
<li>基带电缆<ul>
<li>电缆上一个单个信道</li>
<li>Ethernet</li>
</ul>
</li>
<li>宽带电缆<ul>
<li>电缆上有多个 信道</li>
<li>HFC</li>
</ul>
</li>
</ul>
<br>

<h6 id="光纤和光缆"><a href="#光纤和光缆" class="headerlink" title="光纤和光缆"></a><font color='red'>光纤和光缆</font></h6><ul>
<li><strong>光脉冲，每个脉冲表示一个 bit，在玻璃纤维中传输</strong></li>
<li><strong>高速</strong><ul>
<li><strong>点到点的高速传输（如 10Gbps - 100 Gbps 传输速率）</strong></li>
</ul>
</li>
<li><strong>低误码率 ： 在两个中继器之间可以有很长的距离，不受电磁噪声的干扰</strong></li>
<li><strong>安全</strong></li>
</ul>
<br>

<h5 id="无线链路"><a href="#无线链路" class="headerlink" title="无线链路"></a>无线链路</h5><ul>
<li>开放空间传输电磁波，携带要传输的数据</li>
<li>无需物理  “线缆”</li>
<li>双向</li>
<li>传播环境效应<ul>
<li>反射</li>
<li>吸收</li>
<li>干扰</li>
</ul>
</li>
</ul>
<br>

<h6 id="无线链路类型"><a href="#无线链路类型" class="headerlink" title="无线链路类型"></a><font color='red'>无线链路类型</font></h6><ul>
<li><strong><font color='cornflowerblue'>地面微波</font></strong></li>
<li><strong><font color='cornflowerblue'>LAN</font></strong></li>
<li><strong><font color='cornflowerblue'>wide-area</font></strong><ul>
<li>3G cellular : ~ 几 Mbps </li>
<li>4G ：10Mbps</li>
<li>5G ： 数 Gbps</li>
</ul>
</li>
<li><strong><font color='cornflowerblue'>卫星</font></strong><ul>
<li>每个信道 kbps 到 45 Mbps（或者多个聚集信道）</li>
<li>270 msec 端到端延迟</li>
<li>同步静止卫星和地轨卫星</li>
</ul>
</li>
</ul>
<br>

<h3 id="Internet-结构-和-ISP"><a href="#Internet-结构-和-ISP" class="headerlink" title="Internet 结构 和 ISP"></a>Internet 结构 和 ISP</h3><hr>
<h4 id="互联网络结构-：-网络的网络"><a href="#互联网络结构-：-网络的网络" class="headerlink" title="互联网络结构 ： 网络的网络"></a>互联网络结构 ： 网络的网络</h4><ul>
<li>端系统通过 接入**<font color='red'>ISPs</font>** (Internet Service Providers) 连接到互联网<ul>
<li>住宅，公司和 大学的 ISPs</li>
</ul>
</li>
<li>接入 ISPs 相应的必须是互联的<ul>
<li>因此任何两个 端系统可互相发送分组给对方</li>
</ul>
</li>
<li>导致的 “ 网络的网络” 非常复杂<ul>
<li>发展和演化是通过 <strong>经济的</strong>  和 <strong>国家的</strong> 政策来驱动的</li>
</ul>
</li>
<li>让我们采用渐进方法来描述当前互联网的结构</li>
</ul>
<br>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230204210108462.png"
                      alt="image-20230204210108462" style="zoom:80%;" 
                >

<ul>
<li>在网络的最中心，一些为数不多的充分连接的大范围网络（分布广、节点有限、但是之间有着多重连接）<ul>
<li><strong><font color='red'>“ tier-1” commercial ISPs</font></strong> ,国家或者国际范围的覆盖</li>
<li><strong><font color='red'>content provider network</font></strong> : 将他们的数据中心接入 ISP，方便周边用户的访问；通常私有网络之间用专网绕过第一层 ISP 和</li>
</ul>
</li>
</ul>
<br>

<h4 id="network-of-networks"><a href="#network-of-networks" class="headerlink" title="network of networks"></a>network of networks</h4><ul>
<li>松散的层次结构</li>
<li><strong><font color='red'>中心：第一层 ISP</font></strong> （如 UUNet，BBN&#x2F;Genuity，Sprint，AT&amp;T） 国家&#x2F;国际覆盖，速率极高<ul>
<li>直接与其他第一层 ISP 相连</li>
<li>与大量的 第二层 ISP 和 其他客户网络相连</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230204210818316.png"
                      alt="image-20230204210818316" style="zoom:67%;" 
                >



<ul>
<li><strong><font color='red'>第二层 ISP ： 更小些的（通常是区域性的）ISP</font></strong><ul>
<li>与一个或多个第一个 ISPs ，也可能与其他第二层 ISP</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230204210948248.png"
                      alt="image-20230204210948248" style="zoom: 50%;" 
                >

<ul>
<li><strong><font color='red'>第三层 ISP  与其他本地 ISP</font></strong><ul>
<li>接入网（与端系统最近）</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230204211036421.png"
                      alt="image-20230204211036421" style="zoom:50%;" 
                >

<ul>
<li><strong><font color='red'>一个分组要经过许多分组</font></strong></li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230204211111511.png"
                      alt="image-20230204211111511" style="zoom:50%;" 
                >

<ul>
<li>许多内容提供商（如 Google） 可能会部署自己的网络，连接自己在各地的 DC （数据中心），走自己的数据</li>
<li>连接若干 local ISP 和各级（包括一层）ISP，更加靠近用户</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230204211318787.png"
                      alt="image-20230204211318787" style="zoom:50%;" 
                >

<br>

<h4 id="ISP-之间的连接"><a href="#ISP-之间的连接" class="headerlink" title="ISP 之间的连接"></a>ISP 之间的连接</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230204211415213.png"
                      alt="image-20230204211415213" style="zoom:67%;" 
                >

<ul>
<li>POP ： 高层 ISP 面向客户网络的接入点，涉及费用结算<ul>
<li>如一个低层 ISP 接入多个高层 ISP，多宿（multi home）</li>
</ul>
</li>
<li>对等接入： 两个 ISP 对等接入，不涉及费用结算</li>
<li>IXP ： 多个对等 ISP 互联互通之处，通常不涉及费用结算<ul>
<li>对等接入</li>
</ul>
</li>
<li>ICP 自己部署专用网络，同时 和各级 ISP 连接</li>
</ul>
<br>

<h3 id="分组延时、丢失和吞吐量"><a href="#分组延时、丢失和吞吐量" class="headerlink" title="分组延时、丢失和吞吐量"></a>分组延时、丢失和吞吐量</h3><hr>
<p>在理想状态下 ，我们希望因特网服务能够在任意两个端系统之间随心所欲的瞬间移动数据而没有任何的数据丢失。然而这是一个极高的目标。与之相反，<strong>计算机网络必定要限制在端系统之间的吞吐量（每秒能够传送的数据量）</strong>。在端与端之间引入时延，而实际上也会存在 <strong>丢失分组</strong>。</p>
<p><strong>分组丢失和延时是怎么发生的？</strong></p>
<p>在路由器缓冲区的分组队列</p>
<ul>
<li><strong><font color='red'>分组到达链路的速率大于链路传输的速率</font></strong></li>
<li>分组等待排到队头、被传输</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230303103417308.png"
                      alt="image-20230303103417308" style="zoom: 50%;" 
                >



<h4 id="分组交换网中的时延概述"><a href="#分组交换网中的时延概述" class="headerlink" title="分组交换网中的时延概述"></a>分组交换网中的时延概述</h4><p>分组从一个主机（host  源）出发，通过一系列的路由器传输，在另一台主机（目的地）中结束它的历程。当分组从一个节点（主机或路由器）沿着这条路径到后继节点（主机或路由器），该分组在沿途的每个节点经受了几种不同类型的时延。这些时延最为重要的是</p>
<ul>
<li>节点处理时延（nodal processing delay ）</li>
<li>排队时延（queuing delay）</li>
<li>传输时延（transmission delay）</li>
<li>传播时延（propagation delay）</li>
</ul>
<p>这些时延总体累加起来是 <strong>节点总时延</strong></p>
<br>

<p><font color='red'>节点处理时延</font></p>
<ul>
<li>检查 bit 级 差错</li>
<li>检查分组首部和决定将分组导向何处</li>
</ul>
<br>

<p><strong><font color='red'>排队时延</font></strong></p>
<ul>
<li>在输出链路上等待被传输的时间	</li>
<li>依赖于路由器的拥塞程度</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230303103751174.png"
                      alt="image-20230303103751174" style="zoom:50%;" 
                >

<br>

<p><font color='red'>传输时延</font></p>
<ul>
<li>R &#x3D;  链路带宽（bps）</li>
<li>L &#x3D; 分组长度（bit）</li>
<li>将分组发送到链路上所需的时间  &#x3D; L &#x2F; R</li>
<li>存储转发延时</li>
</ul>
<br>

<p><font color='red'>传播延时</font></p>
<ul>
<li>d &#x3D; 物理链的长度</li>
<li>s &#x3D; 在媒体上传播的速度 （~ 2 x 10 ^ 8 m&#x2F;sec）</li>
<li>传播延时 &#x3D; d &#x2F; s</li>
</ul>
<blockquote>
<p>Note : s  and d  are very different quantities</p>
</blockquote>
<h5 id="时延的类型"><a href="#时延的类型" class="headerlink" title="时延的类型"></a>时延的类型</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230303101555369.png"
                      alt="image-20230303101555369" style="zoom: 33%;" 
                >

<p>作为源和目的地之间的端到端路由的一部分，一个分组从上游节点通过路由器 A 向路由器B 发送。A 具有 通往 B 的出链路。该链路 前面有一个 <strong>队列 （也称缓存）</strong>。当 分组从上游节点到达路由器 A 时，路由器 A 检查该分组的首部以决定它的适当 出链路，并将该分组导向该链路。</p>
<br>

<p>在此例子中，对该分组的出链路是通向路由器 B 的那条链路。 仅当 <strong>在该链路没有其他分组正在传输并且没有其他分组排队在该队列之前时</strong>，才能在该链路上传输该分组</p>
<br>

<p>如果 该链路当前正繁忙或有其他分组已经在该链路上排队，则  <strong>新到达的分组将加入排队</strong></p>
<h6 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h6><h3 id="协议层次及服务类型"><a href="#协议层次及服务类型" class="headerlink" title="协议层次及服务类型"></a>协议层次及服务类型</h3><hr>
<h4 id="协议层次"><a href="#协议层次" class="headerlink" title="协议层次"></a>协议层次</h4><p><strong><font color='red'>网络是一个复杂的系统</font></strong></p>
<ul>
<li>网络的功能复杂：<ul>
<li>数字信号的物理信号承载、点到点、路由、rdt、进程区分、应用等等</li>
</ul>
</li>
<li>现实来看，网络的许多构成元素和设备<ul>
<li>主机</li>
<li>路由器</li>
<li>各种媒体的链路</li>
<li>应用</li>
<li>协议</li>
<li>硬件、软件</li>
</ul>
</li>
</ul>
<h5 id="层次化方式实现复杂的网络功能"><a href="#层次化方式实现复杂的网络功能" class="headerlink" title="层次化方式实现复杂的网络功能"></a>层次化方式实现复杂的网络功能</h5><ul>
<li>将网络复杂的功能分层功能明确的 <strong>层次</strong>，每一层实现了其中一个或一组<strong>功能</strong>，功能中有其上层可以使用的功能 ： <strong>服务</strong></li>
<li>本层协议实体相互交互执行本层的 <strong>协议动作</strong>，目的是实现本层功能，通过接口为上层提供更好的服务</li>
<li>在实现本层协议的时候，直接 <strong>利用率下层所提供的的服务</strong></li>
<li>本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用的） +  更下层所提供的的服务</li>
</ul>
<h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><h5 id="服务和服务访问点"><a href="#服务和服务访问点" class="headerlink" title="服务和服务访问点"></a>服务和服务访问点</h5><ul>
<li>服务（Service）：<ul>
<li>低层实体向上层实体提供他们之间的通信的能力<ul>
<li>服务用户（service user)</li>
<li>服务提供者（service provider）</li>
</ul>
</li>
</ul>
</li>
<li>原语（primitive）<ul>
<li>上层使用下层 服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是服务访问原语来进行交互的   —   形式</li>
</ul>
</li>
<li>服务访问点 SAP（ Services Access Point）<ul>
<li>上层使用下层提供的服务通过层间的接口 - 地点<ul>
<li>eg: 邮箱<ul>
<li>地址（address） ： 下层的一个实体支撑着上层的多个实体，SAP 有标志不同上层实体的作用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="服务的类型"><a href="#服务的类型" class="headerlink" title="服务的类型"></a>服务的类型</h5><h6 id="面向连接的服务"><a href="#面向连接的服务" class="headerlink" title="面向连接的服务"></a>面向连接的服务</h6><ul>
<li>面向连接的服务（Connection-oriented Service）<ul>
<li>连接 （Connection）<ul>
<li>两个通信实体为进行通信而建立的一种结合</li>
</ul>
</li>
<li>面向连接的服务通信的过程：<ol>
<li>建立连接</li>
<li>通信</li>
<li>拆除连接</li>
</ol>
</li>
<li>面向连接的服务的 例子<ul>
<li>网络层的连接被称为虚电路</li>
</ul>
</li>
<li>适用范围<ul>
<li>对于大的数据块要传输；不适合小的零星报文</li>
</ul>
</li>
<li>特点<ul>
<li>保序</li>
</ul>
</li>
<li>服务类型<ul>
<li>可靠的信息流  传送页面（可靠的获得，通过接收方的确认）</li>
<li>可靠的字节流  远程登录</li>
<li>不可靠的连接  数字化声音</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="面向无连接的服务"><a href="#面向无连接的服务" class="headerlink" title="面向无连接的服务"></a>面向无连接的服务</h6><ul>
<li>无连接的服务（Connectionless Service）<ul>
<li>无连接服务<ul>
<li>两个对等层实体在通信前不需要建立一个连接，不预留资源；不需要通信双方都是活跃（eg: 寄信）</li>
</ul>
</li>
<li>特点<ul>
<li>不可靠</li>
<li>可能重复</li>
<li>可能失序</li>
</ul>
</li>
<li>IP 分组，数据包</li>
<li>使用范围<ul>
<li>适合 传送零星数据</li>
</ul>
</li>
<li>服务类型<ul>
<li>不可靠的数据报 电子方式的函件</li>
<li>有确认的数据报  挂号信</li>
<li>请求回答  信息查询</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="服务和协议"><a href="#服务和协议" class="headerlink" title="服务和协议"></a>服务和协议</h4><h5 id="服务与协议的区别"><a href="#服务与协议的区别" class="headerlink" title="服务与协议的区别"></a>服务与协议的区别</h5><ul>
<li>服务（Service）<ul>
<li>低层实体向上层实体提供他们之间的通信的能力，是通过 原语（primitive） 来操作的， <strong>垂直</strong></li>
</ul>
</li>
<li>协议（protocol )<ul>
<li>对等层实体（peer entity）之间在相互通信的过程中，需要遵循的规则的集合， <strong>水平</strong></li>
</ul>
</li>
</ul>
<h5 id="服务与协议的关系"><a href="#服务与协议的关系" class="headerlink" title="服务与协议的关系"></a>服务与协议的关系</h5><ul>
<li>本层 **<font color='red'>协议的实现</font> **  要靠下层提供的服务来实现</li>
<li>本层实体通过协议为 上层 <strong><font color='red'>提供更高级的服务</font></strong></li>
</ul>
<h4 id="数据单元（DU）"><a href="#数据单元（DU）" class="headerlink" title="数据单元（DU）"></a>数据单元（DU）</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230421110408877.png"
                      alt="image-20230421110408877" style="zoom: 67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230421110425320.png"
                      alt="image-20230421110425320" style="zoom:80%;" 
                >



<h4 id="分层处理和实现复杂系统的好处"><a href="#分层处理和实现复杂系统的好处" class="headerlink" title="分层处理和实现复杂系统的好处"></a>分层处理和实现复杂系统的好处</h4><ul>
<li>概念化<ul>
<li>结构清晰，便于标示网络组件，以及描述其相互关系</li>
<li>分层参考模型</li>
</ul>
</li>
<li>结构化<ul>
<li>模块化更易于维护和系统升级</li>
<li>改变某一层服务的实现不影响系统中的其他层次<ul>
<li>对于其他层次而言是透明的</li>
</ul>
</li>
</ul>
</li>
<li>分层思想被认为有害的地方</li>
</ul>
<h4 id="Internet-协议栈"><a href="#Internet-协议栈" class="headerlink" title="Internet 协议栈"></a>Internet 协议栈</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230421111838470.png"
                      alt="image-20230421111838470" style="zoom: 50%;" 
                >

<ul>
<li><strong><font color='red'>应用层</font></strong>： 网络应用<ul>
<li>为人类或者其他应用进程提供网络应用服务</li>
<li>FTP、SMTP、HTTP、DNS</li>
</ul>
</li>
<li><strong><font color='red'>传输层</font></strong>：主机之间的数据传输<ul>
<li>在网络层提供的端到端通信基础上，细分为 进程到进程，将不可靠的通信变成可靠地通信</li>
<li>TCP、UDP</li>
</ul>
</li>
<li><strong><font color='red'>网络层</font></strong> ： 为数据报从源到目的地 选择路由<ul>
<li>主机主机之间的通信，端到端通信，不可靠</li>
<li>IP、路由协议</li>
</ul>
</li>
<li><strong><font color='red'>链路层</font></strong>： 相邻网络节点间的数据传输<ul>
<li>2 个 相邻 2 点的通信，点到点通信，可靠或不可靠</li>
<li>点到点协议 PPP，802.11（wifi）,Ethernet</li>
</ul>
</li>
<li><strong><font color='red'>物理层</font></strong>：在线路上传送 bit</li>
</ul>
<h4 id="ISO-OSI-参考模型"><a href="#ISO-OSI-参考模型" class="headerlink" title="ISO &#x2F; OSI 参考模型"></a>ISO &#x2F; OSI 参考模型</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230421111850768.png"
                      alt="image-20230421111850768" style="zoom:50%;" 
                >

<ul>
<li><strong><font color='red'>表示层</font></strong>： 允许应用解释传输的数据 （加密，压缩，机器相关的表示转换）</li>
<li><strong><font color='red'>会话层</font></strong>：数据交换的同步，检查点，恢复</li>
<li>互联网协议栈没有这两层（在 应用层）</li>
</ul>
<h4 id="封装与解封装"><a href="#封装与解封装" class="headerlink" title="封装与解封装"></a>封装与解封装</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230421112109077.png"
                      alt="image-20230421112109077" style="zoom: 67%;" 
                >



<h4 id="各层次的协议数据单元"><a href="#各层次的协议数据单元" class="headerlink" title="各层次的协议数据单元"></a>各层次的协议数据单元</h4><ul>
<li>应用层：报文（message）</li>
<li>传输层：报文段（segment）：tcp 段，UDP 数据报</li>
<li>网络层：分组 packet（如果无连接方式 ： 数据报 datagram ）</li>
<li>数据链路层 ： 帧（frame）</li>
<li>物理层：位 （bit)</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<ul>
<li>组成角度看  什么是互联网<ul>
<li>边缘 ： 端系统（包括应用） + 接入网</li>
<li>核心 ： 网络交换设备 + 通信链路</li>
<li>协议 ： 对等层实体通信过程中遵守的规则的集合<ul>
<li>语法，语义，时序</li>
</ul>
</li>
</ul>
</li>
<li>为了实现复杂的网络功能，采用分层方式设计、实现和调试<ul>
<li>应用层、传输层、网络层、数据链路层、物理层</li>
<li>协议数据单位<ul>
<li>报文、报文段、分组、帧、位</li>
</ul>
</li>
</ul>
</li>
<li>从 服务角度 看互联网<ul>
<li>通信服务基础设施<ul>
<li>提供的通信服务： 面向连接   无连接</li>
</ul>
</li>
<li>应用</li>
</ul>
</li>
<li>应用之间的交互<ul>
<li>C&#x2F;S 模式</li>
<li>P2P 模式</li>
</ul>
</li>
<li>数据交换<ul>
<li>分组数据交换</li>
<li>线路交换</li>
</ul>
</li>
<li>比较  线路交换和 分组交换</li>
<li>分组交换的 2 中方式<ul>
<li>虚电路</li>
<li>数据报</li>
</ul>
</li>
<li>接入网和物理媒介<ul>
<li>接入网技术<ul>
<li>住宅：ADSL，拨号，cable modem</li>
<li>单位：以太网</li>
<li>无线接入方式</li>
</ul>
</li>
<li>物理媒介<ul>
<li>光纤，同轴电缆，以太网，双绞线</li>
</ul>
</li>
</ul>
</li>
<li>ISP 层次结构</li>
<li>分组交换网络中 延迟和丢失是如何发生的<ul>
<li>延迟的组成：<ul>
<li>处理</li>
<li>传输</li>
<li>传播</li>
<li>排队</li>
</ul>
</li>
</ul>
</li>
<li>网络的分层体系结构<ul>
<li>分层体系结构</li>
<li>服务</li>
<li>协议数据单元</li>
<li>封装与解封装</li>
</ul>
</li>
<li>历史</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>在本章中，我们将学习有关网络应用的原理和实现方面的知识。我们从定义关键的应用层概念开始，其中包括应用程序所需要的网络服务、客户和服务器、进程和运输层接口。</p>
<p>应用层是我们学习协议非常好的起点，它最为我们熟悉。</p>
<br/>

<p><strong>目标</strong></p>
<ul>
<li>网络应用的 <strong>原理</strong>：网络应用协议的概念和实现方面<ul>
<li>传输层的服务模型</li>
<li>客户-服务器模式</li>
<li>对等模式（peer-to-peer)</li>
<li>内容分发网络</li>
</ul>
</li>
<li>网络应用的 <strong>实例</strong>：互联网流行的应用层协议<ul>
<li>HTTP</li>
<li>FTP</li>
<li>SMTP&#x2F;POP3&#x2F;IMAP</li>
<li>DNS</li>
</ul>
</li>
<li><strong>编程</strong>：网络应用程序<ul>
<li><strong>Socket API</strong></li>
</ul>
</li>
</ul>
<br>

<p><strong>创建一个新的网络应用</strong></p>
<p><strong><font color='red'>编程</font></strong></p>
<ul>
<li>在不同的端系统上运行</li>
<li>通过网络基础设施提供的服务，应用进程彼此通信</li>
<li>如 WEB<ul>
<li>web 服务器软件与浏览器软件通信</li>
</ul>
</li>
</ul>
<p><strong><font color='red'>网络核心中没有应用层软件</font></strong></p>
<ul>
<li>网络核心没有应用层功能</li>
<li>网络应用只在端系统上存在，快速网络应用开发和部署</li>
</ul>
<h3 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h3><hr>
<h4 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h4><h5 id="可能的应用架构"><a href="#可能的应用架构" class="headerlink" title="可能的应用架构"></a>可能的应用架构</h5><ul>
<li>客户-服务器模式（C&#x2F;S : client&#x2F;server)</li>
<li>对等模式 （peer-to-peer)</li>
<li>混合体：c&#x2F;s 和 p2p</li>
</ul>
<h6 id="客户-服务器（c-s-体系结构"><a href="#客户-服务器（c-s-体系结构" class="headerlink" title="客户-服务器（c&#x2F;s 体系结构"></a>客户-服务器（c&#x2F;s 体系结构</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230422132321857.png"
                      alt="image-20230422132321857" style="zoom:50%;" 
                >

<p><strong>服务器</strong></p>
<ul>
<li>一直运行</li>
<li>固定的 IP 地址和周知的端口号（约定）</li>
<li>扩展性：服务器场<ul>
<li>数据中心进行扩展</li>
<li>扩展性差</li>
</ul>
</li>
</ul>
<p><strong>客户端</strong></p>
<ul>
<li>主动与服务器通信</li>
<li>与互联网有间歇性的连接</li>
<li>可能是 动态 IP 地址</li>
<li>不直接与其他客户端通信</li>
</ul>
<h6 id="对等体-（peer-to-peer）体系结构"><a href="#对等体-（peer-to-peer）体系结构" class="headerlink" title="对等体 （peer-to-peer）体系结构"></a>对等体 （peer-to-peer）体系结构</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230422132453842.png"
                      alt="image-20230422132453842" style="zoom:50%;" 
                >

<ul>
<li>（几乎）没有一直运行的服务器</li>
<li>任意端系统之间可以进行通信</li>
<li>每一个节点既是客户端也是服务器<ul>
<li><font color='red'>自扩展性 - 新  peer 节点带来新的服务能力，当然也带来新的服务请求</font></li>
</ul>
</li>
<li>参与的主机间歇性连接且可以改变 IP 地址<ul>
<li>难以管理</li>
</ul>
</li>
<li>eg: 迅雷</li>
</ul>
<h6 id="c-s-和-p2p-体系结构混合体"><a href="#c-s-和-p2p-体系结构混合体" class="headerlink" title="c&#x2F;s 和  p2p 体系结构混合体"></a>c&#x2F;s 和  p2p 体系结构混合体</h6><p><strong><font color='red'>Napster</font></strong></p>
<ul>
<li>文件搜索：集中<ul>
<li>主机在中心服务器上注册其资源</li>
<li>主机向中心服务器查询资源位置</li>
</ul>
</li>
<li>文件传输 ： p2p<ul>
<li>任意 peer 节点之间</li>
</ul>
</li>
</ul>
<p><font color='red'>即时通信</font></p>
<ul>
<li>在线检测：集中<ul>
<li>当用户在线时，向中心服务器注册其 IP</li>
<li>用户和中心服务器联系，以找到其在线好友的位置</li>
</ul>
</li>
<li>两个用户之间聊天：P2P</li>
</ul>
<h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><p><font color='red'>进程</font>：在主机上运行的应用程序</p>
<p><strong><font color='red'>客户端进程</font></strong>：发起通信的进程</p>
<p><strong><font color='red'>服务器进程</font></strong>：等待连接的进程</p>
<ul>
<li>在同一个主机内，使用  <font color='red'>进程间通信机制</font>  通信（操作系统定义）</li>
<li>不同主机，通过交换 <font color='red'>报文</font>（<strong><font color='red'>Message</font></strong>）来通信<ul>
<li>使用 OS 提供的通信服务</li>
<li>按照 应用协议交换报文<ul>
<li>借助传输层提供的服务</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意： p2p 架构的应用也有客户端进程和服务器进程之分</p>
</blockquote>
<h5 id="分布式进程通信需要解决的问题"><a href="#分布式进程通信需要解决的问题" class="headerlink" title="分布式进程通信需要解决的问题"></a>分布式进程通信需要解决的问题</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230422135058488.png"
                      alt="image-20230422135058488" style="zoom: 67%;" 
                >

<ul>
<li>问题1 ： 进程标示和寻址问题（<font color='red'>服务用户</font>）</li>
<li>问题2 ： 传输层 - 应用层提供服务是如何（<font color='red'>服务</font>）<ul>
<li>位置： 层间页面 的 SAP（TCP&#x2F;IP ：Socket）</li>
<li>形式：应用程序接口 API （TCP&#x2F;IP：socket API）</li>
</ul>
</li>
<li>问题3：如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用（<font color='red'>用户使用服务</font>）<ul>
<li>定义应用层协议：报文格式，解释，时序等</li>
<li>编制程序，使用 OS 提供的 API，调用网络基础设施提供通信服务传报文，实现应用应用时序等</li>
</ul>
</li>
</ul>
<h6 id="问题1：对进程进行编址"><a href="#问题1：对进程进行编址" class="headerlink" title="问题1：对进程进行编址"></a>问题1：对进程进行编址</h6><ul>
<li>进程为了 接收报文，必须有一个 <strong>标识</strong>，即 SAP （server access point)(发送也需要标识)<ul>
<li>主机：唯一的 32 位 <strong><font color='red'>IP地址</font></strong><ul>
<li>仅仅有 IP 地址不能唯一标识一个进程：在一台端系统上有很多应用进程在运行</li>
</ul>
</li>
<li>所采用的传输层协议：TCP or UDP</li>
<li><strong><font color='red'>端口号</font></strong> （Port Numbers）</li>
</ul>
</li>
<li>一些知名的端口号的例子<ul>
<li>HTTP：TCP 80  Mail： TCP25 ftp : TCP 2</li>
</ul>
</li>
<li>一个进程：用 IP + Port 标识端节点</li>
<li>本质上，一对主机进程之间的通信由2 个端节点构成</li>
</ul>
<h6 id="问题2：传输层提供的服务-需要穿过层间的信息"><a href="#问题2：传输层提供的服务-需要穿过层间的信息" class="headerlink" title="问题2：传输层提供的服务-需要穿过层间的信息"></a>问题2：传输层提供的服务-需要穿过层间的信息</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230422140209712.png"
                      alt="image-20230422140209712" style="zoom:67%;" 
                >

<ul>
<li>层间接口必须要携带的信息<ul>
<li>要传输的报文（对于本层来说 ： SDU 【service data unit】）</li>
<li>谁传的：对方的应用进程的标示 ： IP + TCP（UDP） 端口</li>
<li>传给谁：对方的应用进程的标示：对方的IP+TCP（UDP） 端口</li>
</ul>
</li>
<li>传输层实体（tcp 或者 udp 实体）根据这些信息进行 tcp 报文段（udp 数据报）的封装<ul>
<li>源端口号，目标端口号，数据等</li>
<li>将 IP 地址往下交 IP 实体，用于封装 IP 数据报源IP，目标 IP</li>
</ul>
</li>
</ul>
<h6 id="问题2：传输层提供的服务-层间信息的代表"><a href="#问题2：传输层提供的服务-层间信息的代表" class="headerlink" title="问题2：传输层提供的服务-层间信息的代表"></a>问题2：传输层提供的服务-层间信息的代表</h6><ul>
<li>如果 Socket API 每次传输报文，都携带如此多的信息，太繁琐易错，不便于管理</li>
<li>用个代号标识 通信的双方或者单方 ： socket</li>
<li>就像 OS 打开文件返回的句柄一样<ul>
<li>对 句柄的操作，就是对文件的操作</li>
</ul>
</li>
<li>TCP socket<ul>
<li>tcp 服务，两个进程之间的通信需要之前要建立连接<ul>
<li>两个进程通信会 持续一段时间，通信关系稳定</li>
</ul>
</li>
<li>可以用一个整数表示两个应用实体之间的通信关系，<strong><font color='red'>本地标示</font></strong></li>
<li>穿过层间接口的信息量 <strong>最小</strong></li>
<li>TCP socket ： 源 IP，源端口，目标IP，目标 端口</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230422143017472.png"
                      alt="image-20230422143017472"
                ></p>
<br>

<p><strong>TCP 之上的套接字（socket）</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230422142957196.png"
                      alt="image-20230422142957196" style="zoom:50%;" 
                >

<ul>
<li>对于使用面向连接服务（tcp）的应用而言，套接字是 4 元组的一个具有 <strong><font color='red'>本地意义的标示</font></strong><ul>
<li>4 元组：<strong><font color='red'>源 IP，源端口，目标IP，目标 端口</font></strong></li>
<li>唯一的指定了一个会话（两个进程之间的会话关系）</li>
<li>应用使用这个标示 ，与远程的应用进程通信</li>
<li>不必在每一个报文的发送都要指定这 4 元组</li>
<li>就像使用操作系统打开一个文件， OS 返回一个文件句柄一样，以后使用这个文件句柄，而不是使用这个文件的目录名、文件名</li>
<li>简单，便于管理</li>
</ul>
</li>
</ul>
<h6 id="问题2：传输层提供的服务-层间信息代码"><a href="#问题2：传输层提供的服务-层间信息代码" class="headerlink" title="问题2：传输层提供的服务-层间信息代码"></a>问题2：传输层提供的服务-层间信息代码</h6><ul>
<li>UDP socket<ul>
<li>UDP 服务，两个进程之间通信需要之前无需建立连接<ul>
<li>每个报文都是独立传输的 </li>
<li>前后报文可能给不同的分布式进程</li>
</ul>
</li>
<li>因此，只能用一个整数表示本应用实体的标示<ul>
<li>因为这个报文可能传给另外一个分布式进程</li>
</ul>
</li>
<li>穿过层间接口的信息大小最小</li>
<li>UDP socket ： 本 IP，本端口</li>
<li>但是传输报文时：必须要提供对方的IP ，port<ul>
<li>接收报文时：传输层需要上传对方的IP，port</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>

<p><strong>UDP 之上 的套接字（socket）</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230422144036521.png"
                      alt="image-20230422144036521" style="zoom:50%;" 
                >

<ul>
<li>对于 使用无连接服务（UDP）的应用而言，套接字是 2 元组的  一个具有 <strong><font color='red'>本地意义的标示</font></strong><ul>
<li>2 元组： IP，port（源端指定）</li>
<li>UDP 套接字指定了应用所在的一个 <strong><font color='red'>端节点 （end point）</font></strong></li>
<li>在发送数据报时，采用创建好的本地套接字（标示 ID），就不必在发送每个报文中指明自己所采用的 ip 和 port</li>
<li>但是在发送报文时，必须要指定对方的 IP 和  udp port (另外一个 段节点)</li>
</ul>
</li>
</ul>
<br>

<p>套接字（socket）</p>
<ul>
<li>进程向 <strong><font color='red'>套接字</font></strong> 发送报文 或从 套接字接收报文</li>
<li>套接字 &lt; - &gt; 门户<ul>
<li>发送 进程将报文推出门户，发送进程依赖于传输层设施在 另外一侧的门将报文交付给接受进程</li>
<li>接受进程从门的另外一侧的门户 收到 报文（依赖于传输层设施）</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230422144843994.png"
                      alt="image-20230422144843994"
                ></p>
<h6 id="问题3：如何使用-传输层提供的服务实现应用"><a href="#问题3：如何使用-传输层提供的服务实现应用" class="headerlink" title="问题3：如何使用 传输层提供的服务实现应用"></a>问题3：如何使用 传输层提供的服务实现应用</h6><ul>
<li>定义应用层协议：报文格式，解释，时序等</li>
<li>编制程序，通过API 调用 网络基础设施提供的通信服务传报文，解析报文，实现应用时序等</li>
</ul>
<br>

<h4 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h4><ul>
<li>定义了：运行在不同端系统上的应用 <strong>进程</strong> 如何相互交换报文<ul>
<li>交换的 <strong><font color='red'>报文类型</font></strong>：请求和应答报文</li>
<li>各种报文类型的 <strong><font color='red'>语法</font></strong>：报文中的各个字段及其描述</li>
<li>字段的 <strong><font color='red'>语义</font></strong>：即 字段取值的含义</li>
<li>进程何时、如何发送报文  及 对 报文进行响应的 <strong><font color='red'>规则</font></strong></li>
</ul>
</li>
<li>应用协议仅仅是应用的一个组成部分<ul>
<li>web 应用：HTTP 协议，web 客户端，web 服务器，HTML</li>
</ul>
</li>
</ul>
<br>

<h5 id="公开协议"><a href="#公开协议" class="headerlink" title="公开协议"></a><font color='red'>公开协议</font></h5><ul>
<li>有 RFC 文档定义</li>
<li>允许互操作</li>
<li>如 HTTP，SMTP</li>
</ul>
<br>

<h5 id="专用（私有）协议"><a href="#专用（私有）协议" class="headerlink" title="专用（私有）协议"></a><font color='red'>专用（私有）协议</font></h5><ul>
<li>协议不公开</li>
<li>如 Skype</li>
</ul>
<h4 id="运输服务"><a href="#运输服务" class="headerlink" title="运输服务"></a>运输服务</h4><h5 id="如何描述传输层的服务"><a href="#如何描述传输层的服务" class="headerlink" title="如何描述传输层的服务"></a>如何描述传输层的服务</h5><ul>
<li><strong><font color='red'>数据丢失率</font></strong><ul>
<li>有些应用则要求 100% 的可靠数据传输（如 文件）</li>
<li>有些应用（如 音频）能容忍一定比例下的数据丢失</li>
</ul>
</li>
<li><strong><font color='red'>吞吐</font></strong><ul>
<li>一些应用（如多媒体）必须需要最小限度的 吞吐，从而使得应用能够有效运转</li>
<li>一些应用能够充分利用可供使用的吞吐（弹性应用）</li>
</ul>
</li>
<li><strong><font color='red'>延迟</font></strong><ul>
<li>一些应用出于 有效性考虑，对数据传输有严格的时间限制<ul>
<li>Internet 电话、交互式游戏</li>
<li>延迟、延迟差</li>
</ul>
</li>
</ul>
</li>
<li><strong><font color='red'>安全性</font></strong><ul>
<li>机密性</li>
<li>完整性</li>
<li>可认证性</li>
</ul>
</li>
</ul>
<h5 id="常见应用对传输服务的要求"><a href="#常见应用对传输服务的要求" class="headerlink" title="常见应用对传输服务的要求"></a>常见应用对传输服务的要求</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230422150547670.png"
                      alt="image-20230422150547670"
                ></p>
<h4 id="Internet-传输层提供的服务"><a href="#Internet-传输层提供的服务" class="headerlink" title="Internet 传输层提供的服务"></a>Internet 传输层提供的服务</h4><h5 id="TCP-服务"><a href="#TCP-服务" class="headerlink" title="TCP 服务"></a><strong><font color='red'>TCP 服务</font></strong></h5><ul>
<li><font color='cornflowerblue'>可靠的传输服务</font></li>
<li><font color='cornflowerblue'>流量控制</font>：发送方不会淹没接收方</li>
<li><font color='cornflowerblue'>拥塞控制</font>：当网络出现拥堵时，能抑制发送方</li>
<li><font color='cornflowerblue'>不能提供的服务</font>：时间保证、最小吞吐量保证和安全</li>
<li><font color='cornflowerblue'>面向连接</font>：要求在客户端进程和服务器进程之间建立连接</li>
</ul>
<h5 id="UDP服务"><a href="#UDP服务" class="headerlink" title="UDP服务"></a><font color='red'>UDP服务</font></h5><ul>
<li>不可靠的数据传输</li>
<li><font color='red'>不</font>提供的服务：可靠，流量控制，拥塞控制，带宽保证，建立连接</li>
</ul>
<blockquote>
<p>为什么要有 UDP？</p>
</blockquote>
<h5 id="UDP-存在的必要性"><a href="#UDP-存在的必要性" class="headerlink" title="UDP 存在的必要性"></a>UDP 存在的必要性</h5><ul>
<li>能够 <font color='red'>区分不同的进程</font>，而 IP 服务不能<ul>
<li>在 IP 提供的主机到主机  端到端功能的基础上，区分了 主机的应用进程</li>
</ul>
</li>
<li><strong><font color='red'>无需建立连接</font></strong>，省去 了建立连接的时间，适合事务性的应用</li>
<li><strong><font color='red'>不做可靠性的工作</font></strong>。例如 检错重发，适合那些对实时性要求比较高而对正确性要求不高的应用<ul>
<li>因为为了实现可靠性（正确性、保序等），必须付出时间代价（检错重发）</li>
</ul>
</li>
<li>没有了 拥塞控制和流量控制，<font color='red'>应用能够按照设定的速度发送数据</font><ul>
<li>而在 tcp 上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量限制和拥塞限制</li>
</ul>
</li>
</ul>
<h5 id="Internet-应用及其应用层协议和传输协议"><a href="#Internet-应用及其应用层协议和传输协议" class="headerlink" title="Internet 应用及其应用层协议和传输协议"></a>Internet 应用及其应用层协议和传输协议</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230422152425471.png"
                      alt="image-20230422152425471"
                ></p>
<h5 id="安全-TCP"><a href="#安全-TCP" class="headerlink" title="安全 TCP"></a>安全 TCP</h5><h6 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP&amp; UDP"></a>TCP&amp; UDP</h6><ul>
<li>都没有加密</li>
<li>明文通过互联网传输，甚至密码</li>
</ul>
<h6 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h6><ul>
<li>在 TCP 上实现，提供加密的 TCp 连接</li>
<li>私密性</li>
<li>数据完整性</li>
<li>端到端的鉴别</li>
</ul>
<h6 id="SSL-在-应用层"><a href="#SSL-在-应用层" class="headerlink" title="SSL 在 应用层"></a>SSL 在 应用层</h6><ul>
<li>应用采用 SSL 库，SSL库采用 TCP 通信</li>
</ul>
<h6 id="SSL-socket-api"><a href="#SSL-socket-api" class="headerlink" title="SSL socket api"></a>SSL socket api</h6><ul>
<li>应用通过 API 将 明文交给socket，SSL 将其加密在互联网上传输</li>
</ul>
<h3 id="Web-and-HTTP"><a href="#Web-and-HTTP" class="headerlink" title="Web and HTTP"></a>Web and HTTP</h3><hr>
<p>一些术语</p>
<ul>
<li><p>Web 页：有一些对象组成</p>
</li>
<li><p>对象可以是 HTML 文件、JPEG 图像、Java 小程序、声音剪辑文件等</p>
</li>
<li><p>Web 页 含有一个  <strong>基本的HTML 文件</strong>，该基本 HTML 文件又包含若干对象的引用（链接）</p>
</li>
<li><p>通过 <strong>URL</strong> 对每个对象进行引用</p>
<ul>
<li><strong>访问协议，用户名、口令字、端口等</strong></li>
</ul>
</li>
<li><p>URL 格式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230505223602661.png"
                      alt="image-20230505223602661"
                ></p>
</li>
</ul>
<h4 id="HTTP-概况"><a href="#HTTP-概况" class="headerlink" title="HTTP 概况"></a>HTTP 概况</h4><p><strong><font color='red'>HTTP：超文本传输协议</font></strong></p>
<ul>
<li>Web 的应用层协议</li>
<li>客户&#x2F;服务器模式<ul>
<li><font color='cornflowerblue'>客户</font>：请求、接收和显示 Web 对象的浏览器</li>
<li><font color='cornflowerblue'>服务器</font>：对请求进行响应，发送对象的 web 服务器</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230505224117670.png"
                      alt="image-20230505224117670" style="zoom: 33%;" 
                >

<br>

<p><strong><font color='red'>使用 TCP</font></strong></p>
<ul>
<li>客户发起一个与服务器的 TCP 连接（建立套接字），端口号为 80</li>
<li>服务器接收客户的 TCP 连接</li>
<li>在 浏览器（HTTP 客户端 ）与 Web 服务器（HTTP 服务器 Sever） 交换 HTTP 报文 （应用层协议报文</li>
<li>TCP 连接关闭</li>
</ul>
<br>

<p><strong><font color='red'>HTTP 是无状态的</font></strong></p>
<ul>
<li>服务器并不维护关于客户的任何信息</li>
</ul>
<br>

<p><font color='red'>维护状态的协议很复杂</font></p>
<ul>
<li>必须维护历史信息（状态）</li>
<li>如果 服务器&#x2F;客户端 死机，他们的 状态信息可能不一致，二者的信息必须是一致</li>
<li>无状态的服务器能够支持更多的客户端</li>
</ul>
<h4 id="HTTP-连接"><a href="#HTTP-连接" class="headerlink" title="HTTP 连接"></a>HTTP 连接</h4><h5 id="非持久-HTTP"><a href="#非持久-HTTP" class="headerlink" title="非持久 HTTP"></a>非持久 HTTP</h5><ul>
<li>最多只有一个对象在 TCP 连接上发送</li>
<li>下载多个对象需要多个 TCP 连接</li>
<li>HTTP &#x2F;1.0 使用非持久连接</li>
</ul>
<h5 id="持久-HTTP"><a href="#持久-HTTP" class="headerlink" title="持久 HTTP"></a>持久 HTTP</h5><ul>
<li>多个对象可以在一个（在客户端和服务器之间的） TCP 连接上传输</li>
<li>HTTP &#x2F;1.1 默认使用 持久连接</li>
</ul>
<h5 id="非持久-HTTP-连接"><a href="#非持久-HTTP-连接" class="headerlink" title="非持久 HTTP 连接"></a>非持久 HTTP 连接</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230505224728515.png"
                      alt="image-20230505224728515" style="zoom:67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230505224947916.png"
                      alt="image-20230505224947916" style="zoom: 80%;" 
                >

<h5 id="响应时间模型"><a href="#响应时间模型" class="headerlink" title="响应时间模型"></a>响应时间模型</h5><h6 id="往返时间-RTT（Round-trip-time）"><a href="#往返时间-RTT（Round-trip-time）" class="headerlink" title="往返时间 RTT（Round-trip time）"></a><font color='red'><strong>往返时间 RTT（Round-trip time）</strong></font></h6><p>一个小的分组从客户端服务器，在回到客户端的时间（传输时间忽略）</p>
<br>

<h6 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a><font color='red'>响应时间</font></h6><ul>
<li>一个 RTT 用来发起 TCP 连接</li>
<li>一个 RTT 用来 HTTP 请求并等待 HTTP 响应</li>
<li>文件传输时间</li>
</ul>
<blockquote>
<p>共 2RTT +  传输时间</p>
</blockquote>
<h6 id="非持久-HTTP-的-缺点"><a href="#非持久-HTTP-的-缺点" class="headerlink" title="非持久 HTTP  的 缺点"></a>非持久 HTTP  的 缺点</h6><ul>
<li>每个对象要两个 RTT</li>
<li>操作系统必须为每个 tcp 连接分配资源</li>
<li>但浏览器通常打开 并行 tcp 连接，以获取引用对象</li>
</ul>
<h6 id="持久-http"><a href="#持久-http" class="headerlink" title="持久 http"></a>持久 http</h6><ul>
<li>服务器在发送响应后，仍保持 tcp 连接</li>
<li>在相同客户端和服务器之间连续请求和响应报文通过相同的 连接继续进行传送</li>
<li>客户端在遇到一个 引用的时候，就可以尽快发送该对象的请求</li>
</ul>
<h6 id="非流水方式的持久-HTTP"><a href="#非流水方式的持久-HTTP" class="headerlink" title="非流水方式的持久 HTTP"></a>非流水方式的持久 HTTP</h6><ul>
<li>客户端只能在收到前一个响应后 才能发出新的请求</li>
<li>每个引用对象花费一个 RTT</li>
</ul>
<h6 id="流水方式的-持久HTTP"><a href="#流水方式的-持久HTTP" class="headerlink" title="流水方式的 持久HTTP"></a>流水方式的 持久HTTP</h6><ul>
<li>HTTP &#x2F;1.1 的默认模式</li>
<li>客户端在遇到一个引用对象就立即产生一个 请求</li>
<li>所有 引用（小）对象只花费一个 RTT 是可能的</li>
</ul>
<h4 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h4><ul>
<li>两种类型的 HTTP 报文： 请求、响应</li>
<li>HTTP 请求 报文<ul>
<li>ASCII （人能阅读）</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230505230517969.png"
                      alt="image-20230505230517969" style="zoom:50%;" 
                ></li>
</ul>
</li>
</ul>
<h5 id="通用格式"><a href="#通用格式" class="headerlink" title="通用格式"></a>通用格式</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230505230543466.png"
                      alt="image-20230505230543466" style="zoom:80%;" 
                >



<h5 id="提交表单输入"><a href="#提交表单输入" class="headerlink" title="提交表单输入"></a>提交表单输入</h5><h6 id="POST-方式"><a href="#POST-方式" class="headerlink" title="POST 方式"></a>POST 方式</h6><ul>
<li>网页通常 包括表单输入</li>
<li>包含在实体主体（entity body） 中的 输入提交到 服务器</li>
</ul>
<h6 id="URL方式"><a href="#URL方式" class="headerlink" title="URL方式"></a>URL方式</h6><ul>
<li>方法 ： GET</li>
<li>输入通过 请求行的 URL 字段上载</li>
</ul>
<h6 id="方法类型"><a href="#方法类型" class="headerlink" title="方法类型"></a>方法类型</h6><p><font color='red'><strong>HTTP&#x2F;1.0</strong></font></p>
<ul>
<li>GET </li>
<li>POST</li>
<li>HEAD<ul>
<li>要求 服务器在响应报文中不包含请求对象 -&gt; 故障跟踪</li>
</ul>
</li>
</ul>
<br>

<p><font color='red'><strong>HTTP&#x2F;1.1</strong></font></p>
<ul>
<li>GET、POST、HEAD</li>
<li>PUT<ul>
<li>将实体主体的文件上载到URL字段规定的路径</li>
</ul>
</li>
<li>DELETE<ul>
<li>删除 URL 字段规定的文件</li>
</ul>
</li>
</ul>
<h4 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230505231052760.png"
                      alt="image-20230505231052760" style="zoom:67%;" 
                >

<h5 id="HTTP-状态响应码"><a href="#HTTP-状态响应码" class="headerlink" title="HTTP 状态响应码"></a>HTTP 状态响应码</h5><p>位于服务器-&gt; 客户端的响应报文中的首行</p>
<p>一些状态码的例子</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230505231143379.png"
                      alt="image-20230505231143379" style="zoom:50%;" 
                >



<h4 id="用户-服务器状态-：-Cookies"><a href="#用户-服务器状态-：-Cookies" class="headerlink" title="用户 - 服务器状态 ： Cookies"></a>用户 - 服务器状态 ： Cookies</h4><p>大多数主要的门户网站使用 cookie</p>
<p><font color='red'><u>四个组成部分</u></font></p>
<ol>
<li>在 HTTP 响应报文中有一个 cookie 的 首部行</li>
<li>在 http 请求报文含有一个 cookie的 首部行</li>
<li>在用户端系统中保留有一个 cookie文件，由 用户的浏览器管理</li>
<li>在 web 站点 有一个后端数据库</li>
</ol>
<h5 id="维护状态"><a href="#维护状态" class="headerlink" title="维护状态"></a>维护状态</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230505231725821.png"
                      alt="image-20230505231725821" style="zoom:50%;" 
                >



<h6 id="cookie-能带来什么"><a href="#cookie-能带来什么" class="headerlink" title="cookie 能带来什么"></a>cookie 能带来什么</h6><ul>
<li>用户验证</li>
<li>购物车</li>
<li>推荐</li>
<li>用户状态</li>
</ul>
<h6 id="如何维护状态"><a href="#如何维护状态" class="headerlink" title="如何维护状态"></a>如何维护状态</h6><ul>
<li>协议端节点： 在多个事务上，发送端和接收端维持状态</li>
<li>cookies ： http 报文携带状态信息</li>
</ul>
<h5 id="Cookies-与-隐私"><a href="#Cookies-与-隐私" class="headerlink" title="Cookies 与 隐私"></a>Cookies 与 隐私</h5><ul>
<li>Cookies 允许站点知道许多关于用户的信息</li>
<li>可能将它知道的东西卖给第三方</li>
<li>使用重定向和 cookie 的搜索引擎还能知道用户更多的信息<ul>
<li>如 通过 某个用户的行为，了解其个人浏览方式的大致模式</li>
</ul>
</li>
<li>广告公司从站点获得信息</li>
</ul>
<h4 id="Web-缓存"><a href="#Web-缓存" class="headerlink" title="Web 缓存"></a>Web 缓存</h4><p><strong>目标：</strong> 不访问 原始服务器，就满足客户的请求</p>
<ul>
<li>用户设置浏览器： 通过缓存访问 web</li>
<li>浏览器将所有的 HTTP 请求发送给 缓存<ul>
<li>在缓存中的 对象： 缓存直接返回对象</li>
<li>不在缓存中的对象： 请求原始服务器，然后再将对象返回给客户端</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230505232313825.png"
                      alt="image-20230505232313825" style="zoom:50%;" 
                >

<ul>
<li>缓存既是客户端 又是 服务器</li>
<li>通常 缓存是由 ISP 安装</li>
</ul>
<h5 id="为什么要使用-web-缓存"><a href="#为什么要使用-web-缓存" class="headerlink" title="为什么要使用  web 缓存"></a>为什么要使用  web 缓存</h5><ul>
<li>降低 客户端的请求响应时间</li>
<li>可以大大减少一个机构内部网络与 Internet 接入链路上的 流量</li>
<li>互联网大量采用了 缓存，可以使较弱的 ICP 也可以提供内容</li>
</ul>
<h5 id="缓存实例"><a href="#缓存实例" class="headerlink" title="缓存实例"></a>缓存实例</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230505232518291.png"
                      alt="image-20230505232518291" style="zoom:80%;" 
                >



<h6 id="更快的接入链路"><a href="#更快的接入链路" class="headerlink" title="更快的接入链路"></a>更快的接入链路</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230505232552738.png"
                      alt="image-20230505232552738" style="zoom:67%;" 
                >



<h6 id="安装本地缓存"><a href="#安装本地缓存" class="headerlink" title="安装本地缓存"></a>安装本地缓存</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230505232613865.png"
                      alt="image-20230505232613865" style="zoom:67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230505232700372.png"
                      alt="image-20230505232700372" style="zoom:67%;" 
                >



<h5 id="条件-GET-方法"><a href="#条件-GET-方法" class="headerlink" title="条件 GET 方法"></a>条件 GET 方法</h5><ul>
<li>目标：如果 缓存器中的对象拷贝是最新的 ，就不要发送 对象</li>
<li>缓存器： 在 http 请求中指定 拷贝的 日期</li>
<li>服务器： 如果缓存拷贝陈旧，则响应报文没包含对象</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230505232842515.png"
                      alt="image-20230505232842515" style="zoom:67%;" 
                >



<h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><hr>
<p>ftp 文件传输协议</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506174120171.png"
                      alt="image-20230506174120171" style="zoom:67%;" 
                >

<ul>
<li>向远程主机上传输文件或从远程主机上接收文件</li>
<li>c &#x2F; s 模式<ul>
<li>客户端 ： 发起传输的一方</li>
<li>服务器 ： 远程主机</li>
</ul>
</li>
<li>ftp : RFC 959</li>
<li>ftp 服务器 ： 端口号为 21</li>
</ul>
<br>

<p><strong>FTP: 控制连接与数据连接分开</strong></p>
<ul>
<li>FTP客户端与FTP服务器通过端口21联系，并使用TCP为传输协议</li>
<li>客户端通过控制连接获得身份确认</li>
<li>客户端通过控制连接发送命令浏览远程目录</li>
<li>收到一个文件传输命令时，服务器打开一个到客户端的数据连接</li>
<li>一个文件传输完成后，服务器关闭连接</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506182251995.png"
                      alt="image-20230506182251995" style="zoom:33%;" 
                >

<ul>
<li>服务器 打开第二个 TCP 数据连接用来传输另一个文件</li>
<li>控制连接： 带外（”out of band”） 传送</li>
<li>ftp 服务器维护用户的状态信息： 当前路径、用户账户与控制连接对应</li>
</ul>
<h4 id="FTP-命令、响应"><a href="#FTP-命令、响应" class="headerlink" title="FTP 命令、响应"></a>FTP 命令、响应</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506182434130.png"
                      alt="image-20230506182434130" style="zoom: 67%;" 
                >



<h3 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h3><hr>
<p><font color='red'>三个主要组成部分</font></p>
<ul>
<li>用户代理</li>
<li>邮件服务器</li>
<li>简单邮件传输协议： SMTP</li>
</ul>
<br>

<p><font color='red'>用户代理</font></p>
<ul>
<li>又名 “邮件阅读器”</li>
<li>撰写、编辑和阅读邮件</li>
<li>如 Outlook</li>
<li>输出和输入邮件保存在服务器上</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506182719661.png"
                      alt="image-20230506182719661" style="zoom:50%;" 
                >





<h4 id="邮件服务器"><a href="#邮件服务器" class="headerlink" title="邮件服务器"></a>邮件服务器</h4><ul>
<li>邮箱 中管理和维护发送三给用户的邮件</li>
<li>输出 <font color='red'><strong>报文队列</strong></font> 保持发送邮件报文</li>
<li>邮件服务器之间的 <font color='red'><strong>SMTP 协议</strong></font> ： 发送 email 报文<ul>
<li>客户： 发送方邮件服务器</li>
<li>服务器：接收端邮件服务器</li>
</ul>
</li>
</ul>
<h4 id="SMTP-RFC-2821"><a href="#SMTP-RFC-2821" class="headerlink" title="SMTP [RFC 2821]"></a>SMTP [RFC 2821]</h4><ul>
<li>使用 TCP 在客户端和服务器之间传送报文，端口号为 25</li>
<li>直接传输： 从发送方服务器到接收方服务器</li>
<li>传输的三个手段<ul>
<li>握手</li>
<li>传输报文</li>
<li>关闭</li>
</ul>
</li>
<li>命令&#x2F;响应交互<ul>
<li>命令： ASCII 文本</li>
<li>响应：状态码和状态信息</li>
</ul>
</li>
<li>报文必须为 7 位 ASCII 码</li>
</ul>
<h5 id="SMTP-总结"><a href="#SMTP-总结" class="headerlink" title="SMTP 总结"></a>SMTP 总结</h5><ul>
<li>SMTP 使用 持久连接</li>
<li>SMTP 要求报文（首部和主体）为7 位 ASCII 编码</li>
<li>SMTP 服务器使用  <code>CRLF</code> 决定报文的尾部</li>
</ul>
<br>

<p><font color='red'><strong>HTTP 比较</strong></font></p>
<ul>
<li>HTTP : 拉（pull）</li>
<li>SMTP：推（push）</li>
<li>二者都是 ASCII 形式的命令 &#x2F; 响应交互、状态码</li>
<li>HTTP：每个对象封装在各自的响应报文中</li>
<li>SMTP：多个对象封装在一个报文中</li>
</ul>
<h5 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h5><p>SMTP ： 交换 email 报文的协议</p>
<p>RFC 822 ： 文本报文的标准</p>
<ul>
<li>首部行<ul>
<li>To</li>
<li>From</li>
<li>Subject</li>
</ul>
</li>
<li>主体<ul>
<li>报文：只能是ASCII 码字符</li>
</ul>
</li>
</ul>
<h6 id="多媒体扩展"><a href="#多媒体扩展" class="headerlink" title="多媒体扩展"></a>多媒体扩展</h6><ul>
<li>MIME： 多媒体邮件扩展</li>
<li>在报文首部用额外的行申明 MIME 的 内容类型</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506201322731.png"
                      alt="image-20230506201322731" style="zoom:50%;" 
                >



<h6 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506201422630.png"
                      alt="image-20230506201422630"
                ></p>
<ul>
<li>SMTP ： 传送到接收方的邮件服务器</li>
<li>邮件访问协议： 从服务器访问邮件<ul>
<li>POP：邮局访问协议（Post Office Protocol）[RFC 1939]<ul>
<li>用户身份确认（代理 &lt;–&gt; 服务器） 并下载</li>
</ul>
</li>
<li>IMAP ： Internet 邮件访问协议 （Internet Mail Access Protocol ）[RFC 1730]<ul>
<li>更多特性</li>
<li>在服务器上处理存储的报文</li>
</ul>
</li>
<li>HTTP ： Hotmail，Yahoo！Mail 等<ul>
<li>方便</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="POP3-协议"><a href="#POP3-协议" class="headerlink" title="POP3 协议"></a>POP3 协议</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506201819597.png"
                      alt="image-20230506201819597" style="zoom: 67%;" 
                >



<h6 id="POP3-与-IMAP"><a href="#POP3-与-IMAP" class="headerlink" title="POP3 与 IMAP"></a>POP3 与 IMAP</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506201858654.png"
                      alt="image-20230506201858654" style="zoom:67%;" 
                >



<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><hr>
<h4 id="DNS-的必要性"><a href="#DNS-的必要性" class="headerlink" title="DNS 的必要性"></a>DNS 的必要性</h4><ul>
<li>IP地址标识主机、路由器</li>
<li>但IP地址 不好记忆，不便人类使用（没有意义）</li>
<li>人类一般倾向使用一些有意义的字符串来标识 Internet 上 的设备</li>
<li>存在着 “字符串” - IP 地址的转换的必要性</li>
<li>人类用户提供要访问机器的  字符串 名称</li>
<li>由 DNS 负责转换成为 二进制的网络地址</li>
</ul>
<h4 id="DNS-的历史"><a href="#DNS-的历史" class="headerlink" title="DNS  的历史"></a>DNS  的历史</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506203204499.png"
                      alt="image-20230506203204499" style="zoom:67%;" 
                >



<h4 id="DNS-总体思路和目标"><a href="#DNS-总体思路和目标" class="headerlink" title="DNS 总体思路和目标"></a>DNS 总体思路和目标</h4><h5 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h5><ul>
<li>分层的 、基于域的 命名机制</li>
<li>若干分布式的数据库完成名字到 IP 地址的 转换</li>
<li>运行在 UDP 之上的 端口号为  53 的 应用程序</li>
<li>核心的 Internet 功能，但以应用层协议实现<ul>
<li>在网络边缘处理复杂性</li>
</ul>
</li>
</ul>
<h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h5><ul>
<li>实现 主机名到 IP 地址的 转换</li>
<li>其他目标<ul>
<li>主机别名到 规范名字的 转换</li>
<li>邮件服务器 别名到邮件服务器正规名字的转换</li>
<li>负载均衡: Load Distribution</li>
</ul>
</li>
</ul>
<h4 id="DNS-需要解决的问题"><a href="#DNS-需要解决的问题" class="headerlink" title="DNS 需要解决的问题"></a>DNS 需要解决的问题</h4><ul>
<li>问题1 ： 如何命名设备<ul>
<li>用 有意义的字符串：好记，便于人类使用</li>
<li>解决一个平面命名的重名问题：层次化命名</li>
</ul>
</li>
<li>问题2 ：如何完成名字到IP 地址的 转换<ul>
<li>分布式的 数据库维护和响应名字查询</li>
</ul>
</li>
<li>问题3 ： 如何维护：增加或者删除一个域，需要在域名系统中做哪些工作</li>
</ul>
<blockquote>
<p>相关的问题详细，在这个章节中的知识点都有穿插</p>
</blockquote>
<h5 id="问题1-：-DNS-命名空间"><a href="#问题1-：-DNS-命名空间" class="headerlink" title="问题1 ： DNS 命名空间"></a>问题1 ： DNS 命名空间</h5><ul>
<li>DNS 域名结构<ul>
<li>一个层面命名设备会有很多重名</li>
<li>DNS 采用层次树状结构的命名方法</li>
<li>Internet 根 被划为几百个顶级域名<ul>
<li>通用的 （generic）<ul>
<li>.com</li>
<li>.edu</li>
<li>.gov</li>
<li>.mil</li>
<li>.org</li>
<li>.firm</li>
</ul>
</li>
<li>国家的<ul>
<li>.cn</li>
<li>.us</li>
<li>.jp</li>
</ul>
</li>
</ul>
</li>
<li>每个（子）域 下面可划分为若干子域（subdomains）</li>
<li>树叶是主机</li>
</ul>
</li>
</ul>
<br>

<p><strong>DNS：根名字服务器</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506203854558.png"
                      alt="image-20230506203854558" style="zoom:67%;" 
                >

<h5 id="问题2-：-解析问题-名字服务器（Name-Sever）"><a href="#问题2-：-解析问题-名字服务器（Name-Sever）" class="headerlink" title="问题2 ： 解析问题 - 名字服务器（Name Sever）"></a>问题2 ： 解析问题 - 名字服务器（Name Sever）</h5><ul>
<li>一个名字服务器的问题<ul>
<li>可靠性问题：单点故障</li>
<li>扩展性问题：通信容量</li>
<li>维护问题：远距离的集中式数据库</li>
</ul>
</li>
<li>区域（zone)<ul>
<li>区域的划分由区域管理者自己决定</li>
<li>将 DNS 名字空间划分成 互不相交 的区域，每个区域都是树一部分</li>
<li>名字服务器<ul>
<li>每个区域都有一个名字服务器：维护着他所管辖的权威信息</li>
<li>名字服务器允许被放置在区域之外，以保障可靠性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="问题-3-：-维护问题：新增一个域"><a href="#问题-3-：-维护问题：新增一个域" class="headerlink" title="问题 3 ： 维护问题：新增一个域"></a>问题 3 ： 维护问题：新增一个域</h5><ul>
<li>在上级域的名字服务器上增加两条记录，指向这个新增的子域的域名和域名服务器的地址</li>
<li>在新增子域的名字服务器上运行名字服务器，负责本域的名字解析： 名字 -&gt; IP 地址</li>
<li></li>
</ul>
<br>

<p><strong>名字空间被划分成若干区域：Zone</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506204655844.png"
                      alt="image-20230506204655844" style="zoom:67%;" 
                >

<p><strong>权威DNS 服务器： 组织机构的 DNS 服务器，提供组织机构服务器可访问的主机和 IP 之间的 映射</strong></p>
<p>组织机构可以选择实现自己维护或由某个服务提供商来维护</p>
<br>

<p><strong>TLD 服务器</strong></p>
<p><strong>顶级域（TLD）服务器</strong>： 负责顶级域名 和所有国家级的顶级域名</p>
<br>

<p><strong>区域名字服务器维护资源记录</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506204934423.png"
                      alt="image-20230506204934423" style="zoom:67%;" 
                >

<br>

<p><strong>DNS记录</strong></p>
<p>DNS： 保存资源记录 （RR） 的分布式数据库</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506205029117.png"
                      alt="image-20230506205029117" style="zoom:50%;" 
                >



<h4 id="DNS-大致工作流程"><a href="#DNS-大致工作流程" class="headerlink" title="DNS 大致工作流程"></a>DNS 大致工作流程</h4><ul>
<li><p>应用调用解析器（resolver）</p>
</li>
<li><p>解析器 作为客户向 Name Sever 发出查询报文（封装在 UDP 段中）</p>
</li>
<li><p>Name Sever 返回响应报文</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506210035263.png"
                      alt="image-20230506210035263" style="zoom:67%;" 
                ></li>
</ul>
<h5 id="本地名字服务器（Local-Name-Server"><a href="#本地名字服务器（Local-Name-Server" class="headerlink" title="本地名字服务器（Local Name Server)"></a>本地名字服务器（Local Name Server)</h5><ul>
<li>并不严格属于层级结构</li>
<li>每个 ISP 都有一个 本地的 DNS 服务器<ul>
<li>也称   默认名字服务器</li>
</ul>
</li>
<li>当一个主机发起一个 DNS 查询时，查询被送到其当地 DNS 服务器<ul>
<li>起着代理的作用，将查询转发到层次结构中</li>
</ul>
</li>
</ul>
<h5 id="名字服务器（Name-Sever）"><a href="#名字服务器（Name-Sever）" class="headerlink" title="名字服务器（Name Sever）"></a>名字服务器（Name Sever）</h5><ul>
<li>名字解析过程<ul>
<li>目标名字在 Local Name Sever 中<ul>
<li>情况  1 ： 查询的名字在该区域内部</li>
<li>情况 2 ： 缓存</li>
</ul>
</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506210507393.png"
                      alt="image-20230506210507393" style="zoom:80%;" 
                >

<blockquote>
<p>当与本地名字服务器不能解析名字时，联系根名字服务器 顺着根- TLD  一直找到 权威名字服务器</p>
</blockquote>
<h6 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h6><ul>
<li>名字解析负担都放在当前联络的名字服务器上</li>
<li>问题：根服务器负担太重</li>
<li>解决：迭代查询（iterated queries）</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506210733275.png"
                      alt="image-20230506210733275" style="zoom:67%;" 
                >



<h6 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h6><ul>
<li>主机 cis.poly.edu 想知道 主机 gaia.cs.unass.edu 的 IP 地址</li>
<li>根（及各级域名）服务器返回的不是查询结果，而是下一个 NS 地址</li>
<li>最后由权威名字服务器给出解析结果</li>
<li>当前联络的服务给出可以联系的服务器的名字</li>
<li>“我不知道这个名字，但可以向这个服务器请求”</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506211009942.png"
                      alt="image-20230506211009942" style="zoom:50%;" 
                >



<h4 id="DNS-协议、报文"><a href="#DNS-协议、报文" class="headerlink" title="DNS 协议、报文"></a>DNS 协议、报文</h4><p>DNS 协议： 查询和响应报文的 报文格式相同</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506211250382.png"
                      alt="image-20230506211250382" style="zoom:80%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506211259807.png"
                      alt="image-20230506211259807" style="zoom:80%;" 
                >

<br>

<p><strong>提高性能：缓存</strong></p>
<ul>
<li>一旦名字服务器学到了一个映射，就将该映射 缓存起来</li>
<li>根服务器通常都在本地服务器中缓存着<ul>
<li>使根服务器不用被经常访问</li>
</ul>
</li>
<li>目的 : 提高效率</li>
<li>可能存在的问题：如果情况变化，缓存结果和权威资源记录可能不一样</li>
<li>解决方案：TTL （默认 两天）</li>
</ul>
<h4 id="攻击-DNS"><a href="#攻击-DNS" class="headerlink" title="攻击  DNS"></a>攻击  DNS</h4><h5 id="DDoS-攻击"><a href="#DDoS-攻击" class="headerlink" title="DDoS 攻击"></a>DDoS 攻击</h5><ul>
<li>对 根服务器进行流量轰炸：发送大量 ping<ul>
<li>没有成功</li>
<li>原因1 ：根目录服务器配置了流量过滤器，防火墙</li>
<li>原因2：Local DBS 服务器缓存了 TLD服务器的 IP 地址，因此无需查询 根服务器</li>
</ul>
</li>
<li>向  TLD 服务器流量轰炸攻击 ： 发送大量查询<ul>
<li>可能更危险</li>
<li>效果一般，大部分 DNS 缓存 了 TLD</li>
</ul>
</li>
</ul>
<h5 id="重定向攻击"><a href="#重定向攻击" class="headerlink" title="重定向攻击"></a>重定向攻击</h5><ul>
<li>中间人攻击<ul>
<li>截获查询，伪造回答，从而攻击某个（DNS 回答指定的IP）站点</li>
</ul>
</li>
<li>DNS 中毒<ul>
<li>发送伪造的回答给 DNS 服务器，希望他能缓存这个虚假的结果</li>
</ul>
</li>
<li>技术上比较困难：分布式截获和伪造</li>
</ul>
<h5 id="利用-DNS基础设施进行-DDoS"><a href="#利用-DNS基础设施进行-DDoS" class="headerlink" title="利用 DNS基础设施进行 DDoS"></a>利用 DNS基础设施进行 DDoS</h5><ul>
<li>伪造某个 IP 进行查询，攻击这个 目标 IP</li>
<li>查询放大，响应报文比查询报文大</li>
<li>效果有限</li>
</ul>
<h4 id="DNS：名字空间"><a href="#DNS：名字空间" class="headerlink" title="DNS：名字空间"></a><strong>DNS：名字空间</strong></h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506203925957.png"
                      alt="image-20230506203925957" style="zoom:67%;" 
                >

<ul>
<li>域名（Domain name)<ul>
<li>从本域往上，直到树根</li>
<li>中间使用 <code>.</code>   间隔不同的级别</li>
<li>域的域名：可以用于表示一个域</li>
<li>主机的域名：一个域上的一个主机</li>
</ul>
</li>
<li>域名的管理<ul>
<li>一个域管理其下的 子域</li>
<li>创建一个新的域，必须征得它所属域的同意</li>
</ul>
</li>
<li>域与物理网络无关<ul>
<li>域遵从组织界限，而不是物理网络<ul>
<li>一个域的主机可以不在一个网络</li>
<li>一个网络的主机不一定在一个域</li>
</ul>
</li>
<li>域的划分是逻辑的，而不是物理的</li>
</ul>
</li>
</ul>
<h3 id="P2P-应用"><a href="#P2P-应用" class="headerlink" title="P2P 应用"></a>P2P 应用</h3><hr>
<h4 id="纯-P2P-架构"><a href="#纯-P2P-架构" class="headerlink" title="纯 P2P 架构"></a>纯 P2P 架构</h4><ul>
<li>没有 （或极少）一直运行的服务器</li>
<li>任意端系统都可以直接通信</li>
<li>利用 peer 的服务能力</li>
<li>Peer 节点间歇上网，每次 IP地址都有可能变化</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506213540538.png"
                      alt="image-20230506213540538"
                ></p>
<h4 id="文件分发"><a href="#文件分发" class="headerlink" title="文件分发"></a>文件分发</h4><p>问题 ：从一台服务器 分发文件（大小 F) 到 N个 peer 需要多少时间</p>
<ul>
<li>peer 节点上下载能力是有限的资源</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506213711975.png"
                      alt="image-20230506213711975"
                ></p>
<h5 id="文件分发时间：-C-S-模式"><a href="#文件分发时间：-C-S-模式" class="headerlink" title="文件分发时间： C&#x2F;S 模式"></a>文件分发时间： C&#x2F;S 模式</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506213917873.png"
                      alt="image-20230506213917873"
                ></p>
<ul>
<li>服务传输：都是由服务器发送给 peer，服务器必须顺序传输（上载）N个文件拷贝：<ul>
<li>发送一个 copy: F&#x2F;us</li>
<li>发送 N 个 copy ：NF &#x2F; us</li>
</ul>
</li>
<li>客户端：每个客户端必须下载一个文件拷贝<ul>
<li>d(min) &#x3D; 客户端最小的下载速率</li>
<li>下载带宽最小的客户端下载的时间 ： F&#x2F;d(min)</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506214031168.png"
                      alt="image-20230506214031168" style="zoom:80%;" 
                >

<h5 id="文件分发时间-：-P2P-模式"><a href="#文件分发时间-：-P2P-模式" class="headerlink" title="文件分发时间 ： P2P 模式"></a>文件分发时间 ： P2P 模式</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506214549666.png"
                      alt="image-20230506214549666"
                ></p>
<ul>
<li>服务器传输：最少需要上载一份拷贝<ul>
<li>发送一个拷贝的时间 ：F&#x2F;u(s)</li>
</ul>
</li>
<li>客户端：每个客户端必须下载一个拷贝<ul>
<li>最小下载带宽客户单耗时： F &#x2F; d(min)</li>
</ul>
</li>
<li>客户端：所有客户端总体总体下载量 NF<ul>
<li>最大的上载带宽是 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506214751815.png"
                      alt="image-20230506214751815" style="zoom: 67%;" 
                ></li>
<li>除了服务器可以上载，其他所有的 peer 节点都可以上载</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506214839343.png"
                      alt="image-20230506214839343" style="zoom: 80%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506214907461.png"
                      alt="image-20230506214907461"
                ></p>
<h4 id="P2P-文件分发：BitTorrent"><a href="#P2P-文件分发：BitTorrent" class="headerlink" title="P2P 文件分发：BitTorrent"></a>P2P 文件分发：BitTorrent</h4><ul>
<li>文件被分为一个个块 256KB</li>
<li>网络中的这些 peers 发送接收文件块，相互服务</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506215012212.png"
                      alt="image-20230506215012212" style="zoom:67%;" 
                >

<ul>
<li><p>Peer 加入 torrent</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506215149908.png"
                      alt="image-20230506215149908"
                ></p>
<ul>
<li>一开始没有 块，但是会通过其他节点积累文件块</li>
<li>向跟踪服务器注册，获得 peer 节点列表，和部分 peer 节点构成邻居关系</li>
</ul>
</li>
<li><p>当 peer 开始下载时，该 peer可以同时向其他节点提供 上载服务</p>
</li>
<li><p>Peer 可能会变换用户交换块的 peer 节点</p>
</li>
<li><p><strong>扰动 churn</strong>： peer节点可能会上线或下线</p>
</li>
<li><p>一旦一个 peer 拥有整个文件，他会（自私的）离开或者保留（利他主义）在 torrent</p>
</li>
</ul>
<h5 id="torrent：-请求-发送文件块"><a href="#torrent：-请求-发送文件块" class="headerlink" title="torrent： 请求, 发送文件块"></a>torrent： 请求, 发送文件块</h5><h6 id="请求块"><a href="#请求块" class="headerlink" title="请求块"></a>请求块</h6><ul>
<li>在任何给定时间，不同 peer 节点拥有一个文件块的子集</li>
<li>周期性的，Alice 节点向邻居询问他们拥有哪些块信息</li>
<li>Alice向 peer 节点请求它希望的块，稀缺的块</li>
</ul>
<h6 id="发送块：-一报还一报-tit-for-tat"><a href="#发送块：-一报还一报-tit-for-tat" class="headerlink" title="发送块： 一报还一报  tit-for-tat"></a>发送块： 一报还一报  tit-for-tat</h6><ul>
<li>alice 向4个 peer 发送块，这些块向他自己提供最大带宽的服务<ul>
<li>其他 peer 被 Alice 阻塞（将不会从 Alice 处获得服务）</li>
<li>每 10 秒重新评估一次：前 4 位</li>
</ul>
</li>
<li>每个 30 秒：随机选择其他的 peer 节点，向这个节点发送块<ul>
<li>“优化疏通” 这个节点</li>
<li>新选择的 节点可以加入这个 top4</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506220246614.png"
                      alt="image-20230506220246614" style="zoom:67%;" 
                >

<blockquote>
<p>更高的上载速率： 发现更好的交易伙伴，获得更快的文件传输速率</p>
</blockquote>
<h4 id="P2P-文件共享"><a href="#P2P-文件共享" class="headerlink" title="P2P 文件共享"></a>P2P 文件共享</h4><p>例子</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506220618643.png"
                      alt="image-20230506220618643" style="zoom:67%;" 
                >

<blockquote>
<p>所有的对等方都是服务器 &#x3D; 可扩展性好</p>
</blockquote>
<h5 id="两大问题"><a href="#两大问题" class="headerlink" title="两大问题"></a>两大问题</h5><ul>
<li>如何定位所需资源</li>
<li>如何处理对等方的加入与离开</li>
</ul>
<h5 id="可能的方案"><a href="#可能的方案" class="headerlink" title="可能的方案"></a>可能的方案</h5><ul>
<li>集中</li>
<li>分散</li>
<li>半分散</li>
</ul>
<h4 id="P2P：集中式目录"><a href="#P2P：集中式目录" class="headerlink" title="P2P：集中式目录"></a>P2P：集中式目录</h4><p>最初的 “Napster” 设计</p>
<ol>
<li>当 peer 连接时，它告知中心服务器<ul>
<li>IP 地址</li>
<li>内容</li>
</ul>
</li>
<li>Alice 查询 资源</li>
<li>Alice 从 Bob出 请求文件</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506220914622.png"
                      alt="image-20230506220914622" style="zoom:50%;" 
                >



<h5 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h5><ul>
<li>单点故障</li>
<li>性能瓶颈</li>
<li>侵犯版权</li>
</ul>
<blockquote>
<p>文件传输是分散的，而定位内容则是高度集中的 </p>
</blockquote>
<h4 id="查询泛洪：-Gnutella"><a href="#查询泛洪：-Gnutella" class="headerlink" title="查询泛洪： Gnutella"></a>查询泛洪： Gnutella</h4><ul>
<li>全分布式<ul>
<li>没有中心服务器</li>
</ul>
</li>
<li>开放文件共享协议</li>
<li>许多 Gnutella 客户端实现了 Gnutella 协议<ul>
<li>类似 HTTP 有许多 浏览器</li>
</ul>
</li>
</ul>
<h5 id="覆盖网络：-图"><a href="#覆盖网络：-图" class="headerlink" title="覆盖网络： 图"></a>覆盖网络： 图</h5><ul>
<li>如果 x 和 y 之间有一个 tcp 连接，则二者之间存在一条边</li>
<li>所有活动的对等方和边就是覆盖网络</li>
<li>边并不是物理链路</li>
<li>给定一个对等方，通常所连接的节点少于 10 个</li>
</ul>
<h5 id="Gnutella-：协议"><a href="#Gnutella-：协议" class="headerlink" title="Gnutella ：协议"></a>Gnutella ：协议</h5><ul>
<li>在 已有的 TCP 连接上发送查询报文</li>
<li>对等方转发查询报文</li>
<li>以反方向返回查询命中报文</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506221504062.png"
                      alt="image-20230506221504062" style="zoom:67%;" 
                >





<h5 id="Gnutella-：对等方加入"><a href="#Gnutella-：对等方加入" class="headerlink" title="Gnutella ：对等方加入"></a>Gnutella ：对等方加入</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506221758343.png"
                      alt="image-20230506221758343" style="zoom:67%;" 
                >



<h4 id="利用不匀称性：-KaZaA"><a href="#利用不匀称性：-KaZaA" class="headerlink" title="利用不匀称性： KaZaA"></a>利用不匀称性： KaZaA</h4><ul>
<li>每个对等方要么是一个组长，要么隶属于一个组长<ul>
<li>对等方与其组长之间有 TCP 连接</li>
<li>组长对之间有 TCP 连接</li>
</ul>
</li>
<li>组长跟踪其所有的孩子的内容</li>
<li>组长与其他组长取得联系<ul>
<li>转发查询到其他组长</li>
<li>获取其他组长的数据拷贝</li>
</ul>
</li>
</ul>
<h5 id="KaZaA-查询"><a href="#KaZaA-查询" class="headerlink" title="KaZaA : 查询"></a>KaZaA : 查询</h5><ul>
<li>每个文件有一个散列标识码和一个描述符</li>
<li>客户端向其组长发送关键字查询</li>
<li>组长用匹配进行响应<ul>
<li><strong>对每个匹配：元数据、散列标识码和 IP 地址</strong></li>
</ul>
</li>
<li>如果组长将查询转发给其他组长，其他组长以匹配进行响应</li>
<li>客户端选择要下载的 文件<ul>
<li><strong>向拥有文件的对等方发送一个 带散列标识码的 HTTP 请求</strong></li>
</ul>
</li>
</ul>
<p>KaZaA小技巧</p>
<ul>
<li>请求排队<ul>
<li>限制并行上载的数量</li>
<li>确保每个被传输的文件从上载节点接收一定量的带宽</li>
</ul>
</li>
<li>激励优先权<ul>
<li>鼓励用户上载文件</li>
<li>加强系统的扩展性</li>
</ul>
</li>
<li>并行下载<ul>
<li>从多个对等方下载同一文件的不同部分<ul>
<li>HTTP 的字节范围首部</li>
<li>更快的检索一个文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Distribution-Hash-Table（DHT）"><a href="#Distribution-Hash-Table（DHT）" class="headerlink" title="Distribution Hash Table（DHT）"></a>Distribution Hash Table（DHT）</h5><ul>
<li>哈希表</li>
<li>DHT方案</li>
<li>环形 DHT 以及覆盖网络</li>
<li>Peer 波动</li>
</ul>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><hr>
<p>视频流化服务和 CDN： 上下文</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506222722496.png"
                      alt="image-20230506222722496" style="zoom:67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506222745351.png"
                      alt="image-20230506222745351" style="zoom:67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506222759763.png"
                      alt="image-20230506222759763" style="zoom:67%;" 
                >



<h4 id="存储视频的-流化服务"><a href="#存储视频的-流化服务" class="headerlink" title="存储视频的 流化服务"></a>存储视频的 流化服务</h4><p>简单场景</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506222825359.png"
                      alt="image-20230506222825359" style="zoom:67%;" 
                >



<h4 id="多媒体流化服务"><a href="#多媒体流化服务" class="headerlink" title="多媒体流化服务"></a>多媒体流化服务</h4><ul>
<li><strong>DASH</strong> ： Dynamic Adaptive Streaming over HTTP</li>
<li>服务器<ul>
<li>将视频文件分割成多个小块</li>
<li>每个块独立存储，编码于不同码率（8 - 10 种）</li>
<li>告示文件（manifest file) ： 提供不同块的 URL</li>
</ul>
</li>
<li>客户端<ul>
<li>先获取告示文件</li>
<li>周期性的测量服务器到客户端的带宽</li>
<li>查询告示文件，在一个时刻请求一个块，HTTP 头部指定字节范围<ul>
<li>如果带宽足够，选择最大码率的视频块</li>
<li>会话中的不同时刻，可以切换为不同的编码块（取决于当时的可用带宽）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="流式多媒体技术：DASH"><a href="#流式多媒体技术：DASH" class="headerlink" title="流式多媒体技术：DASH"></a>流式多媒体技术：DASH</h5><ul>
<li>“智能” 客户端：客户端自适应决定<ul>
<li>什么时候去请求块（不至于缓存挨饿，或者溢出）</li>
<li>请求 什么编码速率的视频块（当带宽足够时，选择高质量的）</li>
<li>哪里去请求块（可以向离自己近的服务器发送 URL，或者向高可用带宽的服务器请求）</li>
</ul>
</li>
</ul>
<h5 id="Content-Distribution-Networks"><a href="#Content-Distribution-Networks" class="headerlink" title="Content Distribution Networks"></a>Content Distribution Networks</h5><ul>
<li><strong>挑战</strong>：服务器如何通过网络向上百万用户同时流化视频内容（上百万视频内容）</li>
<li><strong>选择1</strong>：单个的、大的超级服务中心<ul>
<li>服务器 到客户端 路径上跳数越多瓶颈链路的带宽小导致停顿</li>
<li>“二八规律” 决定了网络同时充斥着同一个视频的多个拷贝</li>
<li>单点故障点，性能瓶颈</li>
<li>周边网络的拥塞</li>
</ul>
</li>
<li><strong>选择2：</strong> 通过 <strong><font color='red'>CDN</font></strong>，全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验<ul>
<li>enter deep： 将 cdn 服务器深入到许多接入网<ul>
<li>更接近用户，数量多，离用户近，管理困难</li>
</ul>
</li>
<li>bring home : 部署在少数（10 个左右）关键位置，如将服务器簇安装在 POP 附近<ul>
<li>采用 租用线路将服务器簇连接起来</li>
<li>LimeLight</li>
</ul>
</li>
</ul>
</li>
<li><strong>CDN：</strong> 在 CDN 节点中存储内容的多个拷贝</li>
<li>用户在CDN 中请求内容<ul>
<li>重定向到最近的拷贝，请求内容</li>
<li>如果网络路径拥塞，可能选择不同的拷贝</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506224623899.png"
                      alt="image-20230506224623899" style="zoom:67%;" 
                >



<ul>
<li><p>OTT 挑战：在拥塞的网络上复制内容</p>
<ul>
<li>从哪个CDN上 获取内容</li>
<li>用户在网络拥塞时的行为</li>
<li>在哪些cdn 节点存储什么内容</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506224740295.png"
                      alt="image-20230506224740295" style="zoom:67%;" 
                ></li>
</ul>
<h5 id="CDN：-“简单”-内容访问场景"><a href="#CDN：-“简单”-内容访问场景" class="headerlink" title="CDN： “简单” 内容访问场景"></a>CDN： “简单” 内容访问场景</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506224816656.png"
                      alt="image-20230506224816656" style="zoom: 67%;" 
                >



<h3 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h3><hr>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506225339784.png"
                      alt="image-20230506225339784" style="zoom:80%;" 
                >

<p>应用进程使用 传输层提供的服务才能够交换报文，实现应用协议，实现应用</p>
<p>TCP&#x2F;IP : 应用进程使用 Socket API 访问传输服务</p>
<p>地点：界面上的 SAP（Socket）  方式： Socket API</p>
<p><strong>目标：</strong> 学习如何构建能借助 socket 进行通信的 c&#x2F;s 应用程序</p>
<p><strong>socket：</strong> 分布式应用进程之间的门，传输层协议提供的端到端服务接口</p>
<br>

<p><font color='cornflowerblue'>两种传输层服务的 socket 类型</font></p>
<ul>
<li><font color='red'><strong>TCP：</strong></font> 可靠的、字节流的服务</li>
<li><font color='red'>**UDP: **</font>不可靠（数据UDP 数据报）服务</li>
</ul>
<h4 id="TCP-Socket-编程"><a href="#TCP-Socket-编程" class="headerlink" title="TCP Socket 编程"></a>TCP Socket 编程</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506225721179.png"
                      alt="image-20230506225721179" style="zoom:50%;" 
                >

<p><font color='red'><u>套接字</u></font>：应用进程与端到端传输协议（TCP或 UDP）之间的门户</p>
<p><font color='red'><u>TCP服务</u></font>： 从一个进程向另外一个进程可靠地传输 <strong>字节流</strong></p>
<br>

<p><font color='red'><strong>服务器首先运行，等待连接建立</strong></font></p>
<p><u>1、服务器进程必须先处于运行状态</u></p>
<ul>
<li>**创建 ** 欢迎socket （serverSocket)</li>
<li>和本地端口 <strong>绑定</strong></li>
<li>在 欢迎 socket 上阻塞式  <strong>等待接收</strong> 用户的连接</li>
</ul>
<br>

<p><font color='red'><strong>客户端主动和服务器建立连接</strong></font></p>
<p><u>2、<strong>创建</strong>客户端 本地套接字（<strong>隐式捆绑到</strong> 本地 port)</u></p>
<ul>
<li>指定服务器进程的 IP地址 和端口号，与服务器进程 <strong>连接</strong></li>
</ul>
<br>

<p><u>3、当与客户端连接请求到时</u></p>
<ul>
<li><p>服务器 <strong>接收</strong> 来自 用户端的请求，接触阻塞式等待，返回一个 新的  socket（与欢迎 socket 不同），与客户端通信</p>
<ul>
<li>允许服务器与多个客户端通信</li>
<li>使用 源 IP 和 源端口 来区分不同的 客户端</li>
</ul>
<blockquote>
<p>从应用程序的角度</p>
<p><font color='cornflowerblue'>TCP 在客户端与服务器进程之间提供了可靠的、字节流（管道）服务</font></p>
</blockquote>
</li>
</ul>
<br>

<p><u>4、连接 API 调用有效时，客户端与服务器建立了 TCP 连接</u></p>
<h5 id="C-S-模式的应用样例"><a href="#C-S-模式的应用样例" class="headerlink" title="C&#x2F;S 模式的应用样例"></a>C&#x2F;S 模式的应用样例</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506231630040.png"
                      alt="image-20230506231630040" style="zoom:67%;" 
                >

<ol>
<li>客户端从标准输入装置读取一行字符，发送给服务器</li>
<li>服务器从socket 读取 字符</li>
<li>服务器将字符 转换成 大写 然后返回给客户端</li>
<li>客户端 从socket 中 读取一行字符，然后打印出来</li>
</ol>
<h5 id="socket-交互-：-tcp"><a href="#socket-交互-：-tcp" class="headerlink" title="socket 交互 ： tcp"></a>socket 交互 ： tcp</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506231720154.png"
                      alt="image-20230506231720154" style="zoom:80%;" 
                >



<h6 id="数据结构-sockaddr-in"><a href="#数据结构-sockaddr-in" class="headerlink" title="数据结构 sockaddr_in"></a>数据结构 sockaddr_in</h6><p><font color='red'><strong>Ip  地址和 port 捆绑关系的数据结构（标识进程的端节点）</strong></font></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506232009148.png"
                      alt="image-20230506232009148" style="zoom:50%;" 
                >



<h6 id="数据结构-hostent"><a href="#数据结构-hostent" class="headerlink" title="数据结构 hostent"></a>数据结构 hostent</h6><p><font color='red'><strong>域名和IP地址 的数据结构</strong></font></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506232048726.png"
                      alt="image-20230506232048726" style="zoom:50%;" 
                >

<blockquote>
<p>作为 调用域名解析函数时的参数</p>
<p>返回后，将 IP地址拷贝到 sockaddr_in 的 IP 地址部分</p>
</blockquote>
<h6 id="C-客户端（TCP）"><a href="#C-客户端（TCP）" class="headerlink" title="C 客户端（TCP）"></a>C 客户端（TCP）</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506232253034.png"
                      alt="image-20230506232253034" style="zoom:67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506232303129.png"
                      alt="image-20230506232303129" style="zoom:67%;" 
                >

 

<h6 id="C-服务器-（TCP）"><a href="#C-服务器-（TCP）" class="headerlink" title="C 服务器 （TCP）"></a>C 服务器 （TCP）</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506232330076.png"
                      alt="image-20230506232330076" style="zoom:67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506232648977.png"
                      alt="image-20230506232648977" style="zoom:67%;" 
                >



<h4 id="UDP-Socket-编程"><a href="#UDP-Socket-编程" class="headerlink" title="UDP Socket 编程"></a>UDP Socket 编程</h4><p><font color='red'><strong>UDP：在客户端与服务器之间没有连接</strong></font></p>
<ul>
<li>没有握手</li>
<li>发送端在每一个报文中明确地 指定目标的 IP 地址和端口号</li>
<li>服务器 必须从 收到的分组中 提取出发送端的 IP 地址和 端口号</li>
</ul>
<blockquote>
<p><font color='red'>从 进程角度看 UDP 服务</font></p>
<p><font color='cornflowerblue'>UDP 为 客户端和服务器端提供  不可靠的 字节组的传送服务</font></p>
<p><font color='red'><strong>UDP： 传送的数据可能 乱序，也可能丢失</strong></font></p>
</blockquote>
<h5 id="c-s-socket-交互：-udp"><a href="#c-s-socket-交互：-udp" class="headerlink" title="c&#x2F;s socket 交互： udp"></a>c&#x2F;s socket 交互： udp</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506233639309.png"
                      alt="image-20230506233639309"
                ></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230506233929540.png"
                      alt="image-20230506233929540" style="zoom: 50%;" 
                >



<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><hr>
<ul>
<li>应用程序体系结构<ul>
<li>客户-服务器</li>
<li>P2P</li>
<li>混合</li>
</ul>
</li>
<li>应用程序需要的服务品质描述<ul>
<li>可靠性</li>
<li>带宽</li>
<li>延时</li>
<li>安全</li>
</ul>
</li>
<li>Internet 传输层服务模式<ul>
<li>可靠的、面向连接的服务： TCP</li>
<li>不可靠的数据报：UDP</li>
</ul>
</li>
<li>流行的应用层协议<ul>
<li>HTTP</li>
<li>FTP</li>
<li>SMTP 、POP、IMAP</li>
<li>DNS</li>
</ul>
</li>
<li>Socket 编程</li>
</ul>
<br>

<p><font color='red'><strong>更重要的：学习协议的知识</strong></font></p>
<ul>
<li>应用层协议报文类型：请求&#x2F;响应报文：<ul>
<li>客户端请求信息或服务</li>
<li>服务器以数据、状态码进行响应</li>
</ul>
</li>
<li>报文格式<ul>
<li>首部：关于数据信息的字段</li>
<li>数据：被交换的信息</li>
</ul>
</li>
<li>控制报文 vs 数据报文<ul>
<li>带内 、 带外</li>
</ul>
</li>
<li>集中式 vs 分布式</li>
<li>无状态 vs  维护状态</li>
<li>可靠的 vs  不可靠的报文传输</li>
<li>在网络边缘处理复杂性</li>
</ul>
<blockquote>
<p><font color='cornflowerblue'>一个协议定义了在两个或多个通信实体之间交换报文的和次序，以及就一条报文传输和接收或其他事情采取的动作</font></p>
</blockquote>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>运输层位于 应用层和网络层之间，是分层的网络体系结构的重要部分。  <strong>该层为 运行在不同主机上的应用进程提供直接的 通信服务起着至关重要的作用</strong>。</p>
<blockquote>
<p>“<font color='red'><strong>关注运输是什么，他如何工作，为什么这么做</strong></font>”</p>
</blockquote>
<br>

<p><font color='red'><u>目标</u></font>：</p>
<ul>
<li>理解传输层的工作原理</li>
<li>多路复用&#x2F;解复用</li>
<li>可靠数据传输</li>
<li>流量控制</li>
<li>拥塞控制</li>
<li>学习 Internet 的传输层协议<ul>
<li>UDP ：无连接传输</li>
<li>TCP ：面向连接的 可靠性传输</li>
<li>TCP 的拥塞控制</li>
</ul>
</li>
</ul>
<h3 id="概述和传输层服务"><a href="#概述和传输层服务" class="headerlink" title="概述和传输层服务"></a>概述和传输层服务</h3><hr>
<p>运输层协议为 运行在 不同主机上的应用进程 之间 提供了 <strong>逻辑通信（logic communication）</strong> 功能。</p>
<h4 id="传输服务和协议"><a href="#传输服务和协议" class="headerlink" title="传输服务和协议"></a>传输服务和协议</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507112522829.png"
                      alt="image-20230507112522829" style="zoom: 67%;" 
                >

<ul>
<li>运输层协议为 运行在 不同主机上的应用进程 之间 提供了 <strong>逻辑通信（logic communication）</strong> 功能。</li>
<li>传输协议 运行在端系统<ul>
<li>发送方： 将应用层的报文 分成 <strong>报文段</strong>，然后传递给网络层</li>
<li>接收方：将报文段重组成报文。然后传递给应用层</li>
</ul>
</li>
<li>有多个传输层协议可供选择<ul>
<li>Internet ： TCP 和 UDP</li>
</ul>
</li>
</ul>
<h4 id="传输层和网络层之间的关系"><a href="#传输层和网络层之间的关系" class="headerlink" title="传输层和网络层之间的关系"></a>传输层和网络层之间的关系</h4><p>前面讲过，在 <strong>协议栈</strong>中，运输层刚好位于网络层之上。 网络层提供了主机之间的 逻辑通信，而运输层为 运行在不同主机上的进程之间提供了 逻辑通信</p>
<ul>
<li><font color='cornflowerblue'>网络层服务</font>：主机之间的 逻辑通信</li>
<li><font color='cornflowerblue'>运输层服务：</font>进程之间的逻辑通信<ul>
<li>依赖于 网络层的服务<ul>
<li>延时、带宽</li>
</ul>
</li>
<li>并对网络层的服务进行增强<ul>
<li>数据丢失、顺序混乱、加密</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><font color='red'>**有些服务是可以被加强的：不可靠 - &gt; 可靠；  安全 **</font></p>
<p><font color='red'><strong>但有些服务是不可以被加强的：带宽、延迟</strong></font></p>
</blockquote>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507113322554.png"
                      alt="image-20230507113322554" style="zoom:80%;" 
                >

<br>

<p>运输协议能够提供的服务常常受制于底层网络层协议的服务模型。如果网络层协议无法为主机之间发送的运输层报文段提供时延和带宽保证的话，运输层协议也就无法为进程之间发送的应用程序报文提供时延和带宽保证</p>
<p>然而，即使底层网络协议不能在网络层提供相应的服务，运输层协议也能提供某些服务。例如，即使底层网络协议是不可靠的，也就是说网络层协议会使分组丢失、墓改和允余，运输协议也能为应用程序提供可靠的数据传输服务。另一个例子是,即使网络层不能保证运输层报文段的机密性，运输协议也能使用加密来确保应用程序报文不被入侵者读取。</p>
<h4 id="Internet-传输层协议"><a href="#Internet-传输层协议" class="headerlink" title="Internet 传输层协议"></a>Internet 传输层协议</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507114213575.png"
                      alt="image-20230507114213575" style="zoom: 80%;" 
                >

<p>在对UDP和TCP进行简要介绍之前，简单介绍一下因特网的网络层是有用的。因特网网络层协议有一个名字叫IP,即网际协议。IP为主机之间提供了逻辑通信。IP的服务模型是<strong>尽力而为交付</strong>服务（best-effort delivery service)。这意味着IP尽它“最大的努力”在通信的主机之间交付报文段，但它<strong>并不做任何确保</strong>。特别是，它<strong>不确保报文段的交付，不保证报文段的按序交付，不保证报文段中数据的完整性</strong>。由于这些原因，<strong>IP被称为不可靠服务</strong>（unreliable service)。在此还要指出的是，每台主机至少有一个网络层地址，即所谓的IP地址。在这一章中，<font color='red'><strong>只需要记住每台主机都有一个 IP 地址</strong></font></p>
<ul>
<li>可靠的、保序的传输 ：TCP<ul>
<li>多路复用、解复用</li>
<li>拥塞控制</li>
<li>流量控制</li>
<li>建立连接</li>
</ul>
</li>
<li>不可靠的、不保序的传输：UDP <ul>
<li>多路复用、解复用</li>
<li>没有尽力而为的 IP 服务添加更多的其他额外服务</li>
</ul>
</li>
<li>都不提供的服务<ul>
<li>延时保证</li>
<li>带宽保证</li>
</ul>
</li>
</ul>
<p>在对 IP 有了初步的了解之后。总结一下 TCP 和 UDP 所提供的 服务模型。 UDP 和 TCP 最基本的责任是  <strong><u>将两个端系统间 IP 的交付服务扩展到运行在端系统上的两个进程之间的交互服务。将主机间交付扩展到进程之间的交付被称为  <font color='red'>运输层的多路复用 与 多路分解</font></u></strong></p>
<h3 id="多路复用与解复用"><a href="#多路复用与解复用" class="headerlink" title="多路复用与解复用"></a>多路复用与解复用</h3><hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507115247237.png"
                      alt="image-20230507115247237"
                ></p>
<p>在本节中，我们讨论运输层的多路复用与多路分解，也就是将<strong>由网络层提供的主机到主机交付服务延伸到为运行在主机上的应用程序提供进程到进程的交付服务</strong>。为了使讨论具体，我们将在因特网环境中讨论这种基本的运输层服务。然而，需要强调的是，<strong>多路复用与多路分解服务是所有计算机网络都需要的</strong>。</p>
<p>在 socket 中，一个进程（作为网络应用的一部分）有一个或多个套接字(socket),它相当于从网络向进程传递数据和从进程向网络传递数据的门户。因此，如图3-2所示，在接收主机中的运输层实际上并没有直接将数据交付给进程，而是将数据交给了一个中间的套接字。由于在任一时刻，在接收主机上可能有不止一个套接字，所以每个套接字都有唯一的标识符。标识符的格式取决于它是UDP还是TCP套接字</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507115631806.png"
                      alt="image-20230507115631806" style="zoom:80%;" 
                >



<blockquote>
<p>一个 进程有 1 or 多个 socket</p>
<p>每个 socket都有唯一标识符</p>
</blockquote>
<h4 id="多路解复用"><a href="#多路解复用" class="headerlink" title="多路解复用"></a>多路解复用</h4><h5 id="多路解复用工作原理"><a href="#多路解复用工作原理" class="headerlink" title="多路解复用工作原理"></a>多路解复用工作原理</h5><ul>
<li>解复用作用：tcp 或者 udp 实体采用那些信息，将报文段的数据部分交给正确的 socket。从而交给正确的进程</li>
<li>主机收到 IP 数据报<ul>
<li>每个数据报有 源IP地址 和 目标地址</li>
<li>每个数据源承载一个传输层报文段</li>
<li>每个报文段有一个原端口号和 目标端口号<ul>
<li>端口号的 数量为 0 ~ 65535      0 ~ 1023  为周知端口号</li>
</ul>
</li>
</ul>
</li>
<li>主机联合使用 <strong>IP地址</strong> 和 <strong>端口号</strong> 将报文段 发送给适合的 socket</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507120221966.png"
                      alt="image-20230507120221966"
                ></p>
<p><font color='red'><strong>UDP 和 TCP 不同</strong></font></p>
<p>现在应该清楚运输层是怎样能够实现分解服务的了：在主机上的每个套接字能够分一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入其所连接的进程。如我们将看到的那样，UDP大体上是这样做的。然而，也将如我们所见，TCP中的多路复用与多路分解更为复杂。</p>
<h5 id="无连接的多路解复用"><a href="#无连接的多路解复用" class="headerlink" title="无连接的多路解复用"></a>无连接的多路解复用</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507133131368.png"
                      alt="image-20230507133131368"
                ></p>
<ul>
<li><p>创建套接字</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507132635212.png"
                      alt="image-20230507132635212"
                ></p>
<p> serverSocket 和 sad  指定的端口号 捆绑</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507132722858.png"
                      alt="image-20230507132722858"
                ></p>
<p>没有 bind ，clientSocket 和 os 为之分配的某个端口号捆绑（客户端使用什么端口号无所谓，客户端主动找服务器）</p>
</li>
<li><p>在 接收端，udp 套接字用二元组 标识（<strong>目标IP 地址和 目标端口号）</strong></p>
</li>
<li><p>当主机收到 UDP 报文段</p>
<ul>
<li>检查报文段的目标端口号</li>
<li>用该 端口号将报文段定位给 socket</li>
</ul>
</li>
<li><p>如果两个不同源 IP 地址&#x2F; 源端口号 的数据报，但是 有相同的目标IP 地址和目标端口号，则被定位到相同的 socket</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507133148728.png"
                      alt="image-20230507133148728"
                ></p>
<h4 id="面向连接的-多路复用和多路分解"><a href="#面向连接的-多路复用和多路分解" class="headerlink" title="面向连接的 多路复用和多路分解"></a>面向连接的 多路复用和多路分解</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507133911747.png"
                      alt="image-20230507133911747"
                ></p>
<p>为了 理解 TCP 的多路分解，我们必须更加仔细地研究 TCP socket 和 TCP 连接创建。TCP socket 和 UDP socket 之间一个细微的差别是 <strong>TCP socket 是由一个四元组来标识的</strong></p>
<ul>
<li>TCP socket：四元组本地标识<ul>
<li>源IP 地址</li>
<li>源 端口号</li>
<li>目标 IP 地址</li>
<li>目标 端口号</li>
</ul>
</li>
<li>解复用：接收主机用这四个值来将数据报定位到合适 的 socket</li>
<li>服务器能在一个 TCP 端口上同时支持多个 tcp socket<ul>
<li>每个 socket 由其四元组标识</li>
</ul>
</li>
<li>web 服务器对每个连接客户端都有不同的socket<ul>
<li>非持久对每个请求有不同的 socket</li>
</ul>
</li>
</ul>
<p>服务器主机可以支持很多并行的TCP套接字，每个套接字与一个进程相联系，并由其四元组来标识每个套接字。当一个TCP报文段到达主机时，所有4个字段（源IP地址，源端口，目的IP地址，目的端口）被用来将报文段定向（分解）到相应的套接字。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507133941436.png"
                      alt="image-20230507133941436" style="zoom: 67%;" 
                >



<h5 id="面向连接的多路复用：-多线程-web-server"><a href="#面向连接的多路复用：-多线程-web-server" class="headerlink" title="面向连接的多路复用： 多线程 web server"></a>面向连接的多路复用： 多线程 web server</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507134029591.png"
                      alt="image-20230507134029591"
                ></p>
<ul>
<li>一个进程下面可能有多个线程： 由多个线程分别为客户提供服务</li>
<li>在这个场景下，还是根据 4 元组决定将报文段内容 定向 到 同一个进程下的不同线程</li>
<li>解复用到不同线程</li>
</ul>
<h3 id="无连接传输：UDP"><a href="#无连接传输：UDP" class="headerlink" title="无连接传输：UDP"></a>无连接传输：UDP</h3><hr>
<p>由 [RFC768] 定义的  UDP  只是做了<strong>运输协议能够做的最少工作</strong>。除了<strong>复用&#x2F;分解功能及少量的差错检测外</strong>，它几乎没有对IP增加别的东西。实际上，如果应用程序开发人员选择UDP而不是TCP,则该应用程序差不多就是<strong>直接与IP打交道</strong>。UDP从应用进程得到数据，附加上用于多路复用&#x2F;分解服务的源和目的端口号字段，以及两个其他的小字段然后将形成的报文段交给网络层。网络层将该运输层报文段封装到一个IP数据报中，然后尽力而为地尝试将此报文段交付给接收主机。如果该报文段到达接收主机，UDP使用目的端口号将报文段中的数据交付给正确的应用进程。值得注意的是，使用UDP时，<u>在发送报文段之前，发送方和接收方的运输层实体之间没有握手</u>。正因为如此，<strong>UDP被称为是无连接的。</strong></p>
<ul>
<li>尽力而为 服务，报文可能<ul>
<li>丢失</li>
<li>乱序</li>
</ul>
</li>
<li>无连接<ul>
<li>UDP 发送端与接收端之间没有握手</li>
<li>每个UDP 报文段都被独立地 处理</li>
</ul>
</li>
</ul>
<br>

<ul>
<li>UDP 被用于<ul>
<li>流媒体（丢失不敏感，速率敏感、应用可控制传输速率）</li>
<li>DNS</li>
<li>SNMP</li>
</ul>
</li>
<li>在 UDP 上可行可靠传输<ul>
<li>在应用层增加 可靠性</li>
<li>应用特定的差错恢复</li>
</ul>
</li>
</ul>
<h4 id="UDP：-用户数据报协议"><a href="#UDP：-用户数据报协议" class="headerlink" title="UDP： 用户数据报协议"></a>UDP： 用户数据报协议</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507135051078.png"
                      alt="image-20230507135051078"
                ></p>
<p> <font color='red'><strong>为什么要有 UDP</strong></font></p>
<ul>
<li>不建立连接（会增加延时）</li>
<li>简单：在发送端和接收端没有连接状态</li>
<li>报文段的头部很小（开销小）</li>
<li>无拥塞控制和流量控制 ： UDP 可以尽可能快 的发送报文段<ul>
<li>应用 -&gt; 传输的速率 &#x3D; 主机 -&gt; 网络的速率</li>
</ul>
</li>
</ul>
<h4 id="UDP-校验和"><a href="#UDP-校验和" class="headerlink" title="UDP 校验和"></a>UDP 校验和</h4><p>你可能想知道为什么UDP首先提供了检验和，就像许多链路层协议（包括流行的以太网协议）也提供了差错检测那样。其原因是不能保证源和目的之间的所有链路都提供差错检测；这就是说，也许这些链路中的一条可能使用没有差错检测的协议。此外，即使报文段经链路正确地传输，当报文段存储在某台路由器的内存中时，也可能引入比特差错。在既无法确保逐链路的可靠性，又无法确保内存中的差错检测的情况下，如果端到端数据传输服务要提供差错检测，UDP就必须在端到端基础上在运输层提供差错检测。这是一个在系统设计中被称颂的   <strong>端到端原则</strong>  （end-end principle)的例子[Saltzer1984],该原则表述为因为某种功能（在此时为差错检测）必须基于端到端实现：“与在较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是沉余的或几乎没有价值的。”</p>
<p><font color='red'><u>目的</u></font>：检测在被传输报文段中的差错（比如 比特反转）</p>
<p><font color='red'>发送方</font></p>
<ul>
<li>将报文段的内容视为 16 比特的 整数</li>
<li>校验和：报文段的加法和（ 1  的 补运算）</li>
<li>发送方将校验和放在UDP 的校验和字段</li>
</ul>
<br>

<p><font color='red'>接收方</font></p>
<ul>
<li>计算得到的报文段的 校验和</li>
<li>检查 计算出的 校验和 与 校验和字段的内容是否相等<ul>
<li>不相等  –  检测到 差错</li>
<li>相等  – 没有检测到 差错，但也许还是有差错<ul>
<li>残存错误</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507140222737.png"
                      alt="image-20230507140222737"
                ></p>
<p>因为 假定 IP 是可以 运行 在 任何第二层协议之上的，运输层 提供 差错检测作为一种保险措施时非常有用的。虽然 UDP 提供 差错检测，但他对 差错恢复无能为力。UDP 的某种 实现  <strong>只是丢弃了 受损的报文段</strong>；其他 实现则是将受损的 报文段交给应用程序并且 <strong>给出警告</strong></p>
<h3 id="可靠数据传输-rdt-的原理"><a href="#可靠数据传输-rdt-的原理" class="headerlink" title="可靠数据传输(rdt)的原理"></a>可靠数据传输(rdt)的原理</h3><hr>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507140925434.png"
                      alt="image-20230507140925434" style="zoom:80%;" 
                >



<p>图3-8图示说明了我们学习可靠数据传输的框架。为上层实体提供的服务抽象是：<strong>数据可以通过一条可靠的信道进行传输。借助于可靠信道，传输数据比特就不会受到损坏(由0变为1,或者相反）或丢失，而且所有数据都是按照其发送顺序进行交付</strong>。这恰好就是TCP向调用它的因特网应用所提供的服务模型。</p>
<ul>
<li>rdt 在 应用层、运输层和数据链路层都很重要</li>
<li>是 网络 Top 10 问题之一</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507220034664.png"
                      alt="image-20230507220034664" style="zoom: 33%;" 
                >

<ul>
<li>信道的不可靠性决定了可靠数据传输协议（rdt) 的复杂性</li>
</ul>
<h4 id="可靠数据传输：问题描述"><a href="#可靠数据传输：问题描述" class="headerlink" title="可靠数据传输：问题描述"></a>可靠数据传输：问题描述</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507220410334.png"
                      alt="image-20230507220410334" style="zoom:50%;" 
                >

<p>我们将：</p>
<ul>
<li>渐增式开发可靠数据传输协议 的发送方和接收方</li>
<li>只考虑单向数据传输<ul>
<li>但控制信息是双向流动的</li>
</ul>
</li>
<li>双向的 数据传输问题实际上是两个 单向数据传输问题的综合</li>
<li>使用 有限状态机（FSM） 来描述发送方和接收方</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507220801599.png"
                      alt="image-20230507220801599" style="zoom: 67%;" 
                >





<h4 id="Rdt-1-0-：在可靠信道上的可靠数据传输"><a href="#Rdt-1-0-：在可靠信道上的可靠数据传输" class="headerlink" title="Rdt 1.0 ：在可靠信道上的可靠数据传输"></a>Rdt 1.0 ：在可靠信道上的可靠数据传输</h4><ul>
<li>下层的信道是完全可靠的<ul>
<li>没有比特出错</li>
<li>没有分组丢失</li>
</ul>
</li>
<li>发送方和接收方的 FSM<ul>
<li>发送方将数据发送到下层信道</li>
<li>接收方从下层信道接收数据</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230507221333305.png"
                      alt="image-20230507221333305" style="zoom: 50%;" 
                >



<h4 id="Rdt2-0-具有比特差错的信道"><a href="#Rdt2-0-具有比特差错的信道" class="headerlink" title="Rdt2.0: 具有比特差错的信道"></a>Rdt2.0: 具有比特差错的信道</h4><ul>
<li><p>下层信道可能会出错：将分组中的 比特 翻转</p>
<ul>
<li>用校验和 来检测 比特差错</li>
</ul>
</li>
<li><p>问题：怎样从差错中恢复</p>
<ul>
<li><font color='red'>确认（ACK）</font>: 接收方显式告诉发送方分组已被正确接收</li>
<li><font color='red'>否定确认（NAK）</font>: 接收方显式的 告诉发送方 发生了 差错<ul>
<li>发送方 收到 NAK 后，发送方重传分组</li>
</ul>
</li>
</ul>
</li>
<li><p>rdt 2.0 中的新机制：采用 差错控制编码进行差错检测</p>
</li>
<li><p>发送方差错控制编码、缓存</p>
</li>
<li><p>接收方使用  编码检错</p>
</li>
<li><p>接收方的 反馈：控制报文（ACK、NAK）：接收方 -&gt; 发送方</p>
</li>
<li><p>发送方收到反馈相应的 动作</p>
</li>
</ul>
<h5 id="FSM-描述"><a href="#FSM-描述" class="headerlink" title="FSM 描述"></a>FSM 描述</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509223226589.png"
                      alt="image-20230509223226589" style="zoom: 67%;" 
                >



<h6 id="没有差错时的操作"><a href="#没有差错时的操作" class="headerlink" title="没有差错时的操作"></a>没有差错时的操作</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509223308875.png"
                      alt="image-20230509223308875" style="zoom:67%;" 
                >



<h6 id="有差错的操作"><a href="#有差错的操作" class="headerlink" title="有差错的操作"></a>有差错的操作</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509223639884.png"
                      alt="image-20230509223639884" style="zoom:67%;" 
                >



<h4 id="rdt2-1-rdt2-0-的致命缺陷"><a href="#rdt2-1-rdt2-0-的致命缺陷" class="headerlink" title="rdt2.1 : rdt2.0 的致命缺陷"></a>rdt2.1 : rdt2.0 的致命缺陷</h4><p><font color='red'>如果 ack &#x2F; nak 出错</font></p>
<ul>
<li>发送方不知道接收方发生了什么事情</li>
<li>发送方如何做<ul>
<li>重传？可能重复</li>
<li>不重传？可能死锁（或出错）</li>
</ul>
</li>
<li>需要引入新的机制<ul>
<li>序号（sequence number）</li>
</ul>
</li>
</ul>
<br>

<p><font color='red'>处理重复</font></p>
<ul>
<li>发送方在每个分组中加入 <strong>序号</strong></li>
<li>如果 ack &#x2F; nak 出错，发送方  <strong>重传 当前分组</strong></li>
<li>接收方丢弃（不发给上层）重复分组</li>
</ul>
<blockquote>
<p><font color='red'><strong>stop and wait  protocol（停等协议）</strong></font></p>
<p>发送方发送一个分组，然后等待接受方的应答</p>
</blockquote>
<h5 id="rdt2-1-：-发送方处理出错的-ACK-NAK"><a href="#rdt2-1-：-发送方处理出错的-ACK-NAK" class="headerlink" title="rdt2.1 ： 发送方处理出错的 ACK &#x2F; NAK"></a>rdt2.1 ： 发送方处理出错的 ACK &#x2F; NAK</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509224212902.png"
                      alt="image-20230509224212902" style="zoom:67%;" 
                >

<h5 id="rdt2-1-：接收方处理出错的-ACK-NAK"><a href="#rdt2-1-：接收方处理出错的-ACK-NAK" class="headerlink" title="rdt2.1 ：接收方处理出错的 ACK &#x2F; NAK"></a>rdt2.1 ：接收方处理出错的 ACK &#x2F; NAK</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509224249938.png"
                      alt="image-20230509224249938" style="zoom:67%;" 
                >



<h5 id="rdt2-1-：讨论"><a href="#rdt2-1-：讨论" class="headerlink" title="rdt2.1 ：讨论"></a>rdt2.1 ：讨论</h5><p><font color='red'><strong>发送方</strong></font></p>
<ul>
<li>在分组中加入序列号</li>
<li>两个序列号（0,1） 就足够了<ul>
<li>一次只发送一个未经确认的 分组</li>
</ul>
</li>
<li>必须检测 ACK &#x2F; NAK 是否 出错（需要  EDC）</li>
<li>状态数 变成了 两倍<ul>
<li>必须记住当前分组的序列是 0 还是 1</li>
</ul>
</li>
</ul>
<br>

<p><font color='red'><strong>接收方</strong></font></p>
<ul>
<li>必须检测 接收到的 分组是否是重复的<ul>
<li>状态会指示 希望接收到的 分组序号是 0 还是 1</li>
</ul>
</li>
<li>注意 ：接收方并不知道 发送方是否正确接收到 了 其 ACK  &#x2F;  NAK <ul>
<li>没有安排 确认的 确认（ 没有 “必要 ”）</li>
</ul>
</li>
</ul>
<h5 id="rdt2-1-的-运行"><a href="#rdt2-1-的-运行" class="headerlink" title="rdt2.1 的 运行"></a>rdt2.1 的 运行</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509224709088.png"
                      alt="image-20230509224709088" style="zoom:67%;" 
                >

<p>接收方不知道它最后发送的 ACK&#x2F; NAK 是否被正确的 收到</p>
<ul>
<li>发送方不对 收到的  ACK &#x2F; NAK 给 确认，<font color='red'><strong>没有所谓的 确认的确认</strong></font></li>
<li>接收方发送 ack ，如果后面接收方接收到的 是：<ul>
<li>老分组 p0?则 ack 错误</li>
<li>下一个分组？ p1 ，ack 正确</li>
</ul>
</li>
</ul>
<h4 id="rdt-2-2-：-无-NAK-的协议"><a href="#rdt-2-2-：-无-NAK-的协议" class="headerlink" title="rdt 2.2 ： 无 NAK 的协议"></a>rdt 2.2 ： 无 NAK 的协议</h4><ul>
<li>功能同 rdt 2.1 ，但只使用 ACK ，（ACK 要编号）</li>
<li>接收方 对 <strong>最后</strong> 正确接收的 分组 发 ack ,以代替 NAK<ul>
<li>接收方必须 显式地包含被 正确接收分组的 <strong>序号</strong></li>
</ul>
</li>
<li>当 收到 重复的 ACK  （ 如 再次收到 ack0) 时，发送方与 收到 NAK 采取 相同的动作：重传当前分组</li>
<li>为后面的一个发送多个数据单位做一个准备<ul>
<li>一次 能够发送多个</li>
<li>每一个应答都有 ：ACK、NACK ; 麻烦</li>
<li>使用对前一个数据单位的 ACK，代替本数据单位的 nak</li>
<li>确认信息减少一半，协议处理简单</li>
</ul>
</li>
</ul>
<h5 id="rdt2-2-的运行"><a href="#rdt2-2-的运行" class="headerlink" title="rdt2.2 的运行"></a>rdt2.2 的运行</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509231318294.png"
                      alt="image-20230509231318294" style="zoom:67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509231332283.png"
                      alt="image-20230509231332283" style="zoom:67%;" 
                >



<h5 id="rdt2-2-：发送方和接收方片断"><a href="#rdt2-2-：发送方和接收方片断" class="headerlink" title="rdt2.2 ：发送方和接收方片断"></a>rdt2.2 ：发送方和接收方片断</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509231403385.png"
                      alt="image-20230509231403385" style="zoom:67%;" 
                >



<h4 id="rdt-3-0-具有-比特差错的和分组丢失的-信道"><a href="#rdt-3-0-具有-比特差错的和分组丢失的-信道" class="headerlink" title="rdt 3.0 : 具有 比特差错的和分组丢失的 信道"></a>rdt 3.0 : 具有 比特差错的和分组丢失的 信道</h4><p><font color='red'><strong>新的假设</strong></font>：下层信道可能会丢失分组（数据 或 ack)</p>
<ul>
<li>会死锁</li>
<li>机制还不够处理这种状态<ul>
<li>检验和</li>
<li>序列号</li>
<li>ACK</li>
<li>重传</li>
</ul>
</li>
</ul>
<br>

<p><font color='red'><strong>方法：</strong></font>：发送方等待 ack  一段   <strong>合理的时间</strong></p>
<ul>
<li>发送方超时重传：如果到时没有收到 ack -&gt; 重传</li>
<li>问题： 如果 分组（或 ack) 只是被延迟了<ul>
<li>重传将会导致 数据重复，但是利用 <strong>序列号</strong> 已经可以处理这个问题了</li>
<li>接收方必须指明被正确接收的 序列号</li>
</ul>
</li>
<li>需要一个 <strong>倒计数定时器</strong></li>
</ul>
<h5 id="rdt3-0-发送方"><a href="#rdt3-0-发送方" class="headerlink" title="rdt3.0 发送方"></a>rdt3.0 发送方</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509231910625.png"
                      alt="image-20230509231910625" style="zoom:67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509231922070.png"
                      alt="image-20230509231922070" style="zoom:67%;" 
                >



<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509231936147.png"
                      alt="image-20230509231936147" style="zoom:67%;" 
                >

<ul>
<li>过早超时（延迟的ack）也能够 正常工作，但是效率较低，一半 的分组和确认是重复的 </li>
<li>设置一个合理的 超时时间  也是非常重要的</li>
</ul>
<h5 id="rdt3-0-的性能"><a href="#rdt3-0-的性能" class="headerlink" title="rdt3.0 的性能"></a>rdt3.0 的性能</h5><ul>
<li>rdt3.0  可以工作，但是链路容量比较大的情况下，性能很差（吞吐量低）<ul>
<li>链路容量较大，一次发一个 PDU 的不能够充分 利用链路的 传输能力</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509232155284.png"
                      alt="image-20230509232155284" style="zoom:67%;" 
                >



<h5 id="rdt3-0-的-停等操作"><a href="#rdt3-0-的-停等操作" class="headerlink" title="rdt3.0 的 停等操作"></a>rdt3.0 的 停等操作</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509232420838.png"
                      alt="image-20230509232420838" style="zoom:80%;" 
                >



<h4 id="流水线：提高链路利用率"><a href="#流水线：提高链路利用率" class="headerlink" title="流水线：提高链路利用率"></a>流水线：提高链路利用率</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509232455264.png"
                      alt="image-20230509232455264" style="zoom:80%;" 
                >



<h5 id="流水线协议"><a href="#流水线协议" class="headerlink" title="流水线协议"></a>流水线协议</h5><p><font color='red'><strong>流水线</strong></font>：允许发送方在 <em><strong><u>未得到对方确认</u></strong></em> 的情况下一次性发送   <strong>多个</strong> 分组</p>
<ul>
<li><p>必须增加 序号的 范围：用多个 bit 表示 分组的 序号</p>
</li>
<li><p>在发送方 &#x2F; 接收方 要有缓冲区</p>
<ul>
<li><p>发送方缓冲 ： 未得到确认，可能需要重传的 “分组”</p>
</li>
<li><p>接收方缓冲： 上层用户取用数据的速率  !&#x3D; 接收到的 数据速率； 接收到的 数据可能乱序，排序交付（可靠）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509232838464.png"
                      alt="image-20230509232838464"
                ></p>
</li>
</ul>
</li>
<li><p>两种通用的 流水线协议：  <font color='red'><strong>回退N步（go-back-N）（GBN） 和 选择重传（selective repeat）（SR）</strong></font></p>
</li>
</ul>
<h5 id="流水线总结"><a href="#流水线总结" class="headerlink" title="流水线总结"></a>流水线总结</h5><h6 id="Go-back-N"><a href="#Go-back-N" class="headerlink" title="Go-back-N"></a><font color='red'>Go-back-N</font></h6><ul>
<li>发送端最多在流水线上有  N 个未确认的分组</li>
<li>接收端只是发送累计确认 <strong>cumulative ack</strong><ul>
<li>接收端如果发现  <strong>gap</strong>,不确认新到来的 分组</li>
</ul>
</li>
<li>发送端拥有对最老的 未确认分组的  定时器<ul>
<li>只需设置 一个  <strong>定时器</strong></li>
<li>当定时器到时时，<font color='red'>重传所有未确认的分组</font></li>
</ul>
</li>
</ul>
<br>

<p><strong>GBN: 发送方扩展的 FSM</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230510231427341.png"
                      alt="image-20230510231427341" style="zoom:50%;" 
                >

<br>

<p><strong>GBN：接收方扩展的 FSM</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230510231506846.png"
                      alt="image-20230510231506846" style="zoom:80%;" 
                >

<ul>
<li>只发送 ACK：对 顺序接收的 最高序号的 分组<ul>
<li>可能会产生 重复的 ack</li>
<li>只需记住 <code>expectedseqnum</code>; 接收窗口 &#x3D; 1<ul>
<li><strong>只一个变量就可表示接收窗口</strong></li>
</ul>
</li>
</ul>
</li>
<li>对 乱序的 分组<ul>
<li>丢弃（不缓存）  -&gt; <font color='red'><strong>在接收方不被缓存</strong></font></li>
<li>对顺序接收的最高序号的分组 进行确认 -&gt; 累计确认</li>
</ul>
</li>
</ul>
<br>

<p><strong>运行中的 GBN</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230510231916542.png"
                      alt="image-20230510231916542" style="zoom:67%;" 
                >



<h6 id="Selective-Repeat"><a href="#Selective-Repeat" class="headerlink" title="Selective Repeat"></a><font color='red'>Selective Repeat</font></h6><ul>
<li>接收方对每个正确接收的分组，分别发送 ACKn(非累计确认)<ul>
<li>接收窗口 &gt; 1<ul>
<li>接收窗口 &gt; 1<ul>
<li>可以缓存 乱序的分组</li>
</ul>
</li>
<li>最终将 分组按顺序交付给 上层</li>
</ul>
</li>
</ul>
</li>
<li>发送方 只对那些没有收到 ACK 的分组进行 重发 -   选择性 重发 <ul>
<li>发送方为每个未确认的 分组设定一个定时器</li>
</ul>
</li>
<li>发送窗口的 最大值（发送缓冲区）限制发送  未确认分组的个数</li>
</ul>
<br>

<ul>
<li>发送端最多在流水线中 有 N 个未确认的分组</li>
<li>接收方对每个到来的 分组单独确认  <font color='red'><strong>individual ack (非累计确认）</strong></font></li>
<li>发送方为每个 <strong>未确认的分组保持一个定时器</strong><ul>
<li>当超时定时器到时时，只是重发<strong>到时的未确认分组</strong></li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230510232618397.png"
                      alt="image-20230510232618397" style="zoom:80%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230510232641148.png"
                      alt="image-20230510232641148" style="zoom:67%;" 
                >





<h5 id="GBN和-SR-协议的异同"><a href="#GBN和-SR-协议的异同" class="headerlink" title="GBN和 SR 协议的异同"></a>GBN和 SR 协议的异同</h5><ul>
<li>相同之处<ul>
<li>发送窗口 &gt; 1</li>
<li>一次能够可发送多个未经确认的 分组</li>
</ul>
</li>
<li>不同之处<ul>
<li>GBN：接收窗口尺寸 &#x3D; 1 <ul>
<li>接收端：只能顺序接收</li>
<li>发送端：从表现来看，一旦一个分组没有发成功，如 ： 0,1,2,3,4；假如 1 未 成功，2，3,4 都发送出去了， <font color='red'>要 返回 1 再发送 ： GB1</font></li>
</ul>
</li>
<li>SR：接收窗口 尺寸 &gt; 1<ul>
<li>接收端：可以乱序接收</li>
<li>发送端：发送 0,1,2,3,4 ，一旦1 未成功，2，3,4 已发送，无需重发，<font color='red'>选择性发1</font></li>
</ul>
</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230510232700284.png"
                      alt="image-20230510232700284" style="zoom:67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230510232716090.png"
                      alt="image-20230510232716090" style="zoom:67%;" 
                >





<h4 id="通用：滑动窗口（slide-window）协议"><a href="#通用：滑动窗口（slide-window）协议" class="headerlink" title="通用：滑动窗口（slide window）协议"></a>通用：滑动窗口（slide window）协议</h4><ul>
<li>发送缓冲区<ul>
<li>形式：内存中的 一个区域，落入缓冲区的分组可以发送</li>
<li>功能：用于存放已发送，但是没有确认的 分组</li>
<li>必要性：需要重发时可用</li>
</ul>
</li>
<li>发送缓冲区的大小：一次最多可以发送多少个未经确认的 分组<ul>
<li>停等协议 &#x3D; 1</li>
<li>流水线协议 &gt; 1，合理的值，不能很大，链路利用率不能超过 100%</li>
</ul>
</li>
<li>发送缓冲区中的分组<ul>
<li><font color='red'>未发送的</font>：落入发送缓冲区的分组，可以连续发送出去</li>
<li><font color='cornflowerblue'>已经发送出去的，等待对方确认的分组；</font>发送缓冲区的分组只有得到确认才能删除</li>
</ul>
</li>
</ul>
<h5 id="发送窗口滑动过程-相对表示法"><a href="#发送窗口滑动过程-相对表示法" class="headerlink" title="发送窗口滑动过程-相对表示法"></a>发送窗口滑动过程-相对表示法</h5><ul>
<li>采用相对移动方式表示，分组不动</li>
<li>可缓冲范围移动，代表一段可以发送的权力</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\CSQ-PC\AppData\Roaming\Typora\typora-user-images\image-20230509233526395.png"
                      alt="image-20230509233526395" style="zoom: 80%;" 
                >



<h5 id="滑动窗口协议（slide-window-protocol）"><a href="#滑动窗口协议（slide-window-protocol）" class="headerlink" title="滑动窗口协议（slide window protocol）"></a>滑动窗口协议（slide window protocol）</h5><ul>
<li>发送窗口：发送缓冲区内容的一个范围<ul>
<li>那些 <strong>已发送</strong> 但是 <strong>未经确认</strong>的分组的序号构成的空间</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230510225051967.png"
                      alt="image-20230510225051967" style="zoom:50%;" 
                ></li>
</ul>
</li>
<li>发送窗口的最大值 &lt;&#x3D; 发送缓冲区的 值</li>
<li>一开始：没有发送任何一个分尊<ul>
<li>前沿 &#x3D; 后沿</li>
<li>之间为发送窗口的尺寸 &#x3D; 0</li>
</ul>
</li>
<li>每发送一个分组，前沿前移一个单位</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509233820236.png"
                      alt="image-20230509233820236" style="zoom:50%;" 
                >

<ul>
<li><p>接收窗口（receiving window）&#x3D; 接收缓冲区</p>
<ul>
<li>接收窗口用于控制哪些分组可以接收<ul>
<li>只有收到的分组序号落入接收窗口之内 才允许接收</li>
<li>若序号在接收窗口之外，则丢弃</li>
</ul>
</li>
<li>接收窗口尺寸 Wr &#x3D; 1,则只能顺序接收</li>
<li>接收窗口尺寸 Wr &gt; 1, 则 可以乱序接收<ul>
<li>​    但提交给上层的分组，要按序</li>
</ul>
</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230510225427566.png"
                      alt="image-20230510225427566" style="zoom:50%;" 
                ></li>
</ul>
</li>
<li><p>接收窗口的滑动和发送确认</p>
<ul>
<li>滑动<ul>
<li>低序号的分组到来，接收窗口移动</li>
<li>高序号分组乱序列，缓存但不交付（因为 要实现 rdt，不允许失序），不滑动</li>
</ul>
</li>
<li>发送确认<ul>
<li>接收窗口 尺寸 &#x3D; 1，发送连续收到的 最大分组确认（累计确认）</li>
<li>接收窗口尺寸  &gt; 1；收到分组，发送那个分组的确认（非累计确认）</li>
</ul>
</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230510225802316.png"
                      alt="image-20230510225802316" style="zoom:50%;" 
                ></li>
</ul>
</li>
</ul>
<h6 id="发送窗口的移动-前沿移动"><a href="#发送窗口的移动-前沿移动" class="headerlink" title="发送窗口的移动-&gt; 前沿移动"></a>发送窗口的移动-&gt; 前沿移动</h6><ul>
<li>发送窗口前沿移动的 极限：不能超过发送缓冲区</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509233906942.png"
                      alt="image-20230509233906942" style="zoom:50%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\CSQ-PC\AppData\Roaming\Typora\typora-user-images\image-20230509233932936.png"
                      alt="image-20230509233932936" style="zoom:50%;" 
                >



<h6 id="发送窗口的移动-后沿移动"><a href="#发送窗口的移动-后沿移动" class="headerlink" title="发送窗口的移动-&gt; 后沿移动"></a>发送窗口的移动-&gt; 后沿移动</h6><ul>
<li><p>发送窗口 后沿移动</p>
<ul>
<li><p>条件：收到老分组的确认</p>
</li>
<li><p>结果：发送缓冲区罩住新的分组，来了分组可以发送</p>
</li>
<li><p>移动的极限：不能超过前沿</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509234139373.png"
                      alt="image-20230509234139373" style="zoom:50%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230509234204937.png"
                      alt="image-20230509234204937" style="zoom:50%;" 
                ></li>
</ul>
</li>
</ul>
<h6 id="滑动窗口（slide-window）协议-接收窗口"><a href="#滑动窗口（slide-window）协议-接收窗口" class="headerlink" title="滑动窗口（slide window）协议-接收窗口"></a>滑动窗口（slide window）协议-接收窗口</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230510225844811.png"
                      alt="image-20230510225844811" style="zoom:67%;" 
                >



<h5 id="正常情况下的-两个-窗口互动"><a href="#正常情况下的-两个-窗口互动" class="headerlink" title="正常情况下的 两个 窗口互动"></a>正常情况下的 两个 窗口互动</h5><ul>
<li>发送窗口<ul>
<li>有新的分组落入发送缓冲区范围，发送 -&gt; 前沿滑动</li>
<li>来了 老的低序号分组的确认 -&gt; 后沿向前移动 -&gt; 新的分组可以落入发送缓冲区的范围</li>
</ul>
</li>
<li>接收窗口<ul>
<li>收到分组，落入到 接收窗口范围内</li>
<li>是低序号，发送确认给对方</li>
</ul>
</li>
<li>发送端上面来了分组 -&gt; 发送窗口滑动 -&gt; 接收窗口滑动 -&gt; 发确认</li>
</ul>
<h5 id="异常情况下-GBN的-窗口互动"><a href="#异常情况下-GBN的-窗口互动" class="headerlink" title="异常情况下  GBN的 窗口互动"></a>异常情况下  GBN的 窗口互动</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230510230207087.png"
                      alt="image-20230510230207087" style="zoom:67%;" 
                >



<h5 id="异常情况下-SR-的-窗口互动"><a href="#异常情况下-SR-的-窗口互动" class="headerlink" title="异常情况下 SR 的 窗口互动"></a>异常情况下 SR 的 窗口互动</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230510230231454.png"
                      alt="image-20230510230231454" style="zoom:67%;" 
                >

<h3 id="面向连接的传输：TCP"><a href="#面向连接的传输：TCP" class="headerlink" title="面向连接的传输：TCP"></a>面向连接的传输：TCP</h3><hr>
<p>TCP被称为是面向连接的（connection-oriented),这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互“握手”，即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。作为TCP连接建立的一部分，连接的双方都将初始化与TCP连接相关的许多TCP状态变量（其中的许多状态变量将在本节和3.7节中讨论）。</p>
<h4 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230510233930910.png"
                      alt="image-20230510233930910" style="zoom: 67%;" 
                >

<br>

<p>这种TCP“连接”不是一条像在电路交换网络中的端到端TDM或FDM电路。相反，<strong>该“连接”是一条逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中</strong>。</p>
<p>由于 TCP 协议只在 端系统中运行 ，而不在中间的 网络元素（路由器和链路层 ）中运行， <strong>所以 中间的网络元素   并不会   维持 TCP 连接</strong></p>
<blockquote>
<p>事实上，<strong>中间 路由器对 TCP 的连接视而不见，他们看到的 是 <u>数据报</u>，而不是连接</strong></p>
</blockquote>
<p>TCP 的 连接也总是 点对点的（point - to - point），即 <strong>在单个发送方和单个接收方之间的连接</strong></p>
<br>

<p>我们现在来看看TCP连接是怎样建立的。假设运行在某台主机上的一个进程想与另一台主机上的一个进程建立一条连接。<strong>发起连接的</strong>这个进程被称为<strong>客户进程</strong>，而另一个进程被称为<strong>服务器进程</strong>。</p>
<p>该客户应用进程首先要通知客户运输层，它想与服务器上的一个进程建立一条连接。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clientsocket.connect((serverName,serverPort))</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>serverName</code> 是服务器的名字，<code>serverPort</code>  标识了服务器上的进程。</p>
<p>客户上的TCP便开始与服务器上的TCP建立一条TCP连接。</p>
<ol>
<li>客户首先发送一个特殊的TCP报文段，</li>
<li>服务器用另一个特殊的TCP报文段来响应，</li>
<li>最后，客户再用第三个特殊报文段作为响应。</li>
</ol>
<p>前两个报文段不承载“有效载荷”，也就是不包含应用层数据；而第三个报文段可以承载有效载荷。由于在这两台主机之间发送了3个报文段，所以这种连接建立过程常被称为 <font color='red'><strong>三次握手（three-way handshake）</strong></font></p>
<br>

<p>一旦建立起一条TCP连接，两个应用进程之间就可以相互发送数据了。</p>
<p>下面考虑一下从客户进程向服务器进程发送数据的情况。客户进程通过套接字（该进程之门）传递数据流。数据一旦通过该门，它就由客户中运行的TCP控制了。如图3-28所示，TCP将这些数据引导到该连接的<strong>发送缓存（send buffer)<strong>里，发送缓存是发起三握手期间设置的缓存之一。接下来TCP就会不时从发送缓存里取出一块数据，并将数据传递到网络层。有趣的是，在TCP规范[RFC793]中却没提及TCP应何时实际发送缓存里的数据，只是描述为  “<strong>TCP应该在它方便的时候以报文段的形式发送数据</strong>”  。TCP可从缓存中取出并放入报文段中的数据数量受限于</strong>最大报文段长度（Maximum Segment Size,MSS)</strong>。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（即所谓的**最大传输单元（Maximum Transmission Unit,MTU))**来设置。设置该MSS要保证一个TCP报文段（当封装在一个IP数据报中）加上TCP&#x2F;IP首部长度（通常40字节）将适合单个链路层帧。以太网和PPP链路层协议都具有1500字节的MTU,<strong>因此MSS的典型值为1460字节</strong>。注意到MSS是指在报文段里应用层数据的最大长度，而不是指包括首部的TCP报文段的最大长度。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230510234825220.png"
                      alt="image-20230510234825220"
                ></p>
<blockquote>
<p>TCP连接的组成包括：一台主机上的缓存、变量和与进程连接的套接字，以及另一台主机上的另一组缓存、变量和与进程连接的套接字。在这两台主机之间的网络元素（路由器、交换机和中继器）中，没有为该连接分配任何缓存和变量。</p>
</blockquote>
<h4 id="TCP-报文段结构"><a href="#TCP-报文段结构" class="headerlink" title="TCP  报文段结构"></a>TCP  报文段结构</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230510234027268.png"
                      alt="image-20230510234027268" style="zoom: 50%;" 
                >

<p>TCP 报文段 由 <strong>首部字段</strong> 和 <strong>一个数据字段</strong>  组成，数据字段包含一块应用数据</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230510235335318.png"
                      alt="image-20230510235335318" style="zoom:67%;" 
                >

<h5 id="序号与确认号"><a href="#序号与确认号" class="headerlink" title="序号与确认号"></a>序号与确认号</h5><h6 id="序号"><a href="#序号" class="headerlink" title="序号"></a><font color='red'>序号</font></h6><ul>
<li>报文段的首字节的在字节流的编号</li>
</ul>
<h6 id="编号"><a href="#编号" class="headerlink" title="编号"></a><font color='red'>编号</font></h6><ul>
<li>期望从另一方收到的 下一个字节的 序号</li>
<li>累计确认</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230510235352556.png"
                      alt="image-20230510235352556" style="zoom:67%;" 
                >



<h5 id="RTT-的估计和超时"><a href="#RTT-的估计和超时" class="headerlink" title="RTT 的估计和超时"></a>RTT 的估计和超时</h5><p>TCP 如 rdt  一样，它采用 超时&#x2F; 重传 机制来处理报文段的丢失问题。<strong>但是  超时 间隔长度的设置 是一个明显的问题</strong>。显然，超时时间间隔 必须大于 该连接 的RTT，即从一个报文段发出到它被确认的时间，否则 会造成 不必要的 重传</p>
<p><font color='red'><strong>Q：</strong></font> 怎样设置 TCP 超时</p>
<ul>
<li>比 RTT 要长<ul>
<li>但 RTT 是变化的</li>
</ul>
</li>
<li>太短：太早超时<ul>
<li>不必要的重传</li>
</ul>
</li>
<li>太长：对报文段的丢失反应太慢</li>
</ul>
<h6 id="估计往返时间"><a href="#估计往返时间" class="headerlink" title="估计往返时间"></a>估计往返时间</h6><p>估计之间往返时间的。这是通过如下方法完成的。报文段的样本RTT(表示为SampleRTT)就是<strong>从某报文段被发出（即交给IP)到对该报文段的确认被收到之间的时间量</strong>。大多数TCP的实现仅在某个时刻做一次SampleRTT测量，而<strong>不是为每个</strong>发送的报文段测量一个SampleRTT。这就是说，在任意时刻，仅为一个已发送的但目前尚未被确认的报文段估计Samp-leRTT, 从而产生一个接近每个RTT的新SampleRTT值。另外，<strong>TCP决不为已被重传的报文段计算SampleRTT</strong>; 它仅为传输一次的报文段测量SampleRTT[Kan1987]</p>
<p>显然，由于<strong>路由器的拥塞和端系统负载的变化</strong>，这些报文段的 SampleRTT 值会随之波动。由于这种波动，任何给定的SampleRTT值也许<strong>都是非典型</strong>的。因此，为了估计一个身型的RTT,自然要采取某种对SampleRTT<strong>取平均</strong>的办法。TCP维持一个SampleRTT均值(称为EstimatedRTT)。一旦获得一个新SampleRTT时，TCP就会根据下列公式来更新EstimatedRTT :</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511124137134.png"
                      alt="image-20230511124137134" style="zoom:67%;" 
                >

<p><font color='red'><strong>Q</strong></font>：怎样估计 RTT</p>
<ul>
<li><font color='cornflowerblue'><strong>SampleRTT</strong></font>：测量 报文段发出到收到确认的 时间<ul>
<li>如果有重传，忽略此次测量</li>
</ul>
</li>
<li><strong>SampleRTT 会变化</strong>，因此估计的 RTT 应该比较平滑<ul>
<li>对 几个最近的测量值求平均，而不是仅用当前的 <strong>SampleRTT</strong></li>
</ul>
</li>
</ul>
<h6 id="设置和管理重传超时间隔"><a href="#设置和管理重传超时间隔" class="headerlink" title="设置和管理重传超时间隔"></a>设置和管理重传超时间隔</h6><p>很明显，超时间隔应该大于等于<code>EstimatedRTT</code> 否则，将造成不必要的重传。但是超时间隔也不应该比  <code>EstimatedRTT </code> 大太多，否则当报文段丢失时，TCP不能很快地重传该报文段，导致数据传输时延大。因此要求将超时间隔设为 <code>EstimatedRTT </code> 加上一定余量。当  <code>SampleRTT </code> 值波动较大时，这个余量应该大些；当波动较小时，这个余量应该小些。因此：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511124354617.png"
                      alt="image-20230511124354617"
                ></p>
<p>推荐的 <code>TimeoutInterval </code> 为 1  s, 同时当出现超时时， <code>TimeoutInterval </code>  值将加倍，以免即将被确认的后继报文段过早出现超时。然而，**只要收到报文段并更新 <code>EstimatedRTT</code>, 就使用上述公式再次计算  <code>TimeoutInterval </code> **</p>
<ul>
<li><p><font color='red'><strong>设置超时</strong></font></p>
<ul>
<li><p><code>EstimatedRTT</code> + 安全边界时间</p>
<ul>
<li><code>EstimatedRTT</code> 变化大（方差大） —&gt; 较大的安全边界时间</li>
</ul>
</li>
<li><p><code>SampleRTT </code> 会偏离 <code>EstimatedRTT</code> 多远</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511124858456.png"
                      alt="image-20230511124858456" style="zoom:50%;" 
                ></li>
</ul>
</li>
<li><p><font color='red'><strong>超时时间设置</strong></font></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511124925817.png"
                      alt="image-20230511124925817" style="zoom:80%;" 
                ></li>
</ul>
<h4 id="TCP-可靠数据传输"><a href="#TCP-可靠数据传输" class="headerlink" title="TCP: 可靠数据传输"></a>TCP: 可靠数据传输</h4><p>因特网的网络层服务（IP服务）是<strong>不可靠</strong>的。</p>
<blockquote>
<p>IP不保证数据报的交付，不保证数据报的按序交付，也不保证数据报中数据的完整性。</p>
<p>对于IP服务，数据报能句溢出路由器缓存而永远不能到达目的地，数据报也可能是乱序到达，而且数据报中的比特可能损坏（由0变为1或者相反）。</p>
</blockquote>
<p>由于<strong>运输层报文段是被IP数据报携带着在网络中传输的</strong>，所以运输层的报文段也会遇到这些问题。</p>
<p>TCP在IP不可靠的<strong>尽力而为服务</strong>之上创建了一种可靠数据传输服务（reliable datatransfer service)。</p>
<blockquote>
<p> <font color='red'><strong>尽力而为服务 :: best-effort service</strong></font>   可以理解为 <strong>完全没服务</strong></p>
</blockquote>
<p>TCP的可靠数据传输服务确保<strong>一个进程从其接收缓存中读出的数据流是无损坏、无间隙、非穴余和按序的数据流</strong>；即该字节流与连接的另一方端系统发送出的字节流是完全相同。TCP提供可靠数据传输的方法涉及在 rdt  中所学的许多原理。</p>
<ul>
<li><p>TCP 在 IP 不可靠服务 的基础上建立了 rdt </p>
<ul>
<li>管道化的 报文段<ul>
<li>GBN or SR</li>
</ul>
</li>
<li>累计确认 （像 GBN）</li>
<li>单个 重传定时器（像 GBN）</li>
<li>是否可以接收乱序的，没有规范</li>
</ul>
</li>
<li><p>通过一下 事件触发重传</p>
<ul>
<li>超时（只重发最早的未确认的段 ：SR）</li>
<li>重复的确认<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511130634705.png"
                      alt="image-20230511130634705"
                ></li>
</ul>
</li>
</ul>
</li>
<li><p>首先考虑简化的 TCP 发送方</p>
<ul>
<li>忽略重复的确认</li>
<li>忽略流量控制和拥塞控制</li>
</ul>
</li>
</ul>
<h5 id="TCP-发送方事件"><a href="#TCP-发送方事件" class="headerlink" title="TCP 发送方事件"></a>TCP 发送方事件</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511130943089.png"
                      alt="image-20230511130943089"
                ></p>
<h6 id="从应用层接收数据"><a href="#从应用层接收数据" class="headerlink" title="从应用层接收数据"></a><font color='red'>从应用层接收数据</font></h6><ul>
<li>用 <code>nextseq</code> 创建报文段</li>
<li>序号 <code>nextsq</code> 为报文段首字节的字节流编号</li>
<li>如果还没有运行，启动定时器<ul>
<li>定时器与最早确认的报文段关联</li>
<li>过期间隔 <code>TimeoutInterval</code></li>
</ul>
</li>
</ul>
<h6 id="超时"><a href="#超时" class="headerlink" title="超时"></a><font color='red'>超时</font></h6><ul>
<li>重传后沿最老的 报文段</li>
<li>重新启动定时器</li>
</ul>
<h6 id="收到确认"><a href="#收到确认" class="headerlink" title="收到确认"></a><font color='red'>收到确认</font></h6><ul>
<li>如果是对尚未确认的 报文段确认<ul>
<li>更新已被确认的报文序号</li>
<li>如果当前还有未被确认的报文段，重新启动定时器</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511131409081.png"
                      alt="image-20230511131409081"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511132717792.png"
                      alt="image-20230511132717792"
                ></p>
<h4 id="TCP-重传"><a href="#TCP-重传" class="headerlink" title="TCP : 重传"></a>TCP : 重传</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511132749009.png"
                      alt="image-20230511132749009"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511132807187.png"
                      alt="image-20230511132807187"
                ></p>
<p>超时触发重传存在的问题之一是超时周期可能相对较长。当一个报文段丢失时，这种长超时周期迫使发送方延迟重传丢失的分组，因而增加了端到端时延。幸运的是，发送方通常可在超时事件发生之前通过注意所谓冗余ACK来较好地检测到丢包情况。冗余ACK(duplicate ACK) 就是<strong>再次确认某个报文段的ACK</strong>,而发送方<strong>先前已经收到</strong>对该报文段的确认。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511133016647.png"
                      alt="image-20230511133016647"
                ></p>
<p>因为发送方经常一个接一个地发送大量的报文段，如果一个报文段丢失，就很可能引起许多一个接一个的  冗余 ACK。如果TCP发送方接收到对相同数据的3个冗余 ACK,它把这当作一种指示，说明<strong>跟在这个已被确认过3次的报文段之后的报文段已经丢失</strong>。一旦收到3个冗余 ACK,<strong>TCP就执行快速重传</strong>（fast retransmit)[RFC5681],<u>即在该报文段的定时器过期之前重传丢失的报文段</u>。对于采用快速重传的TCP,可用下列代码片段代替   下图 中的ACK收到事件：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511133200531.png"
                      alt="image-20230511133200531"
                ></p>
<ul>
<li>超时周期往往太长：<ul>
<li>在 重传丢失报文段之前的延时太长</li>
</ul>
</li>
<li>通过<strong>重复</strong>  的ack 来检测报文段的 丢失<ul>
<li>发送方通常连续发送大量的 报文段</li>
<li>如果报文段丢失，通常引起多个重复的 ack</li>
</ul>
</li>
<li>如果 发送方 收到同一数据的  3 个冗余 ack ，重传<strong>最小</strong> 序号的 段<ul>
<li><font color='red'><strong><u>快速重传</u></strong></font>：在定时器过时之前重发报文段</li>
<li>他假设跟在 被确认的数据后面的数据丢失了<ul>
<li>第一个 ACK 是正常的</li>
<li>收到第二个该段的 ack,表示接收方收到该段之后的 2 个，3个 乱序段，可能性非常大 -&gt; 段丢失了</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511133728302.png"
                      alt="image-20230511133728302"
                ></p>
<h5 id="快速重传算法"><a href="#快速重传算法" class="headerlink" title="快速重传算法"></a>快速重传算法</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511133751075.png"
                      alt="image-20230511133751075"
                ></p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>前面说过，一条 TCP 连接的每一侧主机都为该链接设置了 接收缓存。当该 TCP 连接收到正确、按序的字节后，他就将数据放入缓存中。<strong>相关联的 应用进程会从该缓存中读取数据，但  <u>不必是数据刚一到达就立即读取。</u></strong> 事实上，接收方可能正忙于其他任务，甚至要过很长时间才去读取该数据。如果，某应用程序读取数据时 **相对缓慢，**而发送方发送得太多、太快， <strong>发送得数据就会很容易地使该链接的接收缓存溢出</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511134553625.png"
                      alt="image-20230511134553625"
                ></p>
<ul>
<li><p>接收方在其向发送方的  TCP 段头部的 <code>rwnd</code> 字段  “通告”  其 <strong>空闲的  <code>buffer</code> 大小</strong></p>
<ul>
<li><p><code>RcvBUffer</code> 大小通过 <code>socket </code> 选项设置（典型默认大小为 4096 字节）</p>
</li>
<li><p>很多操作系统 自动调整 <code>RcvBuffer</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511134955233.png"
                      alt="image-20230511134955233"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511134924091.png"
                      alt="image-20230511134924091"
                ></p>
</li>
</ul>
</li>
<li><p>发送方限制未确认 （“in-flight”) 字节的个数 &lt;&#x3D; 接收方发送过来的 <code>rwnd</code> 值</p>
</li>
<li><p>保证 接收方不会被淹没</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511135107936.png"
                      alt="image-20230511135107936"
                ></p>
<p>这个方案还存在一个小小的问题，假设主机B的接收缓存已经存满，使得 <code>rwnd=0</code> 。在将  <code>rwnd=0</code>通告给主机A之后，还要假设主机B没有任何数据要发给主机A。此时，考虑会发生什么情况。因为主机B上的应用进程将缓存清空，TCP并不向主机A发送带有<code>rwnd</code>新值的新报文段；事实上，TCP仅当在它有数据或有确认要发时才会发送报文段给主机A。这样，主机A不可能知道主机B的接收缓存已经有新的空间了，即主机A被阻塞而不能再发送数据！为了解决这个问题，TCP规流中要求：<strong>当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存将开始清空，并且确认报文里将包含一个非0的rwnd值。</strong></p>
<p>描述了 TCP 的流量控制服务之后，在此简要的 提一下 <strong>UDP 并不提供 流量控制，报文段由于缓存溢出可能在接收方丢失</strong>。 进程每次从 缓存中读取一个完整的报文段，如果 进程从缓存中读取报文段的速度还不够快，那么 <strong>缓存将会溢出，并且将丢失报文段</strong></p>
<h4 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h4><h5 id="TCP：建立-连接"><a href="#TCP：建立-连接" class="headerlink" title="TCP：建立 连接"></a>TCP：建立 连接</h5><p><font color='red'><strong>Q:</strong></font> 在网络中，2 次握手建立连接总是可行吗？</p>
<ul>
<li>变化的延迟（连接请求的段没有丢，但可能超时）</li>
<li>由于丢失造成的重传</li>
<li>报文乱序</li>
<li>相互看不到对方</li>
</ul>
<br>

<p><strong>两次握手的失败场景</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511225115908.png"
                      alt="image-20230511225115908" style="zoom:50%;" 
                >

<br>

<p><strong>TCP 三次握手</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511225353459.png"
                      alt="image-20230511225353459" style="zoom:67%;" 
                >

<p>解决方案：变化的初始序号  +  双方确认对方的 序号（三次握手）</p>
<br>

<p><strong>三次握手解决：半连接和接收老数据问题</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511225523762.png"
                      alt="image-20230511225523762" style="zoom:50%;" 
                >

<br>

<p><strong>TCP 三次握手 ： FSM</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511225555676.png"
                      alt="image-20230511225555676" style="zoom:50%;" 
                >

<br>

<p>现在我们去更加仔细的观察如何建立 和 拆除一条 TCP 连接。</p>
<ul>
<li>第一步：客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文段中不包含应用层数据。但是在报文段的首部（参见图3-29)中的一个标志位(即SYN比特）被置为1。因此，这个特殊报文段被称为SYN报文段。另外，客户会随机地选择一个初始序号（client_isn),并将此编号放置于该起始的TCP SYN报文段的序号字段中。该报文段会被封装在一个IP数据报中，并发送给服务器。为了避免某些安全性攻击，在适当地随机化选择client_isn方面有着不少有趣的研究[CERT 2001-09]。</li>
<li>第二步：一旦包含TCP  SYN报文段的IP数据报到达服务器主机（假定它的确到达了！),服务器会从该数据报中提取出TCP  SYN报文段，为该TCP连接分配TCP组存和变量，并向该客户TCP发送允许连接的报文段。（我们将在第8章看到，在完成三次握手的第三步之前分配这些缓存和变量，使得TCP易于受到称为SYN洪泛的拒绝服务攻击。）这个允许连接的报文段也不包含应用层数据。但是，在报文段的首部却包含3个重要的信息。首先，SYN比特被置为1。其次，该TCP报文段首部的确认号字段被置为client_isn+1。最后，服务器选择自己的初始序号(server_isn),并将其放置到TCP报文段首部的序号字段中。这个允许连接的报段实际上表明了：“我收到了你发起建立连接的SYN分组，该分组带有初始序号client_isn。我同意建立该连接。我自己的初始序号是server_isn。”该允许连接的报文段被称为SYN ACK报文段（SYN ACK segment)。</li>
<li>第三步：在收到SYN ACK报文段后，客户也要给该连接分配缓存和变量。客户机则向服务器发送另外一个报文段；这最后一个报文段对服务器的允许连接的报文段进行了确认（该客户通过将值server_isn+1放置到TCP报文段首部的确认字段中来完成此项工作）。因为连接已经建立了，所以该SYN比特被置为0。该三次握手的第三个阶段可以在报文段负载中携带客户到服务器的数据。</li>
</ul>
<p>一旦完成这三个步骤，客户和服务器主机就可以互相发送包括数据的 报文段 了。注意： <strong>为了创建这个连接，在两台主机之间发送了 3 个分组</strong>，由于这个原因，这种 连接创建过程 通常被称为 <strong>三次握手</strong></p>
<p>在正式交换数据之前，发送方和接收方握手建立通信关系：</p>
<ul>
<li><p>同意建立连接（每一方都知道 对方愿意建立连接）</p>
</li>
<li><p>同意连接参数</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511224848443.png"
                      alt="image-20230511224848443" style="zoom:67%;" 
                ></li>
</ul>
<br>

<h5 id="TCP：关闭连接"><a href="#TCP：关闭连接" class="headerlink" title="TCP：关闭连接"></a>TCP：关闭连接</h5><p>任何一个都能终止该连接。当连接结束后主机中的“资源”（即缓存和变量）将被释放。</p>
<p>举一个例子，假设某客户打算关闭连接，如图3-40所示。客户应用进程发出一个关闭连接命令。这会引起<strong>客户TCP向服务器进程发送一个特殊的TCP报文段</strong>。这个特殊的报文段让其首部中的一个标志位即FIN比特（参见图3-29)被设置为1。当服务器接收到该报文段后，就<strong>向发送方回送一个确认报文段</strong>。然后，<strong>服务器发送它自己的终止报文段</strong>，其FIN比特被置为1。最后，<strong>该客户对这个服务器的终止报文段进行确认</strong>。此时，在两台主机上用于该连接的所有资源都被释放了。</p>
<blockquote>
<p>可以注意到 上面客户端与服务器端一共有 <strong>4 次</strong> 动作，TCP 的连接关闭 也被称为 <strong>四次挥手</strong></p>
</blockquote>
<ul>
<li>客户端，服务器分别关闭她自己这一侧的连接<ul>
<li>发送 FIN bit &#x3D; 1的 TCP 段</li>
</ul>
</li>
<li>一旦接收到 FIN，用 ACK回应<ul>
<li>接到 FIN 段，ACK 可以和 它自己发出的 FIN 段 一起发送</li>
</ul>
</li>
<li>可以处理同时的 FIN 交换</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511230140492.png"
                      alt="image-20230511230140492" style="zoom:67%;" 
                >



<h3 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h3><hr>
<p>前面已经分析了面临分组丢失时用于提供可靠数据传输服务的基本原理及特定的TCP机制。在实践中，这种丢包一般是当网络变得拥塞时由于路由器缓存溢出引起的。分组重传因此作为网络拥塞的征兆（某个特定的运输层报文段丢失）来对待，但是却无法处理导致网络拥塞的原因，因为有太多的源想以过高的速率发送数据。为了处理网络拥塞原因，需要一些机制以在面临网络拥塞时遏制发送方。 以非正式的定义来说，<strong>太多的数据需要网络传输，超过了 网络 的处理能力</strong>  ，故造成 <font color='red'><strong>拥塞</strong></font></p>
<p><font color='red'><strong>拥塞</strong></font></p>
<ul>
<li>非正式的 定义： “太多的数据需要网络传输，超过了网络的处理能力”</li>
<li>与流量控制不同</li>
<li>拥塞的表现<ul>
<li>分组丢失（路由器 缓冲区溢出）</li>
<li>分组经历比较长的延迟（在路由器的 队列中排序）</li>
</ul>
</li>
<li>网络的前 10  位问题</li>
</ul>
<h4 id="拥塞的原因-代价"><a href="#拥塞的原因-代价" class="headerlink" title="拥塞的原因&#x2F;代价"></a>拥塞的原因&#x2F;代价</h4><h5 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511230941657.png"
                      alt="image-20230511230941657" style="zoom:50%;" 
                >



<h5 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511231330476.png"
                      alt="image-20230511231330476"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511231422215.png"
                      alt="image-20230511231422215"
                ></p>
<h5 id="场景3"><a href="#场景3" class="headerlink" title="场景3"></a>场景3</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511231510689.png"
                      alt="image-20230511231510689"
                ></p>
<h4 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h4><p>在最为宽泛的级别上，我们可根据网络层是否为 运输层拥塞控制提供了 <strong>显式帮助</strong>，来区分拥塞控制的方法。 两种常见的拥塞控制方法</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511231800551.png"
                      alt="image-20230511231800551" style="zoom:67%;" 
                >

<ul>
<li>端到端拥塞控制。<ul>
<li>在端到端拥塞控制方法中，网络层没有为运输层拥塞控制提供显式支持。即使网络中存在拥塞，端系统也必须通过对网络行为的观察（如分组丢失与时延）来推断之。TCP采用端到端的方法角决拥塞控制，因为IP层不会向端系统提供有关网络拥塞的反馈信息。TCP报文段的丢失（通过超时或3次冗余确认而得知）被认为是网络拥塞的一个迹象，TCP会相应地减小其窗口长度。我们还将看到关于TCP拥塞控制的一些最新建议，即使用增加的往返时延值作为网络拥塞程度增加的指示。</li>
</ul>
</li>
<li>网络辅助的拥塞控制。<ul>
<li>在网络辅助的拥塞控制中，路由器向发送方提供关于网络中拥塞状态的显式反馈信息。这种反馈可以简单地用一个比特来指示链路中的拥塞情况。该方法在早期的IBM SNA[Schwartz 1982]、DEC DECnet [Jain 1989Ramakrishnan 1990]和ATM[Black 1995]等体系结构中被采用。更复杂的网络反馈也是可能的。例如，在ATM可用比特率（Available Bite Rate,ABR)拥塞控制中，路由器显式地通知发送方它（路由器）能在输出链路上支持的最大主机发送速率。如上面所提到的，默认因特网版本的IP和TCP采用端到端拥塞控制方法。然而，最近IP和TCP也能够选择性地实现网络辅助拥塞控制。</li>
</ul>
</li>
</ul>
<h5 id="案例学习：ATM-ABR-拥塞控制"><a href="#案例学习：ATM-ABR-拥塞控制" class="headerlink" title="案例学习：ATM ABR 拥塞控制"></a>案例学习：ATM ABR 拥塞控制</h5><p><font color='red'><strong>ABR：available bit rate</strong></font></p>
<ul>
<li>弹性服务</li>
<li>如果发送端的路径 “轻载”<ul>
<li>发送使用可用带宽</li>
</ul>
</li>
<li>如果发送方的路径拥塞了<ul>
<li>发送方限制其发送的速度到最小保障速率上</li>
</ul>
</li>
</ul>
<br>

<p><font color='red'><strong>RM（资源单元（信元</strong></font></p>
<ul>
<li>由发送端发送，在数据信元中间隔插入</li>
<li>RM 信元中的 比特 被交换机设置（“网络辅助”）<ul>
<li><font color='cornflowerblue'><strong>NI bit</strong></font> : no increase rate (轻微拥塞) 速率不要增加 了</li>
<li><font color='cornflowerblue'><strong>CI bit</strong></font>: congestion indication 拥塞指示</li>
</ul>
</li>
<li>发送端发送的 RM 信元 被接收端返回，接收端不做任何改变</li>
</ul>
<br>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230511232624418.png"
                      alt="image-20230511232624418" style="zoom:67%;" 
                >

<ul>
<li>在 RM 信元 中的 两个字节（explicit rate）字段<ul>
<li>拥塞的交换机可能会降低信元中的 ER 值</li>
<li>发送端发送速度因此是最低的可支持速率</li>
</ul>
</li>
<li>数据信元中的 EFCI bit： 被拥塞的交换机设置为 1<ul>
<li>如果在 管理信元RM 前面的 数据信元 EFCI 被 设置为了 1，接收端返回的 RM 信元 中设置 CI bit</li>
</ul>
</li>
</ul>
<h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP  拥塞控制"></a>TCP  拥塞控制</h3><hr>
<p>在本节中，我们再次来学习TCP。TCP为运行在不同主机上的两个进程之间提供了可靠传输服务。TCP的另一个关键部分就是其拥塞控制机制。如在前一节所指出，TCP必须使用端到端拥塞控制而不是使网络辅助的拥塞控制，因为IP层不向端系统提供显式的网络拥塞反馈。TCP所采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率。如果一个TCP发送方感知从它到目的地之间的路径上没什么拥塞，则TCP发送方增加其发送速率；如果发送方感知沿着该路径有拥塞，则发送方就会降低其发送速率。但是这种方法提出了三个问题。第一，一个TCP发送方如何限制它向其连接发送流量的速率呢？第二，一个TCP发送方如何感知从它到目的地之间的路径上存在拥塞呢？第三，当发送方感知到端到端的拥塞时，采用何种算法来改变其发送速率呢？</p>
<p><font color='red'><strong>端到端的拥塞控制机制</strong></font></p>
<ul>
<li>路由器不向主机有关拥塞 反馈信息<ul>
<li>路由器的负担较轻</li>
<li>复合网络核心简单的 TCP &#x2F; IP 架构原则</li>
</ul>
</li>
<li>端系统根据自身得到的信息，判断 是否发生拥塞，从而采取动作</li>
</ul>
<br>

<p><font color='red'><strong>拥塞控制的 几个问题</strong></font></p>
<ul>
<li>如何检测拥塞<ul>
<li>轻微拥塞</li>
<li>拥塞</li>
</ul>
</li>
<li>控制策略<ul>
<li>在拥塞发送时如何 动作，降低速率<ul>
<li>轻微拥塞，如何降低</li>
<li>拥塞时，如何 降低</li>
</ul>
</li>
<li>在拥塞 缓解时如何动作，增加速率</li>
</ul>
</li>
</ul>
<h4 id="TCP拥塞控制：拥塞感知"><a href="#TCP拥塞控制：拥塞感知" class="headerlink" title="TCP拥塞控制：拥塞感知"></a>TCP拥塞控制：拥塞感知</h4><p><font color='red'><strong>发送端怎么探测到拥塞</strong></font></p>
<ul>
<li>某个端超时了 （丢失事件）：<strong>拥塞</strong><ul>
<li>超时时间到，某个时间的确认没有来</li>
<li>reason1: 网络拥塞（某个路由器缓冲区没有空间了，被丢弃）<strong>概率大</strong></li>
<li>reason2：<strong>出错被丢弃了</strong>（各级错误，没有通过校验，被丢弃）<strong>概率小</strong></li>
<li>一旦超时。就认为拥塞了，有一定误判，但是 总体控制方向是对的</li>
</ul>
</li>
<li>有关某个段的 3  次 冗余 ack，<strong>轻微拥塞</strong><ul>
<li>段的第一个 ack，正常，确认绿段，期待红段</li>
<li>段的 第二个 重复 ack ，意味着红段的后一段收到了，蓝段乱序到达</li>
<li>段的 第 2,3,4 个 ack 重复，意味着红段的 后 第2,3,4 个段都到了，橙段乱序到达，同时红段丢失的可能性很大（后面三个段都到了，红段没有到）</li>
<li>网络这时还能够进行一定程度的传输，拥塞但情况要比第一种情况好</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230512154853892.png"
                      alt="image-20230512154853892"
                ></p>
<h4 id="TCP拥塞控制：速率控制方法"><a href="#TCP拥塞控制：速率控制方法" class="headerlink" title="TCP拥塞控制：速率控制方法"></a>TCP拥塞控制：速率控制方法</h4><p><font color='red'><strong>如何控制发送端发送的速率</strong></font></p>
<ul>
<li><p>维持一个拥塞窗口的值 ：<code>CogWin</code></p>
</li>
<li><p>发送端限制 <strong>已发送但未确认的</strong>  数据量（的上限）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230512155037318.png"
                      alt="image-20230512155037318"
                ></p>
</li>
<li><p>从而粗略的限制发送方的 往网络中注入的速率</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230512155113252.png"
                      alt="image-20230512155113252"
                ></p>
</li>
<li><p><code>CongWin</code> 是动态的，是感知到的网络拥塞程度的函数</p>
<ul>
<li>超时或者 三个 冗余 ack ,<code>CongWin</code> 下降<ul>
<li><font color='red'>超时</font>：<code>CongWin</code> 降为 1MSS，进入 SS 阶段然后再倍增到 <code>CongWin/2</code> (每个RTT)， 从而进入 CA 阶段</li>
<li><font color='red'><strong>三个 冗余 ack</strong></font>： <code>CongWin</code> 降为 <code>CongWin/2</code>, CA 阶段</li>
</ul>
</li>
<li>否则（正常收到 ACK， 没有发送以上情况）： CongWin 跃跃欲试 增加<ul>
<li>SS 阶段：加倍增加（peer RTT）</li>
<li>CA阶段：线性增加（peer RTT）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="TCP-拥塞控制和流量控制的联合动作"><a href="#TCP-拥塞控制和流量控制的联合动作" class="headerlink" title="TCP 拥塞控制和流量控制的联合动作"></a>TCP 拥塞控制和流量控制的联合动作</h4><p><font color='red'><strong>联合控制的方法</strong></font></p>
<ul>
<li>发送端控制 发送但是未确认的量同时也不能超过接收窗口，满足流量控制要求<ul>
<li><code>SendWin = min&#123;CongWin,RecvWin&#125;</code></li>
<li>同时满足 拥塞控制和流量控制要求</li>
</ul>
</li>
</ul>
<h4 id="TCP拥塞控制：策略概述"><a href="#TCP拥塞控制：策略概述" class="headerlink" title="TCP拥塞控制：策略概述"></a>TCP拥塞控制：策略概述</h4><p><font color='red'><strong>拥塞控制策略</strong></font></p>
<ul>
<li>慢启动</li>
<li>AIMD：线性增、乘性减少</li>
<li>超时事件后的保守策略</li>
</ul>
<h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230512160058788.png"
                      alt="image-20230512160058788"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230512160233876.png"
                      alt="image-20230512160233876"
                ></p>
<blockquote>
<p>慢启动  并不慢，或者说，慢启动 很快。准确的说，<font color='red'><strong>TCP 发送速率起始慢，但后面以指数增长</strong></font></p>
</blockquote>
<h5 id="AIMD"><a href="#AIMD" class="headerlink" title="AIMD"></a>AIMD</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230512160535010.png"
                      alt="image-20230512160535010"
                ></p>
<ul>
<li>当收到 <strong>三个冗余 ack</strong><ul>
<li>CongWin 减半</li>
<li>窗口（缓冲区大小）之后线性增长</li>
</ul>
</li>
<li>当 <strong>超时</strong> 事件发生时<ul>
<li>CongWin 被设置为1 MSS，进入 SS 阶段</li>
<li>之后窗口指数增长</li>
<li>增长到一个阈值（上次发生拥塞的窗口的一半）时，再线性增加</li>
</ul>
</li>
</ul>
<p><strong>改进</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230512160824338.png"
                      alt="image-20230512160824338" style="zoom:80%;" 
                >



<h4 id="总结：TCP-拥塞控制"><a href="#总结：TCP-拥塞控制" class="headerlink" title="总结：TCP 拥塞控制"></a>总结：TCP 拥塞控制</h4><ul>
<li>当CongWin &lt; Threshold,发送端处于慢启动阶段（slow-start),窗口指数性增长. </li>
<li>当CongWin &gt; Threshold,发送端处于拥塞避免阶段(congestion-avoidance),窗口线性增长.</li>
<li>当收到三个重复的ACKs(triple duplicate ACK)<ul>
<li>Threshold设置成CongWin&#x2F;2</li>
<li>CongWin&#x3D;Threshold+3.</li>
</ul>
</li>
<li>当超时事件发生时timeout,Threshold&#x3D;CongWin&#x2F;2  CongWin&#x3D;1 MSS,进入SS阶段</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230512161115322.png"
                      alt="image-20230512161115322"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230512161132176.png"
                      alt="image-20230512161132176"
                ></p>
<h4 id="TCP-吞吐量"><a href="#TCP-吞吐量" class="headerlink" title="TCP 吞吐量"></a>TCP 吞吐量</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230512161459241.png"
                      alt="image-20230512161459241" style="zoom:80%;" 
                >



<h4 id="TCP-公平性"><a href="#TCP-公平性" class="headerlink" title="TCP 公平性"></a>TCP 公平性</h4><p><font color='red'><strong>公平性目标</strong></font>：如果 K 个 TCP 会话分享一个链路带宽为 R 的瓶颈，每一个会话的有效带宽为 R&#x2F;K</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230512161645297.png"
                      alt="image-20230512161645297"
                ></p>
<h5 id="为什么-TCP-是公平的"><a href="#为什么-TCP-是公平的" class="headerlink" title="为什么 TCP 是公平的"></a>为什么 TCP 是公平的</h5><p>两个竞争的 TCP 会话</p>
<ul>
<li>加性增加，斜率为1，吞吐量增加</li>
<li>乘性减，吞吐量比例减少</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230512161819204.png"
                      alt="image-20230512161819204"
                ></p>
<h5 id="公平性和-UDP"><a href="#公平性和-UDP" class="headerlink" title="公平性和 UDP"></a>公平性和 UDP</h5><ul>
<li>多媒体应用通常不使用 TCP<ul>
<li>应用发送的数据速率希望不收拥塞控制的节制</li>
</ul>
</li>
<li>使用 UDP<ul>
<li>音视频 泵出数据的速率是恒定的，忽略数据的丢失</li>
</ul>
</li>
<li>研究领域 ：TCP 友好性</li>
</ul>
<h5 id="公平性和并行-TCP-连接"><a href="#公平性和并行-TCP-连接" class="headerlink" title="公平性和并行 TCP 连接"></a>公平性和并行 TCP 连接</h5><ul>
<li>两个主机间可以打开多个并行的 TCP 连接</li>
<li>WEB浏览器</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230512162605627.png"
                      alt="image-20230512162605627" style="zoom:80%;" 
                ></li>
</ul>
<h4 id="Explicit-Congestion-Notification（ECN）"><a href="#Explicit-Congestion-Notification（ECN）" class="headerlink" title="Explicit Congestion Notification（ECN）"></a>Explicit Congestion Notification（ECN）</h4><p><font color='red'><strong>网络辅助拥塞控制</strong></font></p>
<ul>
<li>TOS 字段中两个 bit 被网络路由器标记，用于指示是否发生拥塞</li>
<li>拥塞指示被传送到接收主机</li>
<li>在接收方 - 到 发送方的 ack中，接收方（在IP 数据报中看到了拥塞指示）设置 ECN bit，指示发送方发生了拥塞</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230512162855366.png"
                      alt="image-20230512162855366"
                ></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>传输层提供的服务<ul>
<li>应用进程间的逻辑通信<ul>
<li>Vs 网络层提供的是主机到主机间的通信服务</li>
</ul>
</li>
<li>互联网上传输层协议：UDP TCP<ul>
<li>特性</li>
</ul>
</li>
</ul>
</li>
<li>多路复用和解复用<ul>
<li>端口：传输层的 SAP</li>
<li>无连接的多路复用和解复用</li>
<li>面向连接的多路复用和解复用</li>
</ul>
</li>
<li>实例1：无连接传输层协议  UDP<ul>
<li>多路复用和解复用</li>
<li>UDP 报文格式</li>
<li>检错机制：校验和</li>
</ul>
</li>
<li>可靠数据传输原理<ul>
<li>问题描述</li>
<li>停止等待协议<ul>
<li>rdt 1.0  2.0 2.1 2.2 3.0</li>
</ul>
</li>
<li>流水线协议<ul>
<li>GBN</li>
<li>SR</li>
</ul>
</li>
</ul>
</li>
<li>实例2：面向连接的传输层协议 - TCP<ul>
<li>概述：TCP 特性</li>
<li>报文段格式<ul>
<li>序号，超时机制及时间</li>
</ul>
</li>
<li>TCP 可靠传输机制</li>
<li>œœ†··重传、快速重传</li>
<li>流量控制</li>
<li>连接管理<ul>
<li>三次握手</li>
<li>对称连接释放</li>
</ul>
</li>
</ul>
</li>
<li>拥塞控制原理<ul>
<li>网络辅助的 拥塞控制</li>
<li>端到端的拥塞控制</li>
</ul>
</li>
<li>TCP 的 拥塞控制<ul>
<li>AIMD</li>
<li>慢启动</li>
<li>超时之后的保守策略</li>
</ul>
</li>
</ul>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514191917544.png"
                      alt="image-20230514191917544" style="zoom:67%;" 
                >

<h4 id="网络层服务"><a href="#网络层服务" class="headerlink" title="网络层服务"></a>网络层服务</h4><ul>
<li>在发送主机和接收主机对之间 传送  段（<code>segment</code>） </li>
<li>在发送端将端封装到 数据报中</li>
<li>在接收端，将端上交给 传输层实体</li>
<li>网络层 协议存在于 <font color='red'><strong>每一个</strong></font> 主机 和 路由器</li>
<li>路由器检查每一个经过他的<code>IP</code> 数据报的头部</li>
</ul>
<h4 id="网络层的-关键功能"><a href="#网络层的-关键功能" class="headerlink" title="网络层的 关键功能"></a>网络层的 关键功能</h4><p><font color='red'><strong>网络层功能</strong></font></p>
<ul>
<li><font color='cornflowerblue'><strong>转发</strong></font>：将分组从路由器的输入接口转发到合适输出接口</li>
<li><font color='cornflowerblue'><strong>路由</strong></font>：使用路由算法来决定分组从发送主机到目标接收主机的路径</li>
</ul>
<br>

<p><font color='red'><strong>旅行的类比</strong></font></p>
<ul>
<li>转发：通过单个路口的过程</li>
<li>路由：从 源到目的地路由路径的规划过程</li>
</ul>
<h4 id="网络层：数据平面、控制平面"><a href="#网络层：数据平面、控制平面" class="headerlink" title="网络层：数据平面、控制平面"></a>网络层：数据平面、控制平面</h4><p><font color='red'><strong>数据平面</strong></font></p>
<ul>
<li>本地，每个路由器的功能</li>
<li>决定从路由器的输入端口到达的分组如何转发到输出端口</li>
<li>转发功能<ul>
<li>传统方式：基于目标地址 + 转发表</li>
<li>SDN方式：基于多个字段 + 流表</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>控制平面</strong></font></p>
<ul>
<li>网络范围内的逻辑</li>
<li>决定数据报如何在路由器之间路由，决定数据报从源到目标主机之间的端到端路径</li>
<li>2 个 控制平面方法<ul>
<li>传统的路由算法：在路由器中被实现</li>
<li>software-defined networking (<strong>SDN</strong>)  :在远程的服务器中实现</li>
</ul>
</li>
</ul>
<h5 id="传统方式：每-路由器（peer-router-控制平面"><a href="#传统方式：每-路由器（peer-router-控制平面" class="headerlink" title="传统方式：每-路由器（peer-router ) 控制平面"></a>传统方式：每-路由器（peer-router ) 控制平面</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514193122143.png"
                      alt="image-20230514193122143" style="zoom: 50%;" 
                >

<p>在 <font color='cornflowerblue'>每一个路由器</font>中的 单独路由器算法元件，在控制平面进行交互</p>
<h6 id="传统方式：路由和转发的相互作用"><a href="#传统方式：路由和转发的相互作用" class="headerlink" title="传统方式：路由和转发的相互作用"></a>传统方式：路由和转发的相互作用</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514193212123.png"
                      alt="image-20230514193212123" style="zoom:67%;" 
                >



<h5 id="SDN-方式：逻辑集中的控制平面"><a href="#SDN-方式：逻辑集中的控制平面" class="headerlink" title="SDN 方式：逻辑集中的控制平面"></a>SDN 方式：逻辑集中的控制平面</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514193325831.png"
                      alt="image-20230514193325831" style="zoom:50%;" 
                >

<p>一个不同的（通常是 远程的）控制器和本地代理（CAs） 交互</p>
<h4 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h4><p><font color='red'><strong>Q：</strong></font>从发送方主机到接收方主机传输数据报的 “通道”，网络提供怎么样的 <font color='cornflowerblue'>服务模型</font></p>
<h5 id="对于单个数据报的服务"><a href="#对于单个数据报的服务" class="headerlink" title="对于单个数据报的服务"></a>对于单个数据报的服务</h5><ul>
<li>可靠传送</li>
<li>延迟保证</li>
</ul>
<h5 id="对于数据报流的服务"><a href="#对于数据报流的服务" class="headerlink" title="对于数据报流的服务"></a>对于数据报流的服务</h5><ul>
<li>保序数据报传送</li>
<li>保证流的最小带宽</li>
<li>分组之间的延迟差</li>
</ul>
<h4 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514193631061.png"
                      alt="image-20230514193631061" style="zoom:67%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514193725466.png"
                      alt="image-20230514193725466"
                ></p>
<h3 id="网络层：数据平面"><a href="#网络层：数据平面" class="headerlink" title="网络层：数据平面"></a>网络层：数据平面</h3><hr>
<p>在本章和下一章中，我们将学习网络层是怎样实现主机到主机的通信服务的。我们将看到 与 运输层和 应用层不同，<strong>在网络上中的每一台主机和路由器中都有一个网络层部分</strong>。正因如此，网络层协议是协议栈中最有趣的部分（也是最具有挑战性的部分）</p>
<p>我们将看到 <strong>网络层能够被分解成两个相互作用的部分，即 <u>数据平面</u> 和 <u>控制平面</u></strong>。在数据平面，即网络层中每台路由器的功能，该数据平面功能决定到达路由器输入链路之一的数据报（即网络层的分组）如何转发到该路由器的输出链路之一。我们将涉及传统的<code>IP</code>转发（其中转发基于数据报的目的地址）和通用的转发（其中可以使用数据报首部中的几个不同域的值执行转发和其他功能）。我们将详细地学习<code>IPv4</code>和<code>IPv6</code>协议及其寻址</p>
<h4 id="路由工作原理"><a href="#路由工作原理" class="headerlink" title="路由工作原理"></a>路由工作原理</h4><p>下图是一个常见的通常路由器的体系架构</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514194224741.png"
                      alt="image-20230514194224741" style="zoom: 50%;" 
                >



<h5 id="路由结构概况"><a href="#路由结构概况" class="headerlink" title="路由结构概况"></a>路由结构概况</h5><p>高层面（非常简化的） 通用路由器体系架构</p>
<ul>
<li>路由：运行  **路由 ** 选择算法 &#x2F; 协议  -  生成路由表</li>
<li>转发：从输入到输出链路交换数据报  - 根据路由表进行 分组的 <strong>转发</strong></li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514194604038.png"
                      alt="image-20230514194604038" style="zoom:67%;" 
                >

 

<h4 id="输入端口处理和基于目的地转发"><a href="#输入端口处理和基于目的地转发" class="headerlink" title="输入端口处理和基于目的地转发"></a>输入端口处理和基于目的地转发</h4><h5 id="输入端口功能"><a href="#输入端口功能" class="headerlink" title="输入端口功能"></a>输入端口功能</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514194848809.png"
                      alt="image-20230514194848809" style="zoom:50%;" 
                >

<p>这里的端口是  <strong>路由器的物理的输入输出 接口</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514195300386.png"
                      alt="image-20230514195300386" style="zoom:50%;" 
                >

<p>图4-5中显示了一个更详细的输入处理的视图。输入端口的线路端接功能与链路层处理实现了用于各个输入链路的物理层和链路层。在输入端口中执行的查找对于路由器运行是至关重要的。正是在这个地方，路由器使用转发表来查找输出端口，使得到达的分组能经过交换结构转发到该输出端口。转发表是由路由选择处理器计算和更新的（使用路由选择协议与其他网络路由器中的路由选择处理器进行交互）,或者转发表接收来自远程SDN控制器的内容。转发表从路由选择处理器经过独立总线（例如一个PCI总线）复制到线路卡</p>
<p>在图4-4中该总线由从路由选择处理器到输入线路卡的虚线所指示。使用在每个输入端口的影子副本，转发决策能在每个输入端口<strong>本地做出</strong>，无须基于每个分组调用集中式路由选择处理器，因此避免了集中式处理的瓶颈。</p>
<h5 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h5><p><font color='red'><strong>longest  prefix matching</strong></font></p>
<p>当给定目标地址查找转发表时，采用 <strong>最长</strong> 地址前缀匹配的目标地址表项</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514195735343.png"
                      alt="image-20230514195735343" style="zoom:50%;" 
                >

<ul>
<li>最长前缀匹配：在路由器中经常采用 <code>TCAMs</code> (ternary content addressable memories ) [<strong>三态内容可存址存储器</strong>]硬件来完成<ul>
<li><font color='red'><strong>内容可寻址</strong></font>：将地址交给 TCAM ，他可以在一个时钟周期内检索出地址，不管表空间有多大</li>
<li>Cisco Catalyst 系列路由器：在 TCAM  中可以存储多达 100多万的路由表项</li>
</ul>
</li>
</ul>
<h5 id="输入端口缓存"><a href="#输入端口缓存" class="headerlink" title="输入端口缓存"></a>输入端口缓存</h5><ul>
<li>当交换机构的速率小于输入端口的汇集速率时， 在输入端口可能要排队<ul>
<li><font color='red'>排队时延以及由于输入缓存溢出造成丢失！</font></li>
<li><font color='red'>Head-of-the-Line (HOL) blocking </font>:排在队头的数据阻止了队列中的其他数据向前移动</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514200521587.png"
                      alt="image-20230514200521587" style="zoom:50%;" 
                >



<h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><p>交换结构位于一台路由器的核心部位，因为正是通过这种交换结构，分组才能实际地从一个输入端口交换（即 转发）到一个输出端口中。交换可以用很多种方式完成</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514201120448.png"
                      alt="image-20230514201120448" style="zoom:50%;" 
                >

<ul>
<li>将分组从 输入缓冲区 传送到合适的输出端口</li>
<li>交换速率：分组可以按照该速率从输入到输出<ul>
<li>运行速率经常是  输入&#x2F;输出链路 速率的若干倍</li>
<li>N 个 输入端口：交换结构的交换速度是 输入速率的 N倍 比较 理想，才不会成为瓶颈</li>
</ul>
</li>
</ul>
<h5 id="通过内存交换"><a href="#通过内存交换" class="headerlink" title="通过内存交换"></a>通过内存交换</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514201733918.png"
                      alt="image-20230514201733918" style="zoom:50%;" 
                >

<ul>
<li>在 CPU 直接控制下的交换，采用传统的计算机</li>
<li>分组被拷贝到 系统内存，CPU从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口</li>
<li>转发速率被内存的带宽限制（数据报通过 BUS两遍)</li>
<li>一次只能转发一个分组</li>
</ul>
<h5 id="通过总线交换"><a href="#通过总线交换" class="headerlink" title="通过总线交换"></a>通过总线交换</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514202132660.png"
                      alt="image-20230514202132660" style="zoom:50%;" 
                >

<ul>
<li>数据报通过共享总线，从输入端口转发到输出端口</li>
<li><font color='red'><strong>总线竞争</strong></font>：交换速率受限于总线带宽</li>
<li>一次处理一个分组路由器</li>
<li>对于 接入或 企业级，速度足够，但是不适合区域或骨干路网络</li>
</ul>
<h5 id="通过互联网络（crossbar-等）的交换"><a href="#通过互联网络（crossbar-等）的交换" class="headerlink" title="通过互联网络（crossbar 等）的交换"></a>通过互联网络（crossbar 等）的交换</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514202435585.png"
                      alt="image-20230514202435585" style="zoom:50%;" 
                >

<ul>
<li>同时并发转发多个分组，克服总线带宽限制</li>
<li>Banyan(榨树）网络，crossbar(纵横）和其它的互联网络被开发，将多个处理器连接成多处理器</li>
<li>当分组从端口A到达，转给端口y;控制器短接相应的两个总线</li>
<li>高级设计：将数据报分片为固定长度的信元，通过交换网络交换</li>
<li>Cisco12000:以60Gbps的交换速率通过互联网络</li>
</ul>
<h4 id="输出端口处理"><a href="#输出端口处理" class="headerlink" title="输出端口处理"></a>输出端口处理</h4><p>如图所示，输出端口处理取出已经存放在输出端口内存中的分组 并将其转发到输出链路上，这包括 选择和取出排队的分组进行传输，执行所需的链路层和物理层传输功能</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514203541178.png"
                      alt="image-20230514203541178" style="zoom:50%;" 
                >

<ul>
<li>当数据报从交换结构的到达速度比传输速率快时，就需要输出端口缓<ul>
<li>数据报（分组）可能会被丢弃，由于拥塞、缓冲区没有空间</li>
</ul>
</li>
<li>由<strong>调度</strong>规则选择排队的数据报进行传输</li>
</ul>
<h4 id="输出端口排队"><a href="#输出端口排队" class="headerlink" title="输出端口排队"></a>输出端口排队</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\CSQ-PC\AppData\Roaming\Typora\typora-user-images\image-20230514204240520.png"
                      alt="image-20230514204240520" style="zoom:50%;" 
                >

<ul>
<li>假设 <code>R-switch</code> 是 <code>R-line</code>  的 N 倍（N： 输入端口的数量）</li>
<li>当多个输入端口同时向输出端口发送时，缓冲该分组（当通过交换网络到达的速率超过 输出速率则缓存）</li>
<li><font color='red'><strong>排队带来延迟，由于输出端口缓存溢出则丢弃数据报</strong></font></li>
</ul>
<p><strong>需要多少缓存</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514204717211.png"
                      alt="image-20230514204717211" style="zoom:50%;" 
                >

<h5 id="调度机制"><a href="#调度机制" class="headerlink" title="调度机制"></a>调度机制</h5><ul>
<li><font color='red'><strong>调度：</strong></font>选择下一个要通过 链路 传输的分组</li>
<li><font color='red'><strong>FIFO scheduling</strong></font> ：按照分组到来的次序发送<ul>
<li><font color='cornflowerblue'><strong>丢弃策略：</strong></font>如果一个分组到达一个满的队列，<strong>哪</strong> 个分组将会被抛弃<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514205112384.png"
                      alt="image-20230514205112384" style="zoom:50%;" 
                ></li>
<li><font color='cornflowerblue'>tail drop：</font>丢弃刚到达的分组</li>
<li><font color='cornflowerblue'>priority ：</font>根据优先权 丢弃&#x2F;移除分组</li>
<li><font color='cornflowerblue'>random：</font> 随机的丢弃&#x2F;移除</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="调度策略：优先权"><a href="#调度策略：优先权" class="headerlink" title="调度策略：优先权"></a>调度策略：优先权</h6><p><font color='red'><strong>优先权调度：</strong></font>发送优先权最高的 分组</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514212515650.png"
                      alt="image-20230514212515650" style="zoom:50%;" 
                >

<ul>
<li>多类，不同类别有不同的优先权<ul>
<li>类别可能依赖于标记或者其他的头部字段</li>
<li>先传优先级高的分组，除非没有</li>
<li>高（低）优先级的分组传输次序：<strong>FIFO</strong></li>
</ul>
</li>
</ul>
<h6 id="调度策略：其他的"><a href="#调度策略：其他的" class="headerlink" title="调度策略：其他的"></a>调度策略：其他的</h6><p><font color='red'><strong>Round Robin (RR) scheduling</strong></font>:</p>
<ul>
<li>多类</li>
<li>循环扫描不同的类型的队列，发送完一类的一个分组，再发送下一类的一个分组，循环所有类</li>
</ul>
<br>

<p><font color='red'><strong>Weighted Fair Queuing (WFQ)</strong></font>:</p>
<ul>
<li>一般化的 Round Robin</li>
<li>在一段时间内，每个队列得到的服务时间是  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514213114084.png"
                      alt="image-20230514213114084" style="zoom:33%;" 
                >, 和权重成正比</li>
<li>每个类在一个循环中获得不同的权重的服务量</li>
</ul>
<h4 id="网际协议：IPv4、寻址、IPv6-及其他"><a href="#网际协议：IPv4、寻址、IPv6-及其他" class="headerlink" title="网际协议：IPv4、寻址、IPv6 及其他"></a>网际协议：IPv4、寻址、IPv6 及其他</h4><p><strong>互联网的网络层</strong></p>
<p>主机、路由器中的网络功能</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514213519902.png"
                      alt="image-20230514213519902" style="zoom:33%;" 
                >



<h5 id="IPv4-数据报格式"><a href="#IPv4-数据报格式" class="headerlink" title="IPv4 数据报格式"></a>IPv4 数据报格式</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514213424029.png"
                      alt="image-20230514213424029" style="zoom:50%;" 
                >

<p>注意到一个IP数据报有总长为20字节的首部（假设无选项）。如果数据报承载一个TCP报文段，则每个（无分片的）数据报共承载了总长40字节的首部（20字节的IP首部加上20字节的TCP首部）以及应用层报文。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514213637847.png"
                      alt="image-20230514213637847" style="zoom:50%;" 
                >



<h5 id="IPv4-数据报分片"><a href="#IPv4-数据报分片" class="headerlink" title="IPv4 数据报分片"></a>IPv4 数据报分片</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514214242287.png"
                      alt="image-20230514214242287" style="zoom:50%;" 
                >

<p>在链路层中我们将知道，并不是所有链路层协议都能承载<strong>相同长度</strong>的网络层分组。<strong>有的协议能承载大数据报，而有的协议只能承载小分组</strong>。例如，<strong>以太网帧能够承载不超过1500字节的数据</strong>，而某些广域网链路的帧可承载不超过576字节的数据。<strong>一个链路层帧能承载的最大数据量叫作最大传送单元（Maximum Transmission Unit,MTU)</strong>。因为每个IP数据报封装在链路层帧中从一台路由器传输到下一台路由器，故<strong>链路层协议的MTU严格地限制着IP数据报的长度</strong>。对IP数据报长度具有严格限制并不是主要问题。问题在于在发送方与目的地路径上的每段链路可能使用不同的链路层协议，且每种协议可能具有不同的MTU。</p>
<ul>
<li>网络链路层有 MTU （最大传输单元） -  链路层帧所携带的最大 数据长度<ul>
<li>不同的链路类型</li>
<li>不同的MTU</li>
</ul>
</li>
</ul>
<p>解决该问题的方法是将IP数据报中的数据分片成两个或更多个较小的IP数据报，用单独的链路层帧封装这些较小的IP数据报，然后通过输出链路发送这些帧。每个这些较小的数据报都称为  <strong>片(fragment)</strong>。</p>
<ul>
<li>大的 IP 数据报在网络上被分片 <ul>
<li>一个数据报被分割成若干个小的数据报<ul>
<li>相同的 IP</li>
<li>不同的偏移量</li>
<li>最后一个分片标记为 0</li>
</ul>
</li>
<li>“重组”  只在 最终的目标主机上进行</li>
<li>IP 头部的信息被用于 标识 、排序相关分片</li>
</ul>
</li>
</ul>
<p>当一台目的主机<strong>从相同源收到一系列数据报时</strong>，它需要确定这些数据报中的某些是否是一些原来较大的数据报的片。如果某些数据报是这些片的话，则它必须<strong>进一步确定何时收到了最后一片</strong>，并且<strong>如何将这些接收到的片拼接到一起以形成初始的数据报</strong>。为了让目的主机执行这些重新组装任务，IPv4的设计者将<strong>标识、标志和片偏移字段放在IP数据报首部中</strong>。当生成一个数据报时，发送主机在为该数据报设置源和目的地址的同时贴上标识号。发送主机通常将它发送的每个数据报的标识号加1。当某路由器需要对一个数据报分片时，形成的每个数据报（即片）具有初始数据报的源地址、目的地址与标识号。当目的地从同一发送主机收到一系列数据报时，它能够检查数据报的标识号以确定哪些数据报实际上是同一较大数据报的片。由于IP是一种不可靠的服务，一个或多个片可能永远到达不了目的地。因为这种原因，为了让目的主机绝对地相信它已收到了初始数据报的最后一个片，<strong>最后一个片的标志比特被设为0,而所有其他片的标志比特被设为1</strong>。另外，为了让目的主机<strong>确定是否丢失</strong>了一个片（且能按正确的顺序重新组装片）,<strong>使用偏移字段指定该片应放在初始IP数据报的哪个位置</strong>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514214611096.png"
                      alt="image-20230514214611096" style="zoom: 67%;" 
                >

<h5 id="IPv4-编址"><a href="#IPv4-编址" class="headerlink" title="IPv4 编址"></a>IPv4 编址</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514232240080.png"
                      alt="image-20230514232240080" style="zoom:50%;" 
                >

<p>然而，在讨论IP编址之前，我们需要简述一下<strong>主机与路由器连入网络的方法</strong>。一台主机通常<strong>只有一条链路连接到网络</strong>；当主机中的IP想发送一个数据报时，它就在该链路上发送。<strong>主机与物理链路之间的边界</strong>叫作<strong>接口（interface)</strong>。现在考虑一台路由器及其接口。因为路由器的任务是从链路上接收数据报并从某些其他链路转发出去，路由器必须拥有两条或更多条链路与它连接。路由器与它的任意一条链路之间的边界也叫作接口。一台路由器因此有多个接口，每个接口有其链路。因为每台主机与路由器都能发送和接收IP数据报，<strong>IP要求每台主机和路由器接口拥有自己的IP地址</strong>。因此，从技术上讲，<strong>一个IP地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联。</strong></p>
<p>每个IP地址长度为32比特（等价为4字节）,因此总共有232个（或大约40亿个）可能的IP地址。这些地址通常按所谓点分十进制记法（dotted-decimal notation)书写，即地址中的每个字节用它的十进制形式书写，各字节间以句点隔开。例如，考虑IP地址193.32.216.9,193是该地址的第一个8比特的十进制等价数，32是该地址的第二个8比特的 十进制 等价数，因此 该地址的 二进制记法是：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514232552130.png"
                      alt="image-20230514232552130"
                ></p>
<p>在全球因特网中的每台主机和路由器上的每个接口，都必须有一个全球唯一的IP地址（在NAT后面的接口除外）。然而，<strong>这些地址不能随意地自由选择</strong>。一个接口的IP地址的一部分需要<strong>由其连接的子网来决定</strong>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514233034873.png"
                      alt="image-20230514233034873" style="zoom: 67%;" 
                >

<ul>
<li><font color='cornflowerblue'><strong>IP 地址</strong></font>：<ul>
<li>子网部分（高位 bits)</li>
<li>主机部分（低位 bits)</li>
</ul>
</li>
<li><font color='cornflowerblue'><strong>什么是 子网（Subnet）</strong></font><ul>
<li>一个子网内的节点（主机或者路由器）他们的 <font color='red'><strong>IP 地址的高位部分相同</strong></font>，这些节点构成的 网络的一部分 叫作 <strong>子网</strong></li>
<li><font color='red'><strong>无需路由器介入</strong></font>，子网内 各主机可以在物理上 相互直接到达</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514233205864.png"
                      alt="image-20230514233205864" style="zoom:50%;" 
                >

<p><font color='red'><strong><u>方法</u></strong></font>：</p>
<ul>
<li>要判断一个子网，将每一个接口从主机或者路由器上分开，构成了一个个网络的孤岛</li>
<li><font color='red'><strong>每一个孤岛（网络）都是一个都可以被称之为 subnet</strong></font></li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514233354259.png"
                      alt="image-20230514233354259" style="zoom:50%;" 
                >



<h6 id="IP-地址分类"><a href="#IP-地址分类" class="headerlink" title="IP  地址分类"></a>IP  地址分类</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514233424594.png"
                      alt="image-20230514233424594" style="zoom:50%;" 
                >



<h6 id="特殊的-IP-地址"><a href="#特殊的-IP-地址" class="headerlink" title="特殊的 IP 地址"></a>特殊的 IP 地址</h6><ul>
<li><p>一些约定</p>
<ul>
<li>子网部分：全为 0  — 本网络</li>
<li>主机部分：全为 0  —  本主机</li>
<li>主机部分： 全为 1 — 广播地址，这个网络的所有主机</li>
</ul>
</li>
<li><p>特殊 的  IP 地址</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514233600034.png"
                      alt="image-20230514233600034" style="zoom:80%;" 
                ></li>
</ul>
<h6 id="内网（专用）IP-地址"><a href="#内网（专用）IP-地址" class="headerlink" title="内网（专用）IP 地址"></a>内网（专用）IP 地址</h6><ul>
<li><p>专用地址：地址空间的一部分  供专用地址使用</p>
</li>
<li><p>永远不会被 当做公用地址来分配，不会与公用地址重复</p>
<ul>
<li>只在局部网络中有意义，区分不同的设备</li>
</ul>
</li>
<li><p>路由器不对 目标地址是专用地址的分组进行转发</p>
</li>
<li><p>专用地址范围</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514233944638.png"
                      alt="image-20230514233944638" style="zoom:50%;" 
                ></li>
</ul>
<h6 id="IP-编址：CIDR"><a href="#IP-编址：CIDR" class="headerlink" title="IP 编址：CIDR"></a>IP 编址：CIDR</h6><p><font color='red'><strong>CIDR：</strong></font> <strong>Classess InterDomain Routing</strong></p>
<p>(无类域间路由)</p>
<ul>
<li>子网部分可以在任意的位置</li>
<li>地址格式： <strong>a.b.c.d&#x2F;x</strong>，其中 X 是 地址中子网号的 长度</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514234248298.png"
                      alt="image-20230514234248298" style="zoom:50%;" 
                >



<h6 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514234658861.png"
                      alt="image-20230514234658861" style="zoom:67%;" 
                >



<h6 id="转发表和转发算法"><a href="#转发表和转发算法" class="headerlink" title="转发表和转发算法"></a>转发表和转发算法</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514235003626.png"
                      alt="image-20230514235003626" style="zoom:67%;" 
                >

<ul>
<li>获得 IP 数据报的 目标地址</li>
<li>对于转发表中的每一个表项<ul>
<li>如 （IP Des addr) &amp; （mask) &#x3D;&#x3D; destination ,则按照表项对应的接口转发该数据报</li>
<li>如果都没有找到，则使用默认表项转发数据报</li>
</ul>
</li>
</ul>
<h6 id="如何获得一个-IP-地址"><a href="#如何获得一个-IP-地址" class="headerlink" title="如何获得一个 IP 地址"></a>如何获得一个 IP 地址</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230514235209570.png"
                      alt="image-20230514235209570" style="zoom:50%;" 
                >



<h6 id="DHCP：Dynamic-Host-Configuration-Protocol"><a href="#DHCP：Dynamic-Host-Configuration-Protocol" class="headerlink" title="DHCP：Dynamic Host Configuration Protocol"></a>DHCP：Dynamic Host Configuration Protocol</h6><p>由于DHCP具有将主机连接进一个网络的网络相关方面的自动能力，故它又常被称为即插即用协议（plug-and-play protocol)或零配置（zeroconf)协议</p>
<p><font color='red'><strong>目标</strong></font>：允许主机在加入网络的时候， <strong>动态的</strong> 从服务器那里获取	 IP 地址</p>
<ul>
<li>可以更新对主机的在用 IP 地址的租用期  -  租期快到</li>
<li>重新启动时，允许重新使用之前的 IP 地址</li>
<li>支持移动网络用户加入该网络 （短期在网)</li>
</ul>
<p><strong>DHCP 工作概况</strong></p>
<ul>
<li>主机广播 <font color='cornflowerblue'><strong>DHCP discover</strong></font> 报文可选</li>
<li>DHCP 服务器 用 <font color='cornflowerblue'><strong>DHCP offer</strong></font> 提供报文响应</li>
<li>主机请求 IP 地址 ：发送 <font color='cornflowerblue'><strong>DHCP request</strong></font> 报文</li>
<li>DHCP 服务器发送地址：<font color='cornflowerblue'>**DHCP  ack **</font> 报文</li>
</ul>
<br>

<p><strong>DHCP client-server scenario</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515092613335.png"
                      alt="image-20230515092613335" style="zoom:67%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515092627099.png"
                      alt="image-20230515092627099"
                ></p>
<p><strong>DHCP 不仅仅只是 IP address</strong></p>
<p>DHCP 返回</p>
<ul>
<li>IP地址</li>
<li>第一跳路由器的 IP 地址（默认网关）</li>
<li>DNS服务器的域名和 IP 地址</li>
<li>子网掩码（指示地址部分的网络号和主机号）</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515092829124.png"
                      alt="image-20230515092829124" style="zoom:50%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515104801933.png"
                      alt="image-20230515104801933" style="zoom:50%;" 
                >

<p>对于一个新到达的主机，DHCP 是一个 4 个步骤的过程</p>
<ul>
<li>DHCP 服务器发现<ul>
<li>一台新到达的主机的首要任务就是发现一个 要与其交互 的 DHCP 服务器，这可以通过 <strong>DHCP发现报文  （DHCP discover message）</strong> 来完成</li>
</ul>
</li>
<li>DHCP 服务器提供<ul>
<li>DHCP 服务器发现收到一个 DHCP 发现报文时，用 <strong>DHCP 提供 报文（DHCP offer message)</strong> 向客户 做出响应，该报文向该子网的所有节点广播    ，仍然使用 广播地址 <code>255.255.255.255</code></li>
</ul>
</li>
<li>DHCP 请求<ul>
<li>新到达的客户从一个或多个服务器提供中选择一个，并向选中的服务器提供用DHCP请求报文（DHCP request message)进行响应，回显配置的参数。</li>
</ul>
</li>
<li>DHCP ack<ul>
<li>服务器用DHCP ACK报文（DHCP ACK message)对DHCP请求报文进行响应，证实所要求的参数。</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515093545638.png"
                      alt="image-20230515093545638" style="zoom:33%;" 
                >

<p>一旦客户收到 <code>DHCP ack</code> 后，交互便完成了，并且该用户能在租用期内使用 DHCP 分配的IP 地址而且 DHCP 还 <strong>允许客户更新它对一个 IP 地址的租用</strong></p>
<p>从移动性角度看，DHCP确实有非常严重的缺陷。因为每当节点连到一个新子网，要从DHCP得到一个新的IP地址，<strong>当一个移动节点在子网之间移动时，就不能维持与远程应用之间的TCP连接</strong>。在后面，我们将研究移动IP,它是一种对IP基础设施的扩展，允许移动节点在网络之间移动时使用其单一永久的地址。</p>
<h6 id="层次编址：路由聚集-（route-aggregation"><a href="#层次编址：路由聚集-（route-aggregation" class="headerlink" title="层次编址：路由聚集 （route aggregation)"></a>层次编址：路由聚集 （route aggregation)</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515104947295.png"
                      alt="image-20230515104947295" style="zoom:50%;" 
                >



<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515105005485.png"
                      alt="image-20230515105005485" style="zoom:50%;" 
                >



<h6 id="IP-编址：如何获得一块地址"><a href="#IP-编址：如何获得一块地址" class="headerlink" title="IP 编址：如何获得一块地址"></a>IP 编址：如何获得一块地址</h6><p><strong>一个 ISP 如何获得一个 地址</strong></p>
<p><font color='red'><strong>ICANN</strong></font> ：**Internet Corporation for Assigned Names and Numbers **</p>
<ul>
<li>分配地址</li>
<li>管理 DNS</li>
<li>分配域名，解决冲突</li>
</ul>
<h5 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h5><h6 id="NAT-（Network-Address-Translation"><a href="#NAT-（Network-Address-Translation" class="headerlink" title="NAT （Network Address Translation)"></a>NAT （Network Address Translation)</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515110153640.png"
                      alt="image-20230515110153640" style="zoom:50%;" 
                >

<ul>
<li><font color='red'><strong>动机</strong></font>：本机网络只有一个有效的 IP 地址<ul>
<li>不需要 从 ISP 分配一块地址，可用一个 IP 地址用于所有的 （局域网）设备   —  省钱</li>
<li>可以在局域网改变设备的地址情况下而无须通知外界</li>
<li>可以改变 ISP（地址变化）而不需要改变内部的设备地址</li>
<li>局域网内部的设备没有具体的地址，对外是不可见的</li>
</ul>
</li>
<li><font color='red'><strong>实现</strong></font>：NAT 路由器 必须：<ul>
<li><font color='cornflowerblue'><strong>外出数据包</strong></font>: 替换 <font color='red'>源地址和端口号</font>为 NAT IP 地址和新的端口号，目标 IP 劲儿端口不变</li>
<li><font color='cornflowerblue'>记住</font> 每个转换替换对（在 NAT 转换表中）</li>
<li><font color='cornflowerblue'><strong>进入数据包</strong></font>：替换 <font color='red'>目标IP 地址和 端口号</font>，采用存储在 NAT 表中的<code>mapping</code> 表项</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515105338533.png"
                      alt="image-20230515105338533" style="zoom: 33%;" 
                >

<p>NAT使能路由器对于外部世界来说甚至不像一台路由器。相反NAT路由器<strong>对外界的行为就如同一个具有单一IP地址的单一设备</strong>。在图4-25中，所有离开家庭路由器流向更大因特网的报文都拥有一个源IP地址138.76.29.7,且所有进入家庭的报文都拥有同一个目的IP地址138.76.29.7。从本质上讲，NAT使能路由器对外界隐藏了家庭网络的细节。(另外，你也许想知道家庭网络计算机是从哪儿得到其地址，路由器又是从哪儿得到它的单一IP地址的。在通常的情况下，答案是相同的，即DHCP!路由器从ISP的DHCP服务器得到它的地址，并且路由器运行一个DHCP服务器，为位于NAT-DHCP路由器控制的家庭网络地址空间中的计算机提供地址。）</p>
<p>如果从广域网到达NAT路由器的所有数据报都有相同的目的IP地址（特别是对NAT路由器广域网一侧的接口）,那么该路由器怎样知道它应将某个分组转发给哪个内部主机呢？技巧就是使用NAT路由器上的一张**NAT转换表（NAT translation table),**并且在表项中包含了端口号及其IP地址。</p>
<ul>
<li>16 - bit 端口字段<ul>
<li>6 万多个同时连接，一个局域网</li>
</ul>
</li>
<li>有 NAT 是 <strong>有争议的</strong><ul>
<li>路由器 只应该对 第 3 层 做信息处理，而这里对 端口号（4 层） 做了处理</li>
<li>违反了 end - to - end 原则<ul>
<li>端到端原则：复杂性放到 <strong>网络边缘</strong><ul>
<li>无需借助 中转和 变换，就可以直接转送到目标主机</li>
</ul>
</li>
<li>NAT 可能要被一些 应用设计者考虑</li>
<li>外网的机器无法主动连接到内网的机器上</li>
</ul>
</li>
<li>地址短缺问题可以被 IPv6 解决</li>
<li>**NAT 穿越：**如果客户端需要连接 在 NAT 后面的机器，应该如何操作</li>
</ul>
</li>
</ul>
<br>

<p><strong>NAT 穿越</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515111031804.png"
                      alt="image-20230515111031804" style="zoom:50%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515111048816.png"
                      alt="image-20230515111048816" style="zoom:50%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515111102338.png"
                      alt="image-20230515111102338" style="zoom:50%;" 
                >

<h5 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h5><p><font color='red'><strong>初始动机</strong></font>：32 - bit 的地址空间将很快被用完</p>
<p><strong>另外的动机</strong>：	</p>
<ul>
<li>头部格式改变 帮助加速处理和转发<ul>
<li>TTL-1</li>
<li>头部 checksum</li>
<li>分片</li>
</ul>
</li>
<li>头部格式 帮助改变 QoS</li>
</ul>
<h6 id="IPv6-数据报格式"><a href="#IPv6-数据报格式" class="headerlink" title="IPv6 数据报格式"></a>IPv6 数据报格式</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515111356190.png"
                      alt="image-20230515111356190" style="zoom:50%;" 
                >

<h6 id="IPv6-头部（cont"><a href="#IPv6-头部（cont" class="headerlink" title="IPv6 头部（cont)"></a>IPv6 头部（cont)</h6><p><font color='red'><strong>Priority</strong></font>: 标识流中数据报的等级</p>
<p><font color='red'><strong>Low Label</strong></font>： 标识一个数据在一个 flow </p>
<p><font color='red'><strong>Next header：</strong></font>标示上层协议</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515204516524.png"
                      alt="image-20230515204516524" style="zoom:50%;" 
                >



<h6 id="和-IPv4-的变化"><a href="#和-IPv4-的变化" class="headerlink" title="和 IPv4 的变化"></a>和 IPv4 的变化</h6><ul>
<li><code>checksum</code>:  被移除，降低在每一段中的处理速度</li>
<li><code>options</code>: 允许，但是在头部之外，被 <code>Next Header </code> 字段标识</li>
<li><font color='red'><strong>ICMPv6</strong></font>: ICMP 的新版本<ul>
<li>附加了 报文类型</li>
<li>多播组管理功能</li>
</ul>
</li>
</ul>
<h6 id="从-IPv4-到-IPv6-的迁移"><a href="#从-IPv4-到-IPv6-的迁移" class="headerlink" title="从 IPv4 到 IPv6 的迁移"></a>从 IPv4 到 IPv6 的迁移</h6><ul>
<li><p>不是所有路由器都可以同时升级的</p>
<ul>
<li>没有一个 标记日  “flag days”</li>
<li>在 IPv4 和 IPv6 路由器混合时，网络如何运转</li>
</ul>
</li>
<li><p><font color='red'><strong>隧道</strong></font>：在 IPv4 路由器之间传输的  IPv4 数据报中携带 IPv6 数据报</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515205022875.png"
                      alt="image-20230515205022875" style="zoom:50%;" 
                ></li>
</ul>
<br>

<p><strong>隧道</strong>  （Tunneling）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515205117805.png"
                      alt="image-20230515205117805" style="zoom:50%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515205147480.png"
                      alt="image-20230515205147480" style="zoom:50%;" 
                >



<h6 id="IPv6-的应用"><a href="#IPv6-的应用" class="headerlink" title="IPv6 的应用"></a>IPv6 的应用</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515205222205.png"
                      alt="image-20230515205222205" style="zoom:50%;" 
                >



<h4 id="通用转发-和-SDN"><a href="#通用转发-和-SDN" class="headerlink" title="通用转发 和 SDN"></a>通用转发 和 SDN</h4><h5 id="网络层为例的数据平面和控制平面"><a href="#网络层为例的数据平面和控制平面" class="headerlink" title="网络层为例的数据平面和控制平面"></a>网络层为例的数据平面和控制平面</h5><h6 id="网络层功能"><a href="#网络层功能" class="headerlink" title="网络层功能"></a>网络层功能</h6><ul>
<li>转发：对于从某个端口到来的分组转发到 合适的 输出端口</li>
<li>路由：决定分组从 源端到 目标端的算法<ul>
<li>路由算法</li>
</ul>
</li>
</ul>
<h6 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h6><ul>
<li>本地的、每个路由器的功能</li>
<li>决定某个从某个端口进入的分组从哪个端口输出</li>
<li>转发功能</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515205807265.png"
                      alt="image-20230515205807265" style="zoom:50%;" 
                >

<h6 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h6><ul>
<li>网络范围的逻辑</li>
<li>决定分组 端到端穿行于 各个 路由器的路径</li>
</ul>
<h6 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515210801653.png"
                      alt="image-20230515210801653" style="zoom:50%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515211400559.png"
                      alt="image-20230515211400559" style="zoom:50%;" 
                >



<p><strong>网络设备控制平面实现方式的特点</strong></p>
<ul>
<li>互联网网络设备 ：传统方式都是通过分布式，每台设备的方法来实现数据平面和 控制平面功能<ul>
<li><font color='red'>垂直集成</font>：每台路由器或其他 网络设备，包括：<ul>
<li>硬件、在私有的 操作系统</li>
<li>互联网 标准协议的 私有实现</li>
<li>从上到下都由一个厂商提供</li>
</ul>
</li>
<li>每个设备都实现了数据平面和 控制平面<ul>
<li>控制平面的功能是<strong>分布式</strong>  实现的</li>
</ul>
</li>
<li>设备基本上只能（分布式升级难） <strong>按照固定方式工作</strong>，控制逻辑固化，不同的网络设备需要不同的 防火墙、负载均衡设备</li>
</ul>
</li>
<li>（数据 +  控制平面） 集成 &gt; （控制逻辑） 分布 -&gt; 固化<ul>
<li>代价大；升级困难；管理困难</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515212037701.png"
                      alt="image-20230515212037701" style="zoom:50%;" 
                >



<p><strong>SDN：逻辑上的控制平面</strong></p>
<p>一个不同的（通常是远程的） 控制器和 CA 交互，控制器决定 分组的转发逻辑（可编程），CA 所在设备执行逻辑</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515212252409.png"
                      alt="image-20230515212252409" style="zoom:50%;" 
                >



<h5 id="通用转发-和-SDN-1"><a href="#通用转发-和-SDN-1" class="headerlink" title="通用转发 和 SDN"></a>通用转发 和 SDN</h5><p>回顾之前将基于目的地转发的特征总结为两个步骤：<strong>查找目的IP地址（“匹配”）</strong>,然后<strong>将分组发送到有特定输出端口的交换结构（“动作”）</strong>。我们现在考虑一种更有意义的<strong>通用“匹配加动作”范式</strong>，其中能够对协议栈的多个首部字段进行“匹配”，这些首部字段是与不同层次的不同协议相关联的。<strong>“动作”能够包括：将分组转发到一个或多个输出端口（就像在基于目的地转发中一样）,跨越多个通向服务的离开接口进行负载均衡分组（就像在负载均衡中一样）,重写首部值（就像在NAT中一样）,有意识地阻挡&#x2F;丢弃某个分组（就像在防火墙中一样）,为进一步处理和动作而向某个特定的服务器发送一个分组（就像在DPI一样）</strong>,等等。在通用转发中，一张匹配加动作表将我们在数据平面中看到的基于目的地的转发表一般化了。因为能够使用网络层和&#x2F;或链路层源和目的地址做出转发决定，所以显示在图4-28中的转发设备更为准确地描述为“分组交换机”而不是第三层“路由器”或第二层“交换机”。因此，在本节后面部分以及控制平面中，我们将这些设备称为分组交换机，这是在SDN文献中被广泛采用的术语。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515210356985.png"
                      alt="image-20230515210356985" style="zoom: 33%;" 
                >

<p>我们后续对通用转发的讨论将基于 OpenFlow , OpenFlow 是一个得到高度认可和成功的标准，它已经成为匹配加动作转发抽象、控制器以及更为一般的SDN革命等概念的先驱[Feamster2013]。我们将主要考虑OpenFlow1.0,该标准以特别清晰和简明的方式引入了关键的SDN抽象和功能。</p>
<p><strong>匹配加动作转发表在OpenFlow中称为流表（flow table)</strong>,它的每个表项包括：</p>
<ul>
<li>首部字段值的集合，入分组将与之匹配。与基于目的地转发的情况一样，基于硬件匹配在TCAM内存中执行得最为迅速（TCAM内存中可能有上百万条地址表项）[Bosshart2013]。匹配不上流表项的分组将被丢弃或发送到远程控制器做更多处理。在实践中，为了性能或成本原因，一个流表可以由多个流表实现[Bosshart2013],但我们这里只关注单一流表的抽象。</li>
<li>计数器集合（当分组与流表项匹配时更新计数器）。这些计数器可以包括已经与该表项匹配的分组数量，以及自从该表项上次更新以来的时间。</li>
<li>当分组匹配流表项时所采取的动作集合。这些动作可能将分组转发到给定的输出端口，丢弃该分组、复制该分组和将它们发送到多个输出端口，和&#x2F;或重写所选的首部字段。</li>
</ul>
<h5 id="SDN"><a href="#SDN" class="headerlink" title="SDN"></a>SDN</h5><h6 id="SDN-的主要思路"><a href="#SDN-的主要思路" class="headerlink" title="SDN 的主要思路"></a>SDN 的主要思路</h6><ul>
<li>网络设备数据平面和 控制平面 分离</li>
<li>数据平面 - 分组交换机<ul>
<li>将 路由器、交换机 和目前大多数网络设备的功能进一步 <font color='red'><strong>抽象</strong></font> 成： 按照流表（由控制平面 设置的 逻辑） 进行 PDU （帧、分组）的动作 （包括转发、丢弃、拷贝、泛洪、阻塞）</li>
<li><font color='red'><strong>统一化</strong></font> 设备功能：SDN 交换机（分组交换机），执行控制逻辑</li>
</ul>
</li>
<li>控制平面 - 控制器 + 网络应用<ul>
<li>分离、集中</li>
<li>计算和下发控制逻辑：流表</li>
</ul>
</li>
</ul>
<h6 id="SDN-控制平面-和-数据平面分离的优势"><a href="#SDN-控制平面-和-数据平面分离的优势" class="headerlink" title="SDN 控制平面 和 数据平面分离的优势"></a>SDN 控制平面 和 数据平面分离的优势</h6><ul>
<li><font color='red'>水平集成</font> 控制平面的 <strong>开放实现</strong>（而非私有实现）。创造出良好的生态，促进发展<ul>
<li>分组交换机、控制器和各种控制逻辑网络应用 app 可由不同厂商生产，专业化，引入竞争形成良好生态</li>
</ul>
</li>
<li><font color='red'>集中</font> 式 实现控制逻辑，网络 <strong>管理容易</strong><ul>
<li>集中式控制器了解 网络状况，编程简单，传统方式困难</li>
<li>避免路由器的 误配置</li>
</ul>
</li>
<li>基于 流表的 <strong>匹配 + 行动</strong> 的工作方式 允许 “<strong>可编程的</strong>” 的 分组交换机<ul>
<li>实现流量工程等高级特性</li>
<li>在此框架下实现各种 新型（未来）的网络设备</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515214214206.png"
                      alt="image-20230515214214206" style="zoom:50%;" 
                >



<h6 id="流量工程"><a href="#流量工程" class="headerlink" title="流量工程"></a>流量工程</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515214414455.png"
                      alt="image-20230515214414455"
                ></p>
<h6 id="SDN-特点"><a href="#SDN-特点" class="headerlink" title="SDN 特点"></a>SDN 特点</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515214518543.png"
                      alt="image-20230515214518543" style="zoom:50%;" 
                >



<h6 id="SDN-架构：数据平面交换机"><a href="#SDN-架构：数据平面交换机" class="headerlink" title="SDN 架构：数据平面交换机"></a>SDN 架构：数据平面交换机</h6><p><font color='red'><strong>数据平面交换机</strong></font></p>
<ul>
<li>快速、简单，商业化 交换设备 采用硬件实现通用转发功能</li>
<li>流表被 控制器计算和安装</li>
<li>基于 南向 API ，SDN 控制器访问基于流的交换机<ul>
<li>定义了哪些可以，哪些不能</li>
</ul>
</li>
<li>也定义了和 控制器的协议</li>
</ul>
<h6 id="SDN架构：SDN-控制器"><a href="#SDN架构：SDN-控制器" class="headerlink" title="SDN架构：SDN 控制器"></a>SDN架构：SDN 控制器</h6><p><font color='red'><strong>SDN 控制器</strong></font> （网络 OS）：</p>
<ul>
<li>维护网络状态信息</li>
<li>通过上面的南向 API 和网络交换机交互</li>
<li>逻辑集中，但是在实现上 通常由性能、可扩展性、容错性以及健壮性 采用分布式方法</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515215015517.png"
                      alt="image-20230515215015517" style="zoom:50%;" 
                >



<h6 id="SDN-架构：控制应用"><a href="#SDN-架构：控制应用" class="headerlink" title="SDN 架构：控制应用"></a>SDN 架构：控制应用</h6><p><font color='red'><strong>网络控制应用</strong></font></p>
<ul>
<li>控制的大脑：采用下层提供的服务（SDN控制器提供的API），实现网络功能<ul>
<li>路由器  交换机</li>
<li>接入控制  防火墙</li>
<li>负载均衡</li>
<li>其他功能</li>
</ul>
</li>
<li>非绑定：可以被第三方提供，与控制器厂商通常不同，与分组交换机也可以不同</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\CSQ-PC\AppData\Roaming\Typora\typora-user-images\image-20230515224315007.png"
                      alt="image-20230515224315007" style="zoom:50%;" 
                >



<h5 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515212502680.png"
                      alt="image-20230515212502680" style="zoom:50%;" 
                >

<p>图4-29显示了11个分组首部字段和入端口ID,该ID能被OpenFlow1.0中的匹配加动作规则所匹配。前面讲过，到达一台分组交换机的一个链路层（第二层）帧将包含一个网络层（第三层）数据报作为其有效载荷，该载荷通常依次将包含一个运输层(第四层）报文段。第一个观察是，OpenFlow的匹配抽象允许对来自三个层次的协议首部所选择的字段进行匹配（因此相当勇敢地违反了我们在1.5节中学习的分层原则）。因为我们还没有涉及链路层，用如下的说法也就足够了：显示在图4-29中的源和目的MAC地址是与帧的发送和接收接口相关联的链路层地址；通过基于以太网地址而不是IP地址进行转发，我们看到OpenFlow使能的设备能够等价于路由器（第三层设备）转发数据报以及交换机（第二层设备）转发帧。</p>
<p>入端口是指 <strong>分组交换机上接收分组的输入接口</strong></p>
<p>最后，<strong>并非一个 IP 首部中的所有字段都能被匹配</strong></p>
<blockquote>
<p>在一个时刻做一件事，将它做好。一个接口应当俘获	一个抽象的最低限度的要件。不要进行一般化，一般化通常是错误的</p>
</blockquote>
<h5 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h5><p>如图4-28中所见，每个流表项都有零个或多个动作列表，<strong>这些动作决定了应用于与流表项匹配的分组的处理</strong>。如果有多个动作，它们以在表中<strong>规定的次序执行</strong>。</p>
<p>其中最为重要的动作可能是：</p>
<ul>
<li><strong>转发</strong>。一个人分组可以转发到一个特定的物理输出端口，广播到所有端口（分组到达的端口除外）,或通过所选的端口集合进行多播。该分组可能被封装并发送到用于该设备的远程控制器。该控制器则可能（或可能不）对该分组采取某些动作，包括安装新的流表项，以及可能将该分组返回给该设备以在更新的流表规则集合下进行转发。</li>
<li>丢弃。没有动作的流表项表明某个匹配的分组应当被丢弃。</li>
<li>修改字段。在分组被转发到所选的输出端口之前，分组首部10个字段（图4-29中显示的除IP协议字段外的所有第二、三、四层的字段）中的值可以重写。</li>
</ul>
<h5 id="OpenFlow-数据平面抽象"><a href="#OpenFlow-数据平面抽象" class="headerlink" title="OpenFlow 数据平面抽象"></a>OpenFlow 数据平面抽象</h5><ul>
<li><font color='cornflowerblue'><strong>流</strong></font>： <font color='cornflowerblue'>由分组（帧） 头部字段所定义</font></li>
<li><font color='cornflowerblue'><strong>通用转发</strong></font>：<font color='cornflowerblue'>简单的分组处理规则</font><ul>
<li><strong>模式</strong>：将分组头部字段和流表进行匹配</li>
<li><strong>行动</strong>：对于匹配上的分组，可以是 <font color='red'><strong>丢弃、转发、修改 、将 匹配的分组发送给控制器</strong></font> </li>
<li><strong>优先权</strong>：几个模式匹配了，优先采用那个，消除歧义</li>
<li><strong>计数器</strong>：# bytes 以及 #packets</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515224952541.png"
                      alt="image-20230515224952541" style="zoom:67%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515225010459.png"
                      alt="image-20230515225010459"
                ></p>
<h6 id="OpenFlow：流表的表项结构"><a href="#OpenFlow：流表的表项结构" class="headerlink" title="OpenFlow：流表的表项结构"></a>OpenFlow：流表的表项结构</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515225041601.png"
                      alt="image-20230515225041601" style="zoom:67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515225653079.png"
                      alt="image-20230515225653079" style="zoom:80%;" 
                >



<h6 id="OpenFlow-抽象"><a href="#OpenFlow-抽象" class="headerlink" title="OpenFlow 抽象"></a>OpenFlow 抽象</h6><ul>
<li><font color='red'><strong>match + action</strong></font> ：统一化各种网络设备提供的功能</li>
<li>路由器<ul>
<li><font color='cornflowerblue'>match</font>：最长前缀匹配</li>
<li><font color='cornflowerblue'>action：</font> 通过一条链路转发</li>
</ul>
</li>
<li>交换机<ul>
<li><font color='cornflowerblue'>match：</font>目标 MAC 地址</li>
<li><font color='cornflowerblue'>action</font>：转发或者泛洪</li>
</ul>
</li>
<li>防火墙<ul>
<li><font color='cornflowerblue'>match</font>：IP 地址和 TCP&#x2F;UDP 端口号</li>
<li><font color='cornflowerblue'>action：</font>允许或者禁止</li>
</ul>
</li>
<li>NAT<ul>
<li><font color='cornflowerblue'>match</font>: IP 地址和端口号</li>
<li><font color='cornflowerblue'>action：</font> 重写地址</li>
</ul>
</li>
</ul>
<blockquote>
<p>目前几乎所有的网络设备都可以在这个匹配+行动模式框架进行描述，具体化为各种网络设备包括未来的网络设备</p>
</blockquote>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230515230115689.png"
                      alt="image-20230515230115689" style="zoom: 80%;" 
                >



<h3 id="网络层：控制平面"><a href="#网络层：控制平面" class="headerlink" title="网络层：控制平面"></a>网络层：控制平面</h3><hr>
<p><strong>本章目标</strong> ： 理解网络层 控制平面的 <strong>工作原理</strong></p>
<ul>
<li>传统路由算法</li>
<li>SDN 控制器</li>
<li>ICMP： Internet Control Message Protocol </li>
<li>网络管理（略）</li>
</ul>
<br>

<p>以及他们在互联网上的实现和实例</p>
<p>在本章中，我们将通过包含网络层的控制平面组件来完成我们的网络层之旅。<strong>控制平面作为一种网络范围的逻辑</strong>，不仅<strong>控制沿着从源主机到目的主机的端到端路径间的路由器如何转发数据报，而且控制网络层组件和服务如何配置和管理</strong>。我们将包含传统的计算图中最低开销路径的路由选择算法。这些算法是两个广为部署的因特网路由选择协议OSPF和BGP的基础，OSPF是一种运行在单一ISP的网络中的路由选择算法。BCP是一种在因特网中用于互联所有网络的路由选择算法，因此常被称为因特网的“黏合剂”。传统上，控制平面功能与数据平面的转发功能在一起实现，在路由器中作为统一的整体。如我们在数据平面所学习的那样，软件定义网络（SDN)在数据平面和控制平面之间做了明确分割，在一台分离的“控制器”服务中实现了控制平面功能，该控制器服务与它所控制的路由器的转发组件完全分开并远离。我们将在本章中讨论SDN控制器。还将涉及管理IP网络的某些具体细节：ICMP(互联网控制报文协议）和SNMP(简单网络管理协议）。</p>
<h4 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h4><p><font color='red'><strong>回顾 网络层的内容: <u>两个网络层功能</u></strong></font></p>
<ul>
<li>转发：将分组从路由器的一个输入端口移到一个合适的输出端口   -&gt; <font color='cornflowerblue'><strong>数据平面</strong></font></li>
<li>路由：确定分组从 源端到目标端的路径   -&gt; <font color='cornflowerblue'><strong>控制平面</strong></font></li>
</ul>
<br>

<p><font color='red'><strong>两种构建网络层控制平面的方法</strong></font>：</p>
<ul>
<li>每个路由器控制功能实现（传统）</li>
<li>逻辑上集中的控制功能的实现  -&gt; <font color='cornflowerblue'><strong>SDN</strong></font></li>
</ul>
<br>

<p>我们通过回顾图4-2和图4-3,迅速建立起学习网络控制平面的环境。在这里，我们看到了转发表（在基于目的地转发的场景中）和流表（在通用转发的场景中）是链接网络层的数据平面和控制平面的首要元素。我们知道这些表定义了一台路由器的本地数据平面转发行为。我们看到在通用转发的场景下，所采取的动作不仅包括转发一个分组到达路由器的每个输出端口，而且能够丢弃一个分组、复制一个分组和&#x2F;或重写第2、3或4层分组首部字段。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516193013274.png"
                      alt="image-20230516193013274" style="zoom: 45%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516193049869.png"
                      alt="image-20230516193049869" style="zoom:45%;" 
                ></p>
<p>在本章中，我们将学习这些转发表和流表是如何计算、维护和安装的。在网络层概述中，我们已经学习了完成这些工作有两种可能的方法。</p>
<ul>
<li><p>每路由器控制。图5-1显示了在每台路由器中运行一种路由选择算法的情况，每台路由器中都包含转发和路由选择功能。每台路由器有一个路由选择组件，用于与其他路由器中的路由选择组件通信，以计算其转发表的值。这种每路由器控制的方法在因特网中已经使用了几十年。后面所学习的OSPF和BGP协议都是基于这种每路由器的方法进行控制的。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516193223775.png"
                      alt="image-20230516193223775" style="zoom:50%;" 
                >
</li>
<li><p>逻辑集中式控制。图5-2显示了逻辑集中式控制器计算并分发转发表以供每台路由器使用的情况。通用的“匹配加动作”抽象允许执行传统的IP转发以及其他功能（负载共享、防火墙功能和NAT)的丰富集合，而这些功能先前是在单独的中间盒中实现的。该控制器经一种定义良好的协议与每台路由器中的一个控制代理（CA)进行交互，以配置和管理该路由器的转发表。<strong>CA一般具有最少的功能，其任务是与控制器通信并且按控制器命令行事</strong>。与图5-1中的路由选择算法不同，<strong>这些CA既不能直接相互交互，也不能主动参与计算转发表。这是每路由器控制和逻辑集中式控制之间的关键差异</strong>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516193254168.png"
                      alt="image-20230516193254168" style="zoom:50%;" 
                ></li>
</ul>
<h4 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h4><p>下面我们将介绍 <strong>路由选择算法（routing algorithm)</strong>,<u>其目的是从发送方到接收方的过程中确定一条通过路由器网络的好的路径（等价于路由）</u>。</p>
<p>通常，一条好路径指具有最低开销的路径。然而我们将看到，实践中现实世界还关心诸如策略之类的问题（例如，有一个规则是“属于组织Y的路由器X不应转发任何来源于组织Z所属网络的分组”）。我们注意到无论网络控制平面采用每路由器控制方法，还是采用逻辑集中式控制方法，必定总是存在一条定义良好的一连串路由器，使得分组从发送主机到接收主机跨越网络“旅行”。因此，计算这些路径的路由选择算法是十分重要的，是最重要的10个十分重要的网络概念之一。</p>
<blockquote>
<p><strong>路由选择算法是指在计算机网络中，用于选择网络中最佳路径的算法。路由选择算法的目的是选择一条最佳路径，以便在网络中传输数据时，能够快速、可靠地到达目的地。</strong></p>
</blockquote>
<h5 id="路由-（route）的概念"><a href="#路由-（route）的概念" class="headerlink" title="路由 （route）的概念"></a>路由 （route）的概念</h5><ul>
<li>路由：按照某种 <strong>指标</strong> （传输延迟、所经过的站点数）找到一条从 源节点到目标节点的 较好路径<ul>
<li>较好路径： <strong>按照某种指标 的较小路径</strong></li>
<li>指标：站数、费用、延迟、或者一些指标的加权平均</li>
<li>采用什么样的指标，表示网络使用者希望网络在什么方面表现突出，什么指标网络使用者比较重视</li>
</ul>
</li>
<li>以 <font color='red'><strong>网络</strong></font> 为单位进行路由 （路由信息通告 + 路由计算）<ul>
<li>网络为单位进行路由，路由信息传输、计算和匹配的代价比较低</li>
<li>前提条件是：一个网络的所有节点地址前缀相同，且物理上聚集 </li>
<li>路由就是 ：计算 网络到其他网络  <strong>如何走</strong>  的问题</li>
</ul>
</li>
<li>网络到网络的 路由 &#x3D; 路由器 - 路由器 之间的路由<ul>
<li>网络对应 的路由器到其他网络对应的路由器 的路由</li>
<li>在一个网络中 ： <strong>路由器 - 主机之间的通信</strong>，链路层解决</li>
<li>到了这个路由器就是这个网络</li>
</ul>
</li>
<li>路由选择算法 （routing algorithm）：网络层软件的一部分，完成路由功能</li>
</ul>
<h6 id="网络的-图抽象"><a href="#网络的-图抽象" class="headerlink" title="网络的 图抽象"></a>网络的 图抽象</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516210246942.png"
                      alt="image-20230516210246942" style="zoom:50%;" 
                >



<h6 id="图抽象：边和路径的代价"><a href="#图抽象：边和路径的代价" class="headerlink" title="图抽象：边和路径的代价"></a>图抽象：边和路径的代价</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516210325002.png"
                      alt="image-20230516210325002" style="zoom:50%;" 
                >

<blockquote>
<p><font color='red'><strong>路由的输入：</strong></font>拓扑、边的代价、源节点</p>
<p><font color='red'><strong>输出的输出</strong></font>：源节点的汇集树</p>
</blockquote>
<br>

<p><strong>最优化原则（optimality principle）</strong></p>
<ul>
<li><strong>汇集树（sink tree)：</strong><ul>
<li>此节点到所有其他节点的最优路径形成的树</li>
<li>路由选择算法 就是为 <strong>所有的路由器  找到 并  使用汇集树</strong></li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516211012724.png"
                      alt="image-20230516211012724" style="zoom:50%;" 
                >



<h5 id="路由的原则"><a href="#路由的原则" class="headerlink" title="路由的原则"></a>路由的原则</h5><ul>
<li>路由选择算法的原则<ul>
<li>正确性（correctness):算法必须是正确的和完整的，使分组一站一站接力，正确发向目标站；完整：目标所有的站地址，在路由表中都能找到相应的表项；没有处理不了的目标站地址；</li>
<li>简单性（simplicity):算法在计算机上应简单：最优但复杂的算法，时间上延迟很大，不实用，不应为了获取路由信息增加很多的通信量；</li>
<li>健壮性（robustness):算法应能适应通信量和网络拓扑的变化：通信量变化，网络拓扑的变化算法能很快适应；不向很拥挤的链路发数据，不向断了的链路发送数据；</li>
<li>稳定性（stability):产生的路由不应该摇摆</li>
<li>公平性（fairness):对每一个站点都公平</li>
<li>最优性（optimality):某一个指标的最优，时间上，费用上，等指标，或综合指标；实际上，获取最优的结果代价较高，可以是次优的</li>
</ul>
</li>
</ul>
<h5 id="路由算法分类"><a href="#路由算法分类" class="headerlink" title="路由算法分类"></a>路由算法分类</h5><p><font color='red'><strong>全局或者局部路由信息</strong></font></p>
<p><font color='cornflowerblue'><strong>全局</strong></font></p>
<ul>
<li>所有的路由器拥有完整的拓扑和 边的代价的 信息</li>
<li><font color='red'><strong>“link state”</strong></font> LS  链路状态算法</li>
</ul>
<br>

<p><font color='cornflowerblue'><strong>分布式</strong></font></p>
<ul>
<li>路由器只知道与他有物理连接关系的邻居路由器，和到相应邻居的代价值</li>
<li>迭代地与邻居交换路由信息、计算路由信息</li>
<li><font color='red'><strong>“distance vector”</strong></font>  dv 距离向量算法</li>
</ul>
<p>集中式路由选择算法（centralized routing algorithm)用完整的、全局性的网络知识计算出从源到目的地之间的最低开销路径。也就是说，该算法以所有节点之间的连通性及所有链路的开销为输入。这就要求该算法在真正开始计算以前，要以某种方式获得这些信息。计算本身可在某个场点进行，或在每台路由器的路由选择组件中重复进行。然而，这里的主要区别在于，<strong>集中式算法具有关于连通性和链路开销方面的完整信息</strong>。<strong>具有全局状态信息的算法常被称作链路状态（Link State,LS)算法因为该算法必须知道网络中每条链路的开销</strong>。在分散式路由选择算法（decentralized routing algorithm)中，<strong>路由器以迭代、分布式的方式计算出最低开销路径。没有节点拥有关于所有网络链路开销的完整信息相反，每个节点仅有与其直接相连链路的开销知识即可开始工作</strong>。然后，通过<strong>迭代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或一组目的节点的最低开销路径</strong>。之所以叫作DV算法，是因为<strong>每个节点维护到网络中所有其他节点的开销（距离）估计的向量</strong>。这种分散式算法，通过相邻路由器之间的交互式报文交换，也许更为天然地适合那些路由器直接交互的控制平面。</p>
<br>

<p><font color='red'><strong>静态或者动态的</strong></font></p>
<p><font color='cornflowerblue'><strong>静态</strong></font></p>
<ul>
<li>路由随时间变化缓慢</li>
</ul>
<br>

<p><font color='cornflowerblue'><strong>动态</strong></font></p>
<ul>
<li>路由变化很快<ul>
<li>周期性更新</li>
<li>根据链路代价变化而变化</li>
</ul>
</li>
</ul>
<blockquote>
<p>非自适应算法（non-adaptive algorithm)不能适应网络拓扑和通信量的变化，路由表是事先计算好的</p>
<p>自适应路由选择（adaptive algorithm):能适应网络拓扑和通信量的变化</p>
</blockquote>
<p>路由选择算法的第二种广义分类方式是根据算法是静态的还是动态的进行分类。在静态路由选择算法（static routing algorithm)中，路由随时间的变化非常缓慢，通常是人工进行调整（如人为手工编辑一条链路开销）。动态路由选择算法（dynamic routing algorithm)随着网络流量负载或拓扑发生变化而改变路由选择路径。一个动态算法可周期性地运行或直接响应拓扑或链路开销的变化而运行。虽然动态算法易于对网络的变化做出反应，但也更容易<strong>受诸如路由选择循环、路由振荡之类问题的影响</strong>。</p>
<br>

<blockquote>
<p><font color='red'><strong>补充</strong></font></p>
<p>路由选择算法的第三种分类方式是<strong>根据它是负载敏感的还是负载迟钝</strong>的进行划分。在负载敏感算法（load-sensitive algorithm)中，链路开销会动态地变化以反映出底层链路的当前拥塞水平。如果当前拥塞的一条链路与高开销相联系，则路由选择算法趋向于绕开该拥塞链路来选择路由。而早期的ARPA net路由选择算法就是负载敏感的,所以遇到了许多难题。当今的因特网路由选择算法（如RIP、OSPF和BGP)都是负载迟钝的（load-insensitive),因为某条链路的开销不明确地反映其当前（或最近）的拥塞水平。</p>
</blockquote>
<h5 id="链路状态选择算法-Link-State"><a href="#链路状态选择算法-Link-State" class="headerlink" title="链路状态选择算法 - Link State"></a>链路状态选择算法 - Link State</h5><p>前面讲过，在链路状态算法中，网络拓扑和所有的链路开销都是已知的，也就是说可用作LS算法的输入。实践中这是通过让每个节点向网络中所有其他节点广播链路状态分组来完成的，其中每个链路状态分组包含它所连接的链路的标识和开销。在实践中（例如使用因特网的OSPF路由选择协议，讨论见5.3节）,这经常由链路状态广播（link statebroadcast)算法[Perlman 1999]来完成。节点广播的结果是所有节点都具有该网络的统一、完整的视图。于是每个节点都能够像其他节点一样，运行LS算法并计算出相同的最低开销路径集合。</p>
<p>给出的算法是 <strong>Dijkstra 算法</strong></p>
<p>它计算从某节点（源节点，我们称之为u)到网络中所有其他节点的最低开销路径。Dijkstra算法是迭代算法，其性质是经算法的第k 次迭代后，可知道到k个目的节点的最低开销路径，在到所有目的节点的最低开销路径之中，这k条路径具有k个最低开销。</p>
<h6 id="LS-路由的工作过程"><a href="#LS-路由的工作过程" class="headerlink" title="LS 路由的工作过程"></a>LS 路由的工作过程</h6><ul>
<li>配置 <strong>LS 路由选择算法</strong> 的路由工作过程 <ul>
<li>各点通过各种渠道获得  <strong>整个网络拓扑</strong>，网络中所有链路 <strong>代价</strong> 等信息（这部分和算法没有关系，属于协议和实现）</li>
<li>使用 <strong>LS 路由算法</strong>，计算本站点到其他站点的 最优路径（汇集树），得到路由表</li>
<li>按照 此路由表转发分组 （datagram 方式）<ul>
<li>严格意义上说不是一个路由的 一个步骤</li>
<li>分发到输入端口的网络层</li>
</ul>
</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516213759067.png"
                      alt="image-20230516213759067" style="zoom:50%;" 
                >

<ul>
<li><p>LS 路由的基本工作过程</p>
<ol>
<li><p>发现相邻节点，获知对方网络地址</p>
<ul>
<li><p>一个路由器上电之后，向所有线路发送 HELLO 分组</p>
</li>
<li><p>其他路由器 收到 HELLO 分组，回送 响应，在应答分组中，告知自己的名字（全局唯一）</p>
</li>
<li><p>在 LAN 中，通过广播 HELLO 分组，获得其他路由器的信息，可以认为 引入一个人工节点</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516214457637.png"
                      alt="image-20230516214457637" style="zoom:50%;" 
                ></li>
</ul>
</li>
<li><p>测量到相邻节点的代价</p>
<ul>
<li>实测法，发送一个分组要求对方立即响应</li>
<li>回送一个 ECHO 分组</li>
<li>通过测量时间可以估算出 延迟情况</li>
</ul>
</li>
<li><p>组装一个  LS 分组，描述它到相邻节点的代价情况</p>
<ul>
<li><p>发送者名称 </p>
</li>
<li><p>序号、年龄</p>
</li>
<li><p>列表：给出他相邻节点，和它到相邻节点的 延迟</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516223659117.png"
                      alt="image-20230516223659117" style="zoom: 80%;" 
                ></li>
</ul>
</li>
<li><p>将分组通过 扩散的方法 发到所有其他路由器</p>
<ul>
<li><p>顺序号：用于控制无穷的 扩散，每个路由器都记录（源路由器，顺序号），发现重复的或老的就不扩散</p>
<ul>
<li>q1:循环使用问题</li>
<li>路由器崩溃之后序号从 0 开始</li>
<li>序号出现错误</li>
</ul>
</li>
<li><p>解决的办法：年龄字段（age）</p>
<ul>
<li>生成一个分组时，年龄字段不为0</li>
<li>每个一个 时间段，age 字段减一</li>
<li>age  字段为 0  的分组将被 抛弃</li>
</ul>
</li>
<li><p>关于扩散分组的 数据结构</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516224313551.png"
                      alt="image-20230516224313551" style="zoom: 67%;" 
                ></li>
</ul>
<p>以上 4 步 让每个路由器获得 <font color='red'><strong>拓扑和边代价</strong></font></p>
</li>
<li><p>通过 Dijkstra 算法 找出最短路径（这才是 路由算法）</p>
<ol>
<li><p>每个节点独立算出来到其他节点（路由器&#x3D;网络）的最短路径</p>
<ul>
<li>路由器获得各站点  LS 分组和整个网络的拓扑</li>
<li>通过 Dijkstra 算法 计算出到其他各路由器的最短路径（汇集树）</li>
<li>将计算结果安装到 路由表中</li>
</ul>
</li>
<li><p>迭代算法： 第 K 步 能够知道本节点到 K  个其他节点的最短路径</p>
</li>
<li><p>OSPF 协议是一种 LS 协议，被用于 Internet 上</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>符号标记</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516224712969.png"
                      alt="image-20230516224712969" style="zoom:80%;" 
                >
</li>
<li><p>LS 路由选择算法的工作原理</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516224739356.png"
                      alt="image-20230516224739356" style="zoom:80%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516224807197.png"
                      alt="image-20230516224807197" style="zoom:80%;" 
                ></li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516224825913.png"
                      alt="image-20230516224825913" style="zoom:80%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516224854760.png"
                      alt="image-20230516224854760" style="zoom: 67%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516224911501.png"
                      alt="image-20230516224911501" style="zoom: 67%;" 
                ></p>
<h5 id="距离矢量算法-Distance-vector"><a href="#距离矢量算法-Distance-vector" class="headerlink" title="距离矢量算法 - Distance vector"></a>距离矢量算法 - Distance vector</h5><p>距离矢量路由选择算法是一种基于距离估计的算法。在距离矢量路由选择中，每个路由器会维护到其它路由器的距离估计，并将其距离向相邻的路由器发送。然后，路由器根据接收到的距离信息和自身的距离估计更新路由表。距离矢量路由选择算法的缺点是收敛速度慢，容易出现路由环路。</p>
<ul>
<li><p>动态算法之一</p>
</li>
<li><p>DV 算法历史以及应用情况</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516230115211.png"
                      alt="image-20230516230115211" style="zoom:67%;" 
                >
</li>
<li><p>DV 的 基本思想</p>
<ul>
<li><p>各路由器维护一张路由表，结构如图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516230202340.png"
                      alt="image-20230516230202340"
                ></p>
</li>
<li><p>各路由器与相邻路由器交换路由表（持续）</p>
</li>
<li><p>根据获得的路由信息，更新路由表（持续）</p>
</li>
</ul>
</li>
<li><p>代价以及相邻节点代价的获得</p>
<ul>
<li>跳数（hops),延迟（delay），队列长度</li>
<li>相邻节点间代价的获得：通过实测</li>
</ul>
</li>
<li><p>路由信息的 更新</p>
<ul>
<li>根据实测 得到本节点A到相邻站点的代价（如：延迟）</li>
<li>根据各相邻站点声称它们到目标站点B的代价</li>
<li>计算出本站点A经过各相邻站点到目标站点B的代价</li>
<li><strong>找到一个最小的代价，和相应的下一个节点Z,到达节点B经过此节点Z,并且代价为A-Z-B的代价</strong></li>
<li>其它所有的目标节点一个计算法</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516230718248.png"
                      alt="image-20230516230718248" style="zoom:50%;" 
                >



<p>距离矢量（Distance-Vector,DV)算法是一种<strong>迭代的、异步的和分布式</strong>的算法，而LS算法是一种使用全局信息的算法。说它是分布式的，是因为<strong>每个节点都要从一个或多个直接相连邻居接收某些信息，执行计算，然后将其计算结果分发给邻居</strong>。说它是迭代的，是因为<strong>此过程一直要持续到邻居之间   <u>无更多信息要交换为止</u></strong>。（有趣的是，此算法是自我终止的，即没有计算应该停止的信号，它就停止了。）说它是异步的，是因为它<strong>不要求所有节点相互之间步伐一致地操作</strong>。我们将看到一个异步的、迭代的、自我终止的、分布式的算法比一个集中式的算法要有趣得多！</p>
<p>在给出 <code>DV</code> 算法之前，有必要讨论一下存在于最低开销路径的开销之间的一种重要关系。令d(y)是从节点x到节点y的最低开销路径的开销。则该最低开销与著名的Bellman-Ford 方程相关，即</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516225329130.png"
                      alt="image-20230516225329130"
                ></p>
<p>在该分布式、异步算法中，<strong>每个节点  <u>不时地</u>  向它的每个邻居发送它的距离向量副本</strong>。当节点x从它的任何一个邻居，接收到一个新距离向量，它保存v的距离向量，然后使用Bellman-Ford方程  <strong>更新</strong>  它自己的距离向量如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516225500624.png"
                      alt="image-20230516225500624"
                ></p>
<p>如果节点x的距离向量因这个更新步骤而改变，节点x接下来将向它的每个邻居发送其更新后的距离向量，这继而让所有邻居更新它们自己的距离向量。令人惊奇的是，只要所有的节点继续以异步方式交换它们的距离向量，每个开销估计<code>D(y)</code>收敛到<code>dx(y)</code>,<code>d(y)</code>为从节点x到节点y的实际最低开销路径的开销!</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516225912632.png"
                      alt="image-20230516225912632" style="zoom:50%;" 
                >

<p>实际上节点具有的唯一信息是它到直接相连邻居的链路开销和它从这些邻居接收到的信息。每个节点等待来自任何邻居的更新（第10-11行）,当接收到一个更新时计算它的新距离向量(第14行）并向它的邻居分布其新距离向量（第16-17行）</p>
<p>从邻居接收更新距离向量、重新计算路由选择表项和通知邻居到目的地的最低开销路径的开销已经变化的过程继续下去，直到无更新报文发送为止。在这个时候，因为无更新报文发送，将不会出现进一步的路由选择表计算，该算法将进入静止状态，即所有的节点将执行DV算法的第10~11行中的等待。该算法停留在静止状态，直到一条链路开销发生改变，如下面所讨论的那样。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516230736482.png"
                      alt="image-20230516230736482" style="zoom:80%;" 
                >

<br>

<p><font color='red'><strong>Bellman-Ford 方程（动态规划）</strong></font></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516231323869.png"
                      alt="image-20230516231323869" style="zoom:80%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516231351120.png"
                      alt="image-20230516231351120" style="zoom:80%;" 
                ></p>
<p>那个能够达到 目标   z 最小代价的节点 x ，就在到目标节点的 下一条路径上，在转发表中使用</p>
<br>

<h6 id="距离矢量算法"><a href="#距离矢量算法" class="headerlink" title="距离矢量算法"></a>距离矢量算法</h6><p><font color='red'><strong>核心思路</strong></font></p>
<ul>
<li><p>每个节点都将自己的距离矢量估计值传送给邻居，定时或者 DV 有变化时，让对方去算</p>
</li>
<li><p>当 X 从邻居收到 DV 时，自己运算，更新他的最大距离矢量</p>
<ul>
<li><p>采用 <strong>Bellmen-Ford equation</strong> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516231808876.png"
                      alt="image-20230516231808876" style="zoom:80%;" 
                ></li>
</ul>
</li>
<li><p>D<del>x</del>(Y) 估计值最终收敛于实际的最小代价值 d<del>x</del>（y）</p>
<ul>
<li>分布式、迭代算法</li>
</ul>
</li>
</ul>
<br>

<p><font color='red'><strong>异步式、迭代</strong></font>：每次本地迭代被以下事件触发</p>
<ul>
<li>每个节点只是在自己的 DV 改变之后向邻居通告<ul>
<li>然后他们的邻居在有必要的时候通知他们的邻居</li>
</ul>
</li>
</ul>
<br>

<p><font color='red'><strong>每个节点</strong></font>：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230516232131923.png"
                      alt="image-20230516232131923" style="zoom:80%;" 
                >



<h6 id="DV-的无穷计算问题"><a href="#DV-的无穷计算问题" class="headerlink" title="DV 的无穷计算问题"></a>DV 的无穷计算问题</h6><ul>
<li><p>DV 的特点</p>
<ul>
<li>好消息传得快，坏消息传的慢</li>
</ul>
</li>
<li><p>好消息的传播 以每一个交换周期  前进一个路由器的速度进行</p>
<ul>
<li><p>好消息：某个路由器接入 或者 有更短的路径</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517140816607.png"
                      alt="image-20230517140816607" style="zoom:50%;" 
                ></li>
</ul>
</li>
<li><p>坏消息传播的 非常慢（无穷计算问题）</p>
<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517140910176.png"
                      alt="image-20230517140910176" style="zoom:50%;" 
                ></li>
</ul>
</li>
</ul>
<h6 id="水平分裂（split-horizon）算法"><a href="#水平分裂（split-horizon）算法" class="headerlink" title="水平分裂（split horizon）算法"></a>水平分裂（split horizon）算法</h6><p>Split horizon算法是一种防止路由环路的技术，常用于距离矢量路由协议中。其主要思想是防止一个路由器将其从一个接口学习到的路由信息再次返回给该接口的源路由器，从而避免路由环路的发生。</p>
<p>具体来说，当一个路由器从一个接口学习到一条路由信息时，它会将该信息发送到其它的接口上，但不会将该信息发送回源路由器所在的接口。这样，当源路由器再次收到该信息时，它不会再将该信息发送回该路由器，从而避免了路由环路的发生。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517141222046.png"
                      alt="image-20230517141222046" style="zoom:50%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517141249008.png"
                      alt="image-20230517141249008" style="zoom:50%;" 
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517141331325.png"
                      alt="image-20230517141331325" style="zoom:33%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517141354277.png"
                      alt="image-20230517141354277" style="zoom:25%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517141424404.png"
                      alt="image-20230517141424404" style="zoom:33%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517141445220.png"
                      alt="image-20230517141445220" style="zoom:33%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517141530341.png"
                      alt="image-20230517141530341" style="zoom:33%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517141939425.png"
                      alt="image-20230517141939425" style="zoom:33%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517142006764.png"
                      alt="image-20230517142006764" style="zoom:33%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517142057541.png"
                      alt="image-20230517142057541" style="zoom:33%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517142124086.png"
                      alt="image-20230517142124086" style="zoom:33%;" 
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517142146187.png"
                      alt="image-20230517142146187" style="zoom:67%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517142206025.png"
                      alt="image-20230517142206025" style="zoom:67%;" 
                ></p>
<p>Split horizon算法通常与距离矢量路由协议中的毒性反转技术（poison reverse）一起使用。在毒性反转技术中，一个路由器将其从某个接口学习到的路由信息发送回该接口时，会将该路由信息的距离值设为无穷大，从而告诉源路由器该路由已经失效。</p>
<p>总的来说，Split horizon算法是一种简单有效的防止路由环路的技术，常用于距离矢量路由协议中。</p>
<h5 id="LS-和-DV-算法的比较"><a href="#LS-和-DV-算法的比较" class="headerlink" title="LS 和 DV 算法的比较"></a>LS 和 DV 算法的比较</h5><p><font color='red'><strong>消息复杂度（DV胜出）</strong></font></p>
<ul>
<li>LS ：有 N个 节点和 E 条链路，发送报文 O(NE) 个<ul>
<li>局部的路由信息，全局传播</li>
</ul>
</li>
<li>DV： 只和邻居  交换信息<ul>
<li>全局的路由信息，局部传播</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>收敛时间（LS 胜出）</strong></font></p>
<ul>
<li>LS: O(n2) 算法<ul>
<li>有可能震荡</li>
</ul>
</li>
<li>DV： 收敛较慢<ul>
<li>有可能存在路由环路</li>
<li>count - to - infinity  问题</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>健壮性</strong></font>：路由器故障会发生什么？（LS 胜出）</p>
<ul>
<li>LS<ul>
<li>节点会通告 不正确的链路代价</li>
<li>每个节点只计算自己的路由表</li>
<li>错误信息影响较小，局部，路由较 健壮</li>
</ul>
</li>
<li>DV：<ul>
<li>DV 节点可能通告对全网所有节点的不正确路径代价<ul>
<li>距离矢量</li>
</ul>
</li>
<li>每一个节点的路由表 可能被其他节点使用<ul>
<li>错误节点可以扩散到全网</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="因特网中自治系统内部的路由选择"><a href="#因特网中自治系统内部的路由选择" class="headerlink" title="因特网中自治系统内部的路由选择"></a>因特网中自治系统内部的路由选择</h4><p>在我们至今为止的算法研究中，我们将网络只看作一个互联路由器的集合。从所有路由器执行相同的路由选择算法以计算穿越整个网络的路由选择路径的意义上来说，一台路由器很难同另一台路由器区别开来。在实践中，该模型和这种一组执行同样路由选择算法的同质路由器集合的观点有一点简单化，有以下两个重要原因：</p>
<ul>
<li>规模。随着路由器数目变得很大，涉及路由选择信息的通信、计算和存储的开销将高得不可实现。当今的因特网由数亿台主机组成。在这些主机中存储的路由选择信息显然需要巨大容量的内存。在所有路由器之间广播连通性和链路开销更新所要求的负担将是巨大的！在如此大量的路由器中迭代的距离向量算法将肯定永远无法收敛！显然，必须采取一些措施以减少像因特网这种大型网络中的路由计算的复杂性。</li>
<li>管理自治。因特网是ISP的网络，其中每个ISP都有它自己的路由器网络。ISP通常希望按自己的意愿运行路由器（如在自己的网络中运行它所选择的某种路由选择算法）,或对外部隐藏其网络的内部组织面貌。在理想情况下，一个组织应当能够按自己的愿望运行和管理其网络，还要能将其网络与其他外部网络连接起来。</li>
</ul>
<p>这两个问题都可以通过将路由器组织进**自治系统（Autonomous System,AS)**来解决其中每个AS由一组通常处在相同管理控制下的路由器组成。通常在一个ISP中的路由器以及互联它们的链路构成一个AS。然而，某些ISP将它们的网络划分为多个AS。特别是某些一级ISP在其整个网络中使用一个庞大的AS,而其他ISP则将它们的ISP拆分为数十个互联的AS。一个自治系统由其全局唯一的AS号（ASN)所标识。就像IP地址那样，AS号由ICANN区域注册机构所分配。</p>
<p>在相同AS中的路由器都运行相同的路由选择算法并且有彼此的信息。在一个自治系统内运行的路由选择算法叫作<strong>自治系统内部路由选择协议（intra-autonomous system routing protocol)。</strong></p>
<h5 id="RIP（Routing-Information-Protocol）"><a href="#RIP（Routing-Information-Protocol）" class="headerlink" title="RIP（Routing Information Protocol）"></a>RIP（Routing Information Protocol）</h5><ul>
<li>在 1982 年发布的 BSD-UNIX 中实现</li>
<li>Distance Vector 算法<ul>
<li>距离矢量：每条链路 <code>cost = 1</code> ,<code># of hops (max = 15 hops)</code> 跳数</li>
<li>DV 每隔30 s 和邻居交换 DV，<font color='red'><strong>通告</strong></font></li>
<li>每个通告包括：最多 25 个目标<strong>子网</strong></li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517145544189.png"
                      alt="image-20230517145544189" style="zoom:67%;" 
                >



<h6 id="RIP-通告（advertisements）"><a href="#RIP-通告（advertisements）" class="headerlink" title="RIP 通告（advertisements）"></a>RIP 通告（advertisements）</h6><ul>
<li>DV ：在邻居之间每  30 s 交换通告报文<ul>
<li>定期，而且在改变路由的时候发送通告报文</li>
<li>在对方的请求下可以发送 通告报文</li>
</ul>
</li>
<li>每一个通告：至多 AS 内部的 25  个目标网络的 DV<ul>
<li>目标网络 +  跳数<ul>
<li>一次公告最多 25 个子网，最大跳数为 16 hop</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517145848153.png"
                      alt="image-20230517145848153" style="zoom:50%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517145904847.png"
                      alt="image-20230517145904847" style="zoom:50%;" 
                ></p>
<h6 id="RIP-：链路失效和恢复"><a href="#RIP-：链路失效和恢复" class="headerlink" title="RIP ：链路失效和恢复"></a>RIP ：链路失效和恢复</h6><p>如果 180 秒没有收到通告信息 –&gt;  邻居或者链路失效</p>
<ul>
<li><p>发现经过这个邻居的路由已经失效</p>
</li>
<li><p>新的通告报文会传递给邻居</p>
</li>
<li><p>邻居因此发出新的通告（如果路由有变化的话）</p>
</li>
<li><p>链路失效快速（？）地在链路传输</p>
</li>
<li><p>使用  <strong>毒性逆转</strong> （Poison reverse） 阻止 ping-pong 回路（不可达的距离：跳数无限 &#x3D; 16段）</p>
<ul>
<li><p>毒性逆转（poison reverse）是一种距离矢量路由协议中的技术，用于防止路由环路的发生。当一条链路或节点出现故障时，毒性逆转可以迅速告知其它节点该路由不可达，防止路由环路的产生。</p>
<p>具体来说，当一个路由器发现某个路由不可达时，它会将该路由的距离值设为无穷大（infinity），并将该路由信息向其它节点发送。这样，其它节点就会知道该路由不可达，并将其从其路由表中删除。如果没有使用毒性逆转，那么该路由信息会一直存在于网络中，可能会导致路由环路的产生。</p>
<p>毒性逆转通常与Split horizon算法一起使用，Split horizon算法可以防止一个节点将其从一个接口学习到的路由信息再次返回给该接口的源路由器，从而避免路由环路的发生。</p>
<p>总的来说，毒性逆转是一种距离矢量路由协议中的技术，可以迅速告知其它节点某个路由不可达，防止路由环路的产生。它通常与Split horizon算法一起使用，可以提高路由选择协议的稳定性和可靠性。</p>
</li>
</ul>
</li>
</ul>
<h6 id="RIP-进程处理"><a href="#RIP-进程处理" class="headerlink" title="RIP 进程处理"></a>RIP 进程处理</h6><ul>
<li>RIP 以应用进程的方式实现：route-d(daemon)</li>
<li>通告报文 通过 UDP 报文传送，周期性重复</li>
<li>网络层的协议使用了传输层的服务，以应用层实体的方式实现</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517150846309.png"
                      alt="image-20230517150846309" style="zoom:50%;" 
                >



<h5 id="OSPF（Open-Shortest-Path-First"><a href="#OSPF（Open-Shortest-Path-First" class="headerlink" title="OSPF（Open Shortest Path First)"></a>OSPF（Open Shortest Path First)</h5><p>OSPF（Open Shortest Path First）是一种链路状态路由选择协议，用于在大型企业网络和互联网中进行路由选择。OSPF协议适用于IPv4和IPv6网络。</p>
<p>OSPF协议使用链路状态算法来选择最佳路径，即将网络中的所有链路和路由器的状态信息发送给相邻的路由器，然后计算最短路径并更新路由表。OSPF协议使用路由器ID来标识每个路由器，每个路由器维护一个链路状态数据库（LSDB），其中包含了网络中所有链路和路由器的状态信息。</p>
<p>OSPF协议的主要特点包括：</p>
<ol>
<li><p>高效：OSPF协议使用链路状态算法，可以快速计算最短路径，并快速适应网络拓扑的变化。</p>
</li>
<li><p>灵活：OSPF协议支持可变长度子网掩码（VLSM），可以处理不同子网掩码的网络。</p>
</li>
<li><p>可靠：OSPF协议使用可靠的邻居关系协议（Neighbor Protocol），可以确保邻居关系的稳定性和可靠性。</p>
</li>
<li><p>安全：OSPF协议支持认证机制，可以对路由器进行身份认证和数据加密，提高网络的安全性。</p>
</li>
</ol>
<p>总的来说，OSPF协议是一种高效、灵活、可靠和安全的路由选择协议，适用于大型企业网络和互联网。OSPF协议的实现相对复杂，需要一定的配置和管理，但可以提供更高级别的路由选择功能和更好的网络性能。</p>
<ul>
<li><p>“open” ：标准可公开获得</p>
</li>
<li><p>使用 LS算法</p>
<ul>
<li>LS 分组在网络中 （一个 AS 内部）分发</li>
<li>全局网络拓扑、代价在每一个 节点中都保持</li>
<li>路由计算使用 Dijkstra  算法</li>
</ul>
</li>
<li><p>OSPF 通告信息中携带：每一个路由器一个表项</p>
</li>
<li><p>通告信息会传遍 AS 全部（通过泛洪）</p>
<ul>
<li>在 IP 数据报上直接传送 OSPF 报文（而不是通过 TCP、UDP）</li>
</ul>
</li>
<li><p><font color='red'>IS-IS 路由协议</font>：几乎和 OSPF 一样</p>
<ul>
<li><p>IS-IS（Intermediate System to Intermediate System）是一种内部网关协议（IGP），用于在中等规模的企业网络和互联网中进行路由选择。IS-IS协议适用于IPv4和IPv6网络。</p>
<p>IS-IS协议使用链路状态算法来选择最短路径，即将网络中的所有链路和路由器的状态信息发送给相邻的路由器，然后计算最短路径并更新路由表。IS-IS协议使用系统ID来标识每个路由器，每个路由器维护一个链路状态数据库（LSDB），其中包含了网络中所有链路和路由器的状态信息。</p>
<p>IS-IS协议的主要特点包括：</p>
<ol>
<li><p>高效：IS-IS协议使用链路状态算法，可以快速计算最短路径，并快速适应网络拓扑的变化。</p>
</li>
<li><p>灵活：IS-IS协议支持可变长度子网掩码（VLSM），可以处理不同子网掩码的网络。</p>
</li>
<li><p>可靠：IS-IS协议使用可靠的邻居关系协议（Neighbor Protocol），可以确保邻居关系的稳定性和可靠性。</p>
</li>
<li><p>安全：IS-IS协议支持认证机制，可以对路由器进行身份认证和数据加密，提高网络的安全性。</p>
</li>
</ol>
<p>总的来说，IS-IS协议是一种高效、灵活、可靠和安全的路由选择协议，适用于中等规模的企业网络和互联网。IS-IS协议的实现相对复杂，需要一定的配置和管理，但可以提供更高级别的路由选择功能和更好的网络性能。</p>
</li>
</ul>
</li>
</ul>
<h6 id="OSPF-高级特性"><a href="#OSPF-高级特性" class="headerlink" title="OSPF 高级特性"></a>OSPF 高级特性</h6><ul>
<li><p><font color='red'><strong>安全：</strong></font>所有的 OSPF 报文都是经过认证的（防止恶意的攻击）</p>
</li>
<li><p>允许 有 <strong>多个代价相同的</strong> 路径存在（在 RIP 中只有一个）</p>
</li>
<li><p>对于每一个链路，对于不同的 TOS 有 <strong>多重代价矩阵</strong></p>
<ul>
<li><p>在计算机网络中，链路的代价指的是传输数据的开销，通常表示为距离、带宽、延迟等。当网络中存在多个链路时，每个链路的代价可能不同，因此需要为每个链路定义一个代价矩阵来表示不同类型的代价。</p>
<p>在某些网络中，不同类型的数据流（如语音、视频、数据等）可能需要优先考虑不同的代价因素。为了满足这种需求，网络协议可以为每种类型的流量定义不同的代价矩阵，称为多重代价矩阵（Multiple Cost Matrix）。</p>
<p>以OSPF协议为例，OSPF协议为每个链路定义了一个代价值，用于计算最短路径。在OSPF中，每个链路还可以为不同类型的服务定义不同的代价值，称为TOS（Type of Service）代价。例如，语音数据可能需要优先考虑传输延迟，而数据传输可能更注重带宽。因此，OSPF协议可以为每个链路定义多个TOS代价，用于计算不同类型的数据流的最短路径。</p>
<p>总的来说，多重代价矩阵是用于在网络中为不同类型的数据流设置不同的代价值，以便计算不同类型数据流的最短路径。这种技术可以提高网络的性能和服务质量，并满足不同类型数据流的需求。</p>
</li>
</ul>
</li>
<li><p>对 单播和多播的 集成支持</p>
<ul>
<li>Multicast OSPF（MOSPF） 使用相同的 拓扑数据库，就像在 OSPF 中一样</li>
</ul>
</li>
<li><p>在 大型网络中 支持  <strong>层次性</strong> OSPF</p>
<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517152517388.png"
                      alt="image-20230517152517388" style="zoom:50%;" 
                ></li>
<li><font color='red'>两个级别的层次性：</font>本地、骨干<ul>
<li>链路状态通告 仅仅在 本地区域 Area  范围内进行</li>
<li>每一个节点拥有本地 区域的拓扑信息<ul>
<li>关于其他区域，知道去他的方向，通过区域边界路由器（最短路径）</li>
</ul>
</li>
</ul>
</li>
<li><font color='red'><strong>区域边界路由器</strong></font>：”汇集“ 到自己区域内 网络的距离，向其他区域边界路由器通告</li>
<li><font color='red'><strong>骨干路由器</strong></font>：仅仅在骨干区域内，运行 OSPF 路由</li>
<li><font color='red'><strong>边界路由器</strong></font>：连接其他 AS</li>
</ul>
</li>
</ul>
<h4 id="ISP-之间的路由选择：BGP"><a href="#ISP-之间的路由选择：BGP" class="headerlink" title="ISP 之间的路由选择：BGP"></a>ISP 之间的路由选择：BGP</h4><h5 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h5><ul>
<li>一个平面的路由<ul>
<li>一个网络中的所有路由器的地位都一样</li>
<li>通过 LS、DV，或者其他的路由算法，所有的路由器都知道其他所有路由器（子网）应该怎么走</li>
<li>所有路由器在一个平面</li>
</ul>
</li>
<li>平面路由的问题<ul>
<li><strong>规模</strong> 巨大的网络中，路由信息的存储、传输和计算代价过大<ul>
<li>DV：距离矢量很大，且不能够收敛</li>
<li>LS：几百万个节点的 LS 分组的泛洪传输，存储以及最短路径的计算问题</li>
</ul>
</li>
<li><strong>管理问题</strong>：<ul>
<li>不同的网络所有者希望按照自己的方式管理网络</li>
<li>希望对外隐藏自己网络的细节</li>
<li>当然，还希望和其他网络互联</li>
</ul>
</li>
</ul>
</li>
<li>层次路由：将互联网分成一个个 AS（路由器区域）<ul>
<li>某个区域内的路由器集合，自治系统   </li>
<li>一个 AS 用AS Number 唯一标识 （ASN）</li>
<li>一个 ISP 可能包括一个 或者 多个 AS</li>
</ul>
</li>
<li>路由 变成了：2 个 层次路由<ul>
<li><strong>AS内部路由</strong> ：在同一个 AS 内部路由器运行相同的路由协议<ul>
<li><font color='red'>**“intra-AS” routing protocol **</font>:内部网关协议</li>
<li>不同的AS 可能运行着不同内部网关的协议</li>
<li>能够解决规模和管理问题</li>
<li><font color='red'>网关路由器：</font>AS 边缘路由器，可以连接到其他的 AS</li>
</ul>
</li>
<li>AS 之间运行 <strong>AS间路由协议</strong><ul>
<li><fonert color='red'>**“int-AS” routing protocol **</font>:外部网关协议</li>
<li>解决 AS 之间的路由问题，完成 AS 之间的互联互通</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="层次路由的优点"><a href="#层次路由的优点" class="headerlink" title="层次路由的优点"></a>层次路由的优点</h6><ul>
<li>解决了规模问题<ul>
<li>内部网关协议解决：AS 内部 数量有限的 路由器相互到达的问题，AS 内部规模可控</li>
</ul>
</li>
<li>AS 之间路由的规模问题<ul>
<li>增加一个 AS，对于 AS 之间的路由从 总体上来说，只是增加了一个节点 &#x3D; 子网（每个AS 可以用一个点来表示）</li>
<li>对于其他的AS来说只是增加了一个 表项，就是这个新增的AS 如何走的问题</li>
<li>扩展性强：规模增大，性能不会减得太多</li>
</ul>
</li>
<li>解决了管理问题<ul>
<li>各个 AS 之间可以运行不同的 内部网关协议</li>
<li>可以使自己的网络不向外部暴露细节</li>
</ul>
</li>
</ul>
<h5 id="互联网AS间路由：BGP"><a href="#互联网AS间路由：BGP" class="headerlink" title="互联网AS间路由：BGP"></a>互联网AS间路由：BGP</h5><p>是一种互联网路由协议，用于在不同自治系统之间进行路由选择。BGP协议主要用于大规模企业网络、运营商网络以及互联网服务提供商（ISP）之间的路由选择。</p>
<p>BGP协议的主要作用是将路由信息从一个自治系统（AS）传递到另一个自治系统，以便实现全球互联网的路由选择。BGP协议使用TCP协议进行通信，并支持多种路由策略，如路由过滤、路由聚合、路由重分发等。</p>
<ul>
<li><font color='red'><strong>BGP（Border Gateway Protocol）</strong></font> ：自治区域路由协议  “事实上的标准”<ul>
<li>“将互联网各个 AS <strong>粘在一起</strong>  的胶水”</li>
</ul>
</li>
<li><strong>BGP</strong> 提供给每个 AS  以下方法<ul>
<li><font color='red'><strong>eBGP</strong></font>: 从相邻的ASes 那里获得子网可达信息</li>
<li><font color='red'><strong>iBGP</strong></font>:将 获得的子网可达信息传遍 AS内部的所有路由器</li>
<li>根据子网可达信息和 <font color='cornflowerblue'><strong>策略</strong></font> 来决定到达子网的 “好路径”</li>
</ul>
</li>
<li>允许子网向互联网其他网络通告 “<strong>我在这里</strong>”</li>
<li>基于 DV 算法<ul>
<li>不仅仅是DV，还包括到达各个目标网络的详细路径（AS序号的列表）能够避免 DV 的路由环路问题</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517160437842.png"
                      alt="image-20230517160437842" style="zoom:50%;" 
                >

<br>

<p>BGP协议的工作原理如下：</p>
<ol>
<li><p>BGP协议通过向对等的BGP路由器发送UPDATE消息来传递路由信息。</p>
</li>
<li><p>UPDATE消息包括路由的网络地址、AS号码和其他属性信息。</p>
</li>
<li><p>BGP路由器使用路由策略选择最优的路由，并将其添加到自己的路由表中。</p>
</li>
<li><p>如果路由器发现某个路由不再可达，它将从自己的路由表中删除该路由，并向其它BGP路由器发送WITHDRAW消息。</p>
</li>
</ol>
<p>BGP协议的主要特点包括：</p>
<ol>
<li><p>支持多种路由策略，如路由过滤、路由聚合、AS路径选择等。</p>
</li>
<li><p>可以跨越多个自治系统进行路由选择，支持互联网规模的路由选择。</p>
</li>
<li><p>支持路由决策的可扩展性和灵活性。</p>
</li>
<li><p>支持路由信息的安全性和稳定性，如路由过滤、MD5认证等。</p>
</li>
</ol>
<p>总的来说，BGP协议是一种用于在不同自治系统之间进行路由选择的协议，是实现全球互联网的重要技术之一。BGP协议具有高度的可扩展性和灵活性，但实现和管理比较复杂，需要一定的网络知识和经验。</p>
<h6 id="BGP-基础"><a href="#BGP-基础" class="headerlink" title="BGP 基础"></a>BGP 基础</h6><ul>
<li><font color='red'><strong>BGP 会话</strong></font>：两个BGP 路由器（“peers”）在一个半永久的TCP 连接上 交换 BGP 报文<ul>
<li>通告向不同目标子网前缀的 “路径” （BGP 是一个 DV 协议）</li>
</ul>
</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517161756832.png"
                      alt="image-20230517161756832" style="zoom:50%;" 
                ></li>
</ul>
<h6 id="路径的属性-BGP-路由"><a href="#路径的属性-BGP-路由" class="headerlink" title="路径的属性 &amp; BGP 路由"></a>路径的属性 &amp; BGP 路由</h6><ul>
<li>当通告一个子网前缀时，通告包括 BGP 属性<ul>
<li><code>prefix + attributes = &quot;route&quot;</code></li>
</ul>
</li>
<li>两个重要的属性<ul>
<li><font color='red'>**AS - PATH **</font>: 前缀通告所经过的 AS 列表：AS 67 AS 17<ul>
<li>检测环路：多路径选择</li>
<li>在向其他 AS 转发时，需要将自己的 ASN 加在路径上面</li>
</ul>
</li>
<li><font color='red'><strong>NEXT-HOP</strong></font>：从 当前AS 到下一跳AS 有多个链路，在 next-hop 属性中，告诉对方通过那个 I 转发</li>
<li>其他属性：路由偏好指标，如何被插入的属性</li>
</ul>
</li>
<li>基于 <strong>策略</strong> 的路由<ul>
<li>当一个 <strong>网关路由器</strong> 接收到了一个路由通告，使用 <strong>输入策略</strong> 来接受或者 过滤（accept&#x2F; decline) <ul>
<li>reason1:不想经过某个 AS，转发某些前缀的 分组</li>
<li>reason2：已经有了通往某前缀路径的偏好路径</li>
</ul>
</li>
<li>策略也决定了是否向他的邻居通告收到的这个信息</li>
</ul>
</li>
</ul>
<h6 id="BGP-路径通告"><a href="#BGP-路径通告" class="headerlink" title="BGP 路径通告"></a>BGP 路径通告</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517162805716.png"
                      alt="image-20230517162805716" style="zoom:50%;" 
                >

<ul>
<li>路由器AS2.2c从AS3.3a接收到的AS3,X路由通告（通过eBGP)</li>
<li>基于AS2的输入策略，AS2.2c决定接收AS3,X的通告，而且通过iBGP)向AS2的所有路由器进行通告</li>
<li>基于AS2的策略，AS2路由器2a通过eBGP向ASI.lc路由器通告AS2,AS3,X 路由信息<ul>
<li>路径上加上了AS2自己作为AS序列的一跳</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517163425167.png"
                      alt="image-20230517163425167" style="zoom:80%;" 
                >

<p>网关路由器可能获取有关一个子网X的多条路径，从多个eBGP会话上：</p>
<ul>
<li>AS1网关路由器1c从2a学习到路径：AS2,AS3,X</li>
<li>AS1网关路由器1c从3a处学习到路径AS3,X</li>
<li>基于策略，AS1路由器1c选择了路径：<strong>AS3,X,而且通过iBGP告诉所有AS1内部的路由器</strong></li>
</ul>
<h6 id="BGP-报文"><a href="#BGP-报文" class="headerlink" title="BGP 报文"></a>BGP 报文</h6><ul>
<li>使用 TCP 协议交换 BGP 报文</li>
<li>BGP 报文<ul>
<li><strong>OPEN</strong>：打开TCP 连接，认证发送方</li>
<li><strong>UPDATE</strong>：通告新路径（或者撤销新路径）</li>
<li><strong>KEEPALIVE</strong>：在没有更新时保持连接，也用于对 OPEN 请求确认</li>
<li><strong>NOTIFICATION</strong>：报告以前消息的错误，也用来关闭连接</li>
</ul>
</li>
</ul>
<h6 id="BGP、OSPF-转发表表项"><a href="#BGP、OSPF-转发表表项" class="headerlink" title="BGP、OSPF 转发表表项"></a>BGP、OSPF 转发表表项</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517163748726.png"
                      alt="image-20230517163748726" style="zoom:67%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517163809633.png"
                      alt="image-20230517163809633" style="zoom:67%;" 
                ></p>
<h6 id="BGP-路径选择"><a href="#BGP-路径选择" class="headerlink" title="BGP 路径选择"></a>BGP 路径选择</h6><ul>
<li>路由器可能获得一个网络前缀的多个路径，路由器必须进行路径的选择，路由选择可以基于：<ul>
<li>本地偏好值属性：偏好策略决定</li>
<li>最短AS-PATH:AS的跳数</li>
<li>最近的NEXT-HOP路由器：热土豆路由</li>
<li>附加的判据：使用BGP标示</li>
</ul>
</li>
<li>一个前缀对应着多种路径，采用消除规则直到留下一条路径</li>
</ul>
<br>

<p><strong>热土豆策略</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517164317302.png"
                      alt="image-20230517164317302" style="zoom:67%;" 
                >

<p>2d通过iBGP获知，它可以通过2a或者2c到达X</p>
<p><strong>热土豆策略</strong>：选择具备最小内部区域代价的网关作为往X的出口（如：2d选择2a,即使往X可能有比较多的AS跳数）:<strong>不要操心域间的代价！</strong></p>
<p>热土豆策略（Hot Potato Routing）是一种网络路由策略，用于快速转发数据包到目标节点，以最小化网络延迟和传输时间。热土豆策略的基本思想是将数据包发送给最近的可用节点，以便快速到达目标节点。在热土豆策略中，每个节点都会评估到达目标节点的最短路径，并将数据包发送给最近的节点，而不是等待最佳路径。</p>
<p>热土豆策略的工作流程如下：</p>
<ol>
<li><p>当一个节点接收到一个数据包时，它会计算到达目标节点的最短路径，并将数据包发送给这条路径上最近的节点。</p>
</li>
<li><p>如果当前节点没有直接连接到目标节点的最短路径上，它会将数据包发送给距离目标节点最近的节点，并等待该节点将数据包转发给下一个最近的节点，直到数据包到达目标节点。</p>
</li>
<li><p>如果目标节点没有响应或不可达，数据包会被返回给发送方，或者被丢弃。</p>
</li>
</ol>
<p>热土豆策略的主要优点是快速传输数据包，从而降低网络延迟和传输时间。它还可以提高数据包的可靠性和稳定性，因为即使某个节点出现故障，数据包仍然可以通过其他路径到达目标节点。但是，热土豆策略也存在一些缺点，如可能导致网络拥塞和负载不均衡等问题。</p>
<p>总的来说，热土豆策略是一种网络路由策略，用于快速传输数据包到目标节点，可以提高网络性能和数据传输的可靠性。</p>
<h6 id="BGP-通过路径通告执行策略"><a href="#BGP-通过路径通告执行策略" class="headerlink" title="BGP 通过路径通告执行策略"></a>BGP 通过路径通告执行策略</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517164706273.png"
                      alt="image-20230517164706273" style="zoom:67%;" 
                >

<p>假设一个ISP只想路由流量到&#x2F;去往它的客户网络（不想承载其他ISPs之间的流量，即不通告：不是去往我的客户，也不是来自我的客户）</p>
<ul>
<li>A向B和C通告路径AW</li>
<li>B选择不向C通告BAw:<ul>
<li>B从CBAw的路由上无法获得收益，因为C,A,w都不是B的客户</li>
<li>C从而无法获知 CBAw路径的存在：每个ISP感知到的网络和真实不一致</li>
</ul>
</li>
<li>C可能会通过CAw(而不是使用B)最终路由到W</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517165048591.png"
                      alt="image-20230517165048591" style="zoom:67%;" 
                >



<h5 id="为什么内部网关协议和外部网关协议如此不同"><a href="#为什么内部网关协议和外部网关协议如此不同" class="headerlink" title="为什么内部网关协议和外部网关协议如此不同"></a>为什么内部网关协议和外部网关协议如此不同</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517165139055.png"
                      alt="image-20230517165139055" style="zoom:67%;" 
                >



<h4 id="SDN-1"><a href="#SDN-1" class="headerlink" title="SDN"></a>SDN</h4><p>数据平面已经叙述过，不再叙述</p>
<h4 id="ICMP：Internet-控制报文协议"><a href="#ICMP：Internet-控制报文协议" class="headerlink" title="ICMP：Internet 控制报文协议"></a>ICMP：Internet 控制报文协议</h4><p>ICMP（Internet Control Message Protocol）是一种网络协议，用于在互联网上发送错误和控制消息，以及测试网络的连通性和性能。ICMP协议通常与IP协议一起使用，用于处理网络层的错误和控制信息。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517165502567.png"
                      alt="image-20230517165502567" style="zoom:67%;" 
                >

<p>ICMP协议的主要作用包括：</p>
<ol>
<li><p>发送错误消息：当IP数据包在传输过程中出现错误时，ICMP会发送错误消息给源节点，以便重新发送数据包或采取其他措施。</p>
</li>
<li><p>发送控制消息：ICMP还可以发送控制消息，如请求和响应消息，用于测试网络的连通性和性能，如ping命令就是基于ICMP协议实现的。</p>
</li>
<li><p>实现路由选择：ICMP还可以用于路由选择，例如当路由器无法找到目标节点时，将发送ICMP重定向消息告诉源节点选择更优路径。</p>
</li>
</ol>
<p>ICMP协议的常见消息类型包括：</p>
<ol>
<li><p>回显请求和回显应答（Echo Request和Echo Reply）：用于测试网络的连通性和性能，如ping命令就是基于这种消息类型实现的。</p>
</li>
<li><p>目标不可达（Destination Unreachable）：用于告诉源节点目标节点不可达或不存在。</p>
</li>
<li><p>超时（Time Exceeded）：用于告诉源节点数据包在传输过程中已经超时或过期。</p>
</li>
<li><p>重定向（Redirect）：用于告诉源节点选择更优路径。</p>
</li>
</ol>
<p>总的来说，ICMP协议是一种用于在互联网上发送错误和控制消息的网络协议，可以用于测试网络的连通性和性能，以及实现路由选择等功能。在网络故障排除和网络性能测试中，ICMP协议是一个重要的工具和协议。</p>
<h5 id="Traceroute-and-ICMP"><a href="#Traceroute-and-ICMP" class="headerlink" title="Traceroute and ICMP"></a>Traceroute and ICMP</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517165614731.png"
                      alt="image-20230517165614731" style="zoom:67%;" 
                >

<p>Traceroute是一种网络诊断工具，用于检测数据包从源节点到目标节点所经过的路由路径，并测量每个节点的延迟时间。Traceroute通常基于ICMP协议实现，使用ICMP报文作为探测数据包。下面分别介绍Traceroute和ICMP的工作原理。</p>
<p>Traceroute的工作原理：</p>
<ol>
<li><p>在Traceroute开始时，它向目标节点发送第一个探测数据包，该数据包的TTL（Time-To-Live）值设置为1。</p>
</li>
<li><p>当第一个探测数据包到达第一个路由器时，TTL值变为0，该路由器会将ICMP超时消息返回给源节点。这个ICMP消息包含了第一个路由器的IP地址。</p>
</li>
<li><p>Traceroute收到第一个路由器的ICMP消息后，它将向目标节点发送第二个探测数据包，TTL值设置为2。</p>
</li>
<li><p>第二个探测数据包到达第二个路由器时，TTL值变为0，该路由器同样会将ICMP超时消息返回给源节点，包含了第二个路由器的IP地址。</p>
</li>
<li><p>Traceroute重复上述步骤，逐渐增加TTL值，直到到达目标节点，或者TTL值超过了一定的阈值，Traceroute将停止探测。</p>
</li>
<li><p>最终，Traceroute将显示所有经过的路由器的IP地址和延迟时间，以及到达目标节点的总延迟时间。</p>
</li>
</ol>
<p>ICMP的工作原理：</p>
<ol>
<li><p>ICMP协议通常与IP协议一起使用，在IP数据包传输过程中，当出现错误或控制信息时，ICMP会发送消息给源节点或其他网络节点。</p>
</li>
<li><p>ICMP消息通常包含类型码和代码字段，用于指示消息类型和具体信息。例如，Echo Request和Echo Reply是ICMP的一种类型，用于测试网络的连通性和性能。</p>
</li>
<li><p>ICMP还可以用于路由选择，例如当路由器无法找到目标节点时，将发送ICMP重定向消息告诉源节点选择更优路径。</p>
</li>
</ol>
<p>总的来说，Traceroute是一种基于ICMP协议实现的网络诊断工具，用于检测数据包从源节点到目标节点所经过的路由路径，并测量每个节点的延迟时间。ICMP协议是一种用于在互联网上发送错误和控制消息的网络协议，可以用于发送探测数据包、路由选择等功能。在网络故障排除和网络性能测试中，Traceroute和ICMP协议是重要的工具和协议。</p>
<h4 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517165912469.png"
                      alt="image-20230517165912469" style="zoom:67%;" 
                >

<blockquote>
<p><strong>“网络管理”</strong></p>
<p>包括了硬件、软件和人类元素的设置，综合和协调，以便监测，测试，轮询，配置，分析，评价和控制网络和网元资源，用合理的成本满足实时性，运行能和服务质量的要求；</p>
</blockquote>
<h5 id="网络管理的-5-大功能"><a href="#网络管理的-5-大功能" class="headerlink" title="网络管理的 5 大功能"></a>网络管理的 5 大功能</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517170012924.png"
                      alt="image-20230517170012924" style="zoom:67%;" 
                >



<h5 id="网络管理架构"><a href="#网络管理架构" class="headerlink" title="网络管理架构"></a>网络管理架构</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517170102751.png"
                      alt="image-20230517170102751" style="zoom:67%;" 
                >



<h5 id="SNMP-协议"><a href="#SNMP-协议" class="headerlink" title="SNMP 协议"></a>SNMP 协议</h5><p>SNMP（Simple Network Management Protocol）是一种用于网络管理的协议，它提供了一套标准的方法，以便管理和监控网络设备和系统。SNMP协议通常用于网络设备的远程管理和监控，如路由器、交换机、服务器等。</p>
<p>SNMP协议的主要作用包括：</p>
<ol>
<li><p>监控网络设备和系统的状态：SNMP可以获取网络设备和系统的状态信息，如CPU利用率、内存使用率、网络流量等。</p>
</li>
<li><p>配置网络设备和系统：SNMP可以修改网络设备和系统的配置参数，如修改路由表、修改系统参数等。</p>
</li>
<li><p>监控网络性能和故障：SNMP可以监控网络的性能和故障，如检测网络中的故障、分析网络流量等。</p>
</li>
</ol>
<p>SNMP协议的工作原理如下：</p>
<ol>
<li><p>SNMP管理器（Manager）：它是一个用于管理网络设备和系统的计算机程序，它通过SNMP协议与SNMP代理（Agent）进行通信，以获取设备和系统的状态信息。</p>
</li>
<li><p>SNMP代理（Agent）：它是一个运行在网络设备和系统上的程序，它可以获取设备和系统的状态信息，并将这些信息发送给SNMP管理器。</p>
</li>
<li><p>SNMP MIB（Management Information Base）：它是一个用于存储和管理网络设备和系统的状态信息的数据库，包含了一系列标准的对象和属性，可以通过SNMP协议进行访问和修改。</p>
</li>
<li><p>SNMP协议：它是一种用于管理和监控网络设备和系统的协议，包括SNMP协议的版本、消息格式、消息类型等。</p>
</li>
</ol>
<p>SNMP协议的主要优点包括：</p>
<ol>
<li><p>可扩展性：SNMP可以扩展到支持新的设备和系统，并且可以通过添加新的MIB对象来支持新的功能。</p>
</li>
<li><p>简单易用：SNMP协议具有简单的消息格式和操作，易于实现和使用。</p>
</li>
<li><p>标准化：SNMP协议是一个标准化的协议，可以在不同厂商的设备和系统之间进行互操作。</p>
</li>
</ol>
<p>总的来说，SNMP协议是一种用于网络管理和监控的协议，可以获取设备和系统的状态信息、配置设备和系统、监控网络性能和故障等。SNMP协议具有可扩展性、简单易用和标准化等优点，是网络管理和监控的重要工具和协议。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517170153797.png"
                      alt="image-20230517170153797" style="zoom:67%;" 
                >





<h6 id="SNMP-协议-报文类型"><a href="#SNMP-协议-报文类型" class="headerlink" title="SNMP 协议 报文类型"></a>SNMP 协议 报文类型</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517170240441.png"
                      alt="image-20230517170240441" style="zoom:67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230517170251589.png"
                      alt="image-20230517170251589" style="zoom:67%;" 
                >



<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li>网络层控制平面的方法<ul>
<li>每个路由器控制</li>
<li>逻辑上集中控制</li>
</ul>
</li>
<li>传统路由选择算法<ul>
<li>在互联网上的实现 ：RIP、OSPF、BGP</li>
</ul>
</li>
<li>SDN 控制器<ul>
<li>实际中的实现：ODL、ONOS</li>
</ul>
</li>
<li>ICMP</li>
<li>网络管理和SNMP 协议</li>
</ul>
<h2 id="链路层和局域网"><a href="#链路层和局域网" class="headerlink" title="链路层和局域网"></a>链路层和局域网</h2><p><strong>导引：</strong></p>
<ul>
<li>网络层解决了 一个网络如何到达另一个网络的路由问题</li>
<li>在一个网络内部如何由一个节点（主机或者路由器）到达另一个相邻的节点<ul>
<li>链路层的 <font color='red'><strong>点到点</strong></font>  传输层功能</li>
</ul>
</li>
</ul>
<p>在网络层中，我们学习了网络层提供的任意两台主机之间的通信服务。在两台主机之间，数据报跨越一系列通信链路传输，一些是有线链路，而一些是无线链路，从源主机起始，通过一系列分组交换机（交换机和路由器）,在目的主机结束。</p>
<p>当我们沿协议栈继续往下，从网络层到达链路层，我们自然而然地想知道</p>
<ul>
<li><strong>分组是如何通过构成端到端通信路径的各段链路的</strong>。</li>
<li>为了在单段链路上传输，网络层的数据报是怎样被封装进链路层帧的呢？</li>
<li>沿此通信路径，不同的链路能够采用不同的链路层协议吗？在广播链路中传输碰撞是如何解决的？</li>
<li>在链路层存在编址吗？如果需要，链路层编址如何与我们在第4章中学习的网络层编址一起运行呢？</li>
<li>交换机和路由器之间到底有哪些差异？</li>
</ul>
<p>我们将在本章回答这些和其他一些重要的问题。在链路层的讨论中，我们将看到两种截然不同类型的链路层信道。<strong>第一种类型是广播信道，这种信道用于连接有线局域网、卫星网和混合光纤同轴电缆（Hybrid Fiber Coaxialcable,HFC)接入网中的多台主机</strong>。因为许多主机与相同的广播信道连接，需要所谓的媒体访问协议来协调帧传输。在某些场合中，可以使用中心控制器来协调传输。<strong>第二种类型的链路层信道是点对点通信链路，这在诸如长距离链路连接的两台路由器之间，或用户办公室计算机与它们所连接的邻近以太网交换机之间等场合经常能够发现</strong>。协调对点对点链路的访问较为简单；点到点协议（Point-to-Point Protocol,PPP),该协议的适用范围从经电话线的拨号服务到经光纤链路的高速点到点帧传输。</p>
<p><font color='red'><strong>目标：</strong></font></p>
<ul>
<li>理解 数据链路层 服务的 <strong>原理</strong><ul>
<li>检错和纠错</li>
<li>共享广播信道：多点接入（多路访问）</li>
<li>链路层寻址</li>
<li>LAN ：以太网、WLAN、VLANs</li>
<li>可靠数据传输，流控制： <font color='cornflowerblue'>解决</font></li>
</ul>
</li>
<li><strong>实例</strong>和各种链路层技术的实现</li>
</ul>
<br>

<p>在计算机网络中，链路层（Data Link Layer）是网络协议栈中的第二层，它位于物理层之上，网络层之下。链路层的主要作用是将网络层传递下来的数据包转换为物理层可传输的比特流，并将接收到的比特流转换为网络层可识别的数据包。</p>
<p>链路层的功能主要包括以下几个方面：</p>
<ol>
<li><p>封装成帧：链路层将网络层传递下来的数据报封装成帧，添加首部和尾部，并在帧中加入必要的控制信息（如帧起始标志、帧类型、帧校验和等）。</p>
</li>
<li><p>媒体访问控制：链路层负责媒体访问控制，即协调多个节点对共享媒体（如以太网）的访问，防止碰撞和冲突，并保证数据的可靠传输。</p>
</li>
<li><p>差错控制：链路层通过帧校验和等机制，检测和纠正传输中的差错，保证数据的可靠传输。</p>
</li>
<li><p>流量控制：链路层可以根据网络拓扑和节点的处理能力，控制数据的流量，避免网络拥塞和资源浪费。</p>
</li>
<li><p>链路管理：链路层可以管理和监控链路状态，包括链路的连接和断开、链路速率的协商、链路质量的评估等。</p>
</li>
</ol>
<p>常见的链路层协议包括以太网（Ethernet）、无线局域网（Wi-Fi）、令牌环网（Token Ring）等。不同的链路层协议有不同的帧格式和控制机制，但它们都具有封装成帧、媒体访问控制、差错控制、流量控制和链路管理等基本功能。</p>
<p>总的来说，链路层是计算机网络协议栈中的重要组成部分，它负责将网络层传递下来的数据报封装成帧，并管理和控制数据在链路上传输的过程。链路层的正常工作对于整个网络的性能和可靠性具有重要影响。</p>
<h3 id="链路层概述"><a href="#链路层概述" class="headerlink" title="链路层概述"></a>链路层概述</h3><hr>
<p>我们先了解一下相关术语，方便本章的讨论；我们将 运行链路层 协议的 任何设备 均称为 <strong>节点</strong>（node）。节点包括主机、路由器、交换机和 WIFI 接入点。也把 沿着通信路径连接相邻节点的通信信道 称为 <strong>链路</strong>（link）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518175012639.png"
                      alt="image-20230518175012639" style="zoom:50%;" 
                >



<h4 id="数据链路层和局域网"><a href="#数据链路层和局域网" class="headerlink" title="数据链路层和局域网"></a>数据链路层和局域网</h4><ul>
<li>WLAN : 网络形式采用 点到点链路<ul>
<li>带宽大、距离远（延迟大）<ul>
<li>宽带延迟积大</li>
</ul>
</li>
<li>如果采用多点连接方式<ul>
<li>竞争方式：一旦冲突 -&gt; 代价大</li>
<li>令牌等协调方式：在其中协调节点的发送代价大</li>
</ul>
</li>
</ul>
</li>
<li>点到点链路的链路层服务实现非常简单，封装和解封装</li>
<li>LAN 一般采用 多点连接的方式<ul>
<li>连接节点非常方便</li>
<li>接到共享介质上（或者网络交换机），就可以连接所有其他节点</li>
</ul>
</li>
<li>多点连接方式网络的链路层功能实现相当复杂<ul>
<li>多点接入：协调各节点对共享介质的访问和使用</li>
<li>竞争方式：冲突之后的协调</li>
<li>令牌方式：令牌产生，占有和释放等</li>
</ul>
</li>
</ul>
<h4 id="链路层：上下文"><a href="#链路层：上下文" class="headerlink" title="链路层：上下文"></a>链路层：上下文</h4><ul>
<li>数据报（分组）在不同的链路上 以不同的链路协议传输<ul>
<li>第一跳链路：以太网</li>
<li>中间链路：帧中继链路</li>
<li>最后一跳 802.11</li>
</ul>
</li>
<li>不同的链路层协议提供不同的服务<ul>
<li>比如在 链路层 （没有或有）提供 数据可靠传送</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518180851883.png"
                      alt="image-20230518180851883" style="zoom:50%;" 
                >



<h4 id="链路层服务"><a href="#链路层服务" class="headerlink" title="链路层服务"></a>链路层服务</h4><ul>
<li><p><font color='red'><strong>成帧，链路接入</strong></font></p>
<ul>
<li>将数据报 封装在帧中，加上帧头、帧尾</li>
<li>如果采用的是共享性介质，信道接入或者信道访问权</li>
<li>在 帧头部 使用 MAC 地址来标识源和目的<ul>
<li>不同于 IP 地址</li>
</ul>
</li>
</ul>
</li>
<li><p><font color='red'>在（一个网络内）相邻两个节点完成可靠数据传递</font></p>
<ul>
<li><p>在低出错率的链路上（光纤和双绞线电缆）很少使用</p>
</li>
<li><p>在无线链路上经常使用：出错率高</p>
<ul>
<li><p>为什么在链路层和传输层都实现了可靠性</p>
<p><strong>一般化的链路层服务，不是所有链路层都提供这些服务，一个特定的链路层只是提供其中一部分的服务</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><font color='red'>在相邻节点间（一个子网内）进行可靠的转发</font></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518181629379.png"
                      alt="image-20230518181629379" style="zoom:50%;" 
                >
</li>
<li><p><font color='red'><strong>流量控制</strong></font></p>
<ul>
<li>使得相邻发送和接收方节点的速度匹配</li>
</ul>
</li>
<li><p><font color='red'><strong>错误检测</strong></font></p>
<ul>
<li>差错由信号衰减和噪声引起</li>
<li>接收方检测到差错<ul>
<li>通知发送端进行重传或者丢弃帧</li>
</ul>
</li>
</ul>
</li>
<li><p><font color='red'><strong>差错纠正</strong></font></p>
<ul>
<li>接收端检查和  纠正 bit 错误，不通过重传来 <strong>纠正错误</strong></li>
</ul>
</li>
<li><p><font color='red'><strong>半双工和全双工</strong></font></p>
<ul>
<li>半双工：链路可以双向传输，但一次只有一个方向</li>
</ul>
</li>
</ul>
<h4 id="链路层在何处实现"><a href="#链路层在何处实现" class="headerlink" title="链路层在何处实现"></a>链路层在何处实现</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518182317352.png"
                      alt="image-20230518182317352" style="zoom:50%;" 
                >

<p>图6-2显示了一个典型的主机体系结构。链路层的主体部分是在网络适配器（networkadapter)中实现的，网络适配器有时也称为网络接口卡（Network Interface Card,NIC)。位于网络适配器核心的是链路层控制器，该控制器通常是一个实现了许多链路层服务（成帧、链路接入、差错检测等）的专用芯片。因此，链路层控制器的许多功能是用硬件实现的。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518182757805.png"
                      alt="image-20230518182757805" style="zoom:50%;" 
                >

<p>在发送端，控制器取得了由协议栈较高层生成并存储在主机内存中的数据报，在链路层中封装该数据报（<strong>填写该帧的各个字段）</strong>，然后遵循链路接入协议将该帧传进通信链路中。 在接收端，控制器接收了整个帧，抽取出网络层数据报。 如果链路层执行差错检测，则需要发送端在首部设置 差错检测比特，由 接收控制器  执行差错检测</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518182836203.png"
                      alt="image-20230518182836203" style="zoom:50%;" 
                >



<h3 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h3><hr>
<p>在上一节中，我们提到了比特级差错检测和纠正（bit-level error detection and correc-tion),即对从一个节点发送到另一个物理上连接的邻近节点的链路层帧中的比特损伤进行检测和纠正，它们通常是链路层提供的两种服务。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518183152627.png"
                      alt="image-20230518183152627" style="zoom:50%;" 
                >

<p>图6-3图示说明了我们研究的环境。在发送节点，<strong>为了保护比特免受差错</strong>，使用差错检测和纠正比特（Error-Detection and-Correction,EDC)来增强数据D。通常，要保护的数据不仅包括<strong>从网络层传递下来需要通过链路传输的数据报</strong>，而且包括<strong>链路帧首部中的链路级的寻址信息、序号和其他字段</strong>。链路级帧中的D和EDC都被发送到接收节点。在接收节点，接收到比特序列D’和EDC’。注意到因<strong>传输中的比特翻转</strong>所致，D’和EDC’可能与初始的D和EDC不同。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518183620281.png"
                      alt="image-20230518183620281" style="zoom:50%;" 
                >

<p>接收方的挑战是  在他只收到 D‘ 和 EDC’ 的情况下，确定D’ 是否和初始的 D 相同。接收方判断的 准确措辞： <strong>我们问是否检测到一个差错，而非是否出现了差错</strong></p>
<br>

<p>差错检测和纠正技术使接收方有时但并总是检测出已经出现的比特差错。<strong>即使采用差错检测比特，也还是可能有未检出比特差错</strong>（undetected bit error);这就是说，接收方可能<strong>无法知道接收的信息中包含着比特差错</strong>。因此，接收方可能向网路层交付一个损伤的数据报，或者不知道该帧首部的某个其他字段的内容已经损伤。一般而言，差错检测和纠错技术越复杂(即那些具有未检测出比特差错概率较小的技术）,导致的开销就越大，这就是意味着需要更多的计算量及更多的差错检测和纠错比特。</p>
<p>我们现在来研究在传输数据中检测差错的3种技术：</p>
<ul>
<li>奇偶校验（它用来描述差错检测和纠正背后隐含的基本思想）</li>
<li>检验和方法（它通常更多地应用于运输层）</li>
<li>循环冗余检测（它通常更多地应用在适配器中的链路层）。</li>
</ul>
<h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>奇偶校验（Parity Check）是一种简单的差错检测技术，常用于串行传输中。在奇偶校验中，发送方会在数据中添加一个附加位（称为校验位），使得数据中1的个数成为偶数（偶校验）或奇数（奇校验）。接收方在接收数据后，会重新计算校验位，如果计算出的校验位与接收到的校验位不一致，则说明数据传输出错。</p>
<blockquote>
<p>采用单个奇偶校验位方式，接收方的操作也很简单。接收方只需要数一数接收的d+1比特中1的数目即可。如果在采用偶校验方案中发现了奇数个值为1的比特，接收方知道至少出现了一个比特差错。更精确的说法是，出现了奇数个比特差错。</p>
</blockquote>
<p>奇偶校验的原理很简单。以奇校验为例，假设发送方要传输一个8位二进制数10110110，那么发送方会在数据的最高位添加一个附加位，使得数据中1的个数为奇数。由于10110110中有4个1，因此发送方在最高位添加一个1，得到110110110，这就是传输的数据。在接收方，接收到数据后，会重新计算校验位，如果计算出的校验位与接收到的校验位不一致，则说明数据传输出错。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518184620410.png"
                      alt="image-20230518184620410" style="zoom:50%;" 
                >

<p>奇偶校验是一种简单的差错检测技术，它可以检测一位错误，但无法检测两位或更多的错误。并且，奇偶校验只能用于检测数据传输中的单比特错误，不能检测其他类型的错误，如漏字、重复字、失序等。因此，在实际应用中，奇偶校验常与其他差错检测技术（如循环冗余校验）结合使用，以提高数据传输的可靠性。</p>
<p>总的来说，奇偶校验是一种简单的差错检测技术，它可以检测数据传输中的单比特错误，但无法检测其他类型的错误。在串行传输中，奇偶校验常用于保证数据传输的可靠性。</p>
<h5 id="二维奇偶校验"><a href="#二维奇偶校验" class="headerlink" title="二维奇偶校验"></a>二维奇偶校验</h5><p>二维奇偶校验（Two-dimensional Parity Check）是一种常见的差错检测技术，它可以检测数据传输中的多个比特错误，并且可以同时检测行错误和列错误。</p>
<p>在二维奇偶校验中，发送方将数据按照固定的行列分组，在每个分组中添加一个附加位，使得该分组中1的个数为偶数（偶校验）或奇数（奇校验）。接收方在接收数据后，会重新计算每个分组的校验位，并对所有的校验位进行校验。如果某个分组的校验位与接收到的校验位不一致，则说明该分组发生了错误。</p>
<p>以4×4的矩阵为例，假设发送方要传输以下数据：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 0 1 1</span><br><span class="line">0 1 0 1</span><br><span class="line">1 0 1 0</span><br><span class="line">0 1 1 0</span><br></pre></td></tr></table></figure></div>

<p>发送方会将数据按照行列分组，并在每个分组中添加一个附加位，使得该分组中1的个数为偶数。添加附加位后的数据如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 0 1 1 1</span><br><span class="line">0 1 0 1 0</span><br><span class="line">1 0 1 0 1</span><br><span class="line">0 1 1 0 0</span><br><span class="line">1 1 0 0 1</span><br></pre></td></tr></table></figure></div>

<p>在接收方，接收到数据后，会重新计算每个分组的校验位，并对所有的校验位进行校验。如果某个分组的校验位与接收到的校验位不一致，则说明该分组发生了错误。</p>
<p>二维奇偶校验可以检测多个比特错误，并且可以同时检测行错误和列错误。但是，它不能纠正错误，只能检测错误。因此，在实际应用中，二维奇偶校验常与其他纠错码（如海明码）结合使用，以提高数据传输的可靠性。</p>
<p>总的来说，二维奇偶校验是一种常见的差错检测技术，它可以检测多个比特错误，并且可以同时检测行错误和列错误。在实际应用中，二维奇偶校验常与其他纠错码结合使用，以提高数据传输的可靠性。</p>
<h4 id="检验和方法"><a href="#检验和方法" class="headerlink" title="检验和方法"></a>检验和方法</h4><p>检验和（Checksum）方法是一种常见的差错检测技术，它可以检测数据传输中的多比特错误。在检验和方法中，发送方会对数据进行求和，并将结果添加到数据末尾作为校验码。接收方在接收数据后，会重新计算校验和，如果计算出的校验和与接收到的校验码不一致，则说明数据传输出错。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518194656429.png"
                      alt="image-20230518194656429" style="zoom:50%;" 
                >

<p>检验和方法的原理很简单。以16位二进制数为例，假设发送方要传输以下数据：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1101101011001101</span><br></pre></td></tr></table></figure></div>

<p>发送方会对数据进行求和，得到一个16位的校验和。在计算校验和时，为了避免溢出，通常会使用反码求和，即将所有位都取反后再相加。</p>
<p>假设发送方使用反码求和，得到的校验和为：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1010110000111000</span><br></pre></td></tr></table></figure></div>

<p>然后，发送方将校验和添加到数据末尾，组成一个20位的数据包：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11011010110011011010110000111000</span><br></pre></td></tr></table></figure></div>

<p>在接收方，接收到数据后，会重新计算校验和。接收方将接收到的数据按照与发送方相同的方式进行求和，得到一个16位的校验和。然后，接收方将计算出的校验和与接收到的校验码进行比较。如果两者不一致，则说明数据传输出错。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518185628663.png"
                      alt="image-20230518185628663" style="zoom:50%;" 
                >

<blockquote>
<p>在检验和技术中，图6-4中的d比特数据被作为一个k比特整数的序列处理。一个简单检验和方法就是将这k比特整数加起来，并且用得到的和作为差错检测比特。因特网检验和（Internet checksum)就基于这种方法，即数据的字节作为16比特的整数对待并求和。<strong>这个和的反码形成了携带在报文段首部的因特网检验和</strong>。接收方通过对接收的数据（包括检验和）的和  <strong>取反码</strong>，并且检测其结果<strong>是否为全1比特来检测</strong>检验和。如果这些比特中<strong>有任何比特是0,就可以指示出差错</strong>。</p>
<p><strong>不同为1，相同为，取反 应相反，若有相同则有差错</strong></p>
</blockquote>
<p>在 TCP 和 UDP 协议中，对所有字段（包括首部和数据字段）都计算 因特网检验和。在其他协议中，对首部计算一个 检验和，对整个分组计算一个检验和</p>
<p>检验和方法可以检测多比特错误，但不能纠正错误。在实际应用中，检验和方法常与其他纠错码（如海明码）结合使用，以提高数据传输的可靠性。总的来说，检验和方法是一种常见的差错检测技术，它可以检测数据传输中的多比特错误。在实际应用中，检验和方法常与其他纠错码结合使用，以提高数据传输的可靠性。</p>
<h4 id="循环冗余检测-（Cyclic-Redundancy-Check）-CRC"><a href="#循环冗余检测-（Cyclic-Redundancy-Check）-CRC" class="headerlink" title="循环冗余检测 （Cyclic Redundancy Check） CRC"></a>循环冗余检测 （Cyclic Redundancy Check） CRC</h4><p>循环冗余校验（Cyclic Redundancy Check，CRC）是一种常用的差错检测技术，它可以检测数据传输中的多比特错误，并且可以纠正少量的错误。CRC主要应用于数据通信领域，如以太网、无线局域网等。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518194740536.png"
                      alt="image-20230518194740536" style="zoom:50%;" 
                >

<p>在CRC中，发送方将数据看作一个多项式，并对该多项式进行除法运算，得到余数。余数被添加到原始数据末尾作为校验码。接收方在接收数据后，也将数据看作一个多项式，并对该多项式进行除法运算，得到余数。如果余数为0，说明数据传输正确。否则，接收方会请求发送方重新发送数据。</p>
<p>CRC的核心是多项式除法运算。具体来说，CRC使用一个固定的生成多项式（Generator Polynomial）进行多项式除法运算。生成多项式是一个固定的、不可变的多项式，它的次数通常比数据位数少1。在除法运算中，发送方将数据看作一个多项式，将该多项式的次数扩展到与生成多项式相同，并将两个多项式进行除法运算。除法运算的结果就是余数，余数被添加到数据末尾成为校验码。</p>
<p>以16位数据为例，假设发送方要传输以下数据：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1101101011001101</span><br></pre></td></tr></table></figure></div>

<p>发送方会将数据扩展为一个17位的多项式：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x^16 + x^13 + x^12 + x^10 + x^9 + x^5 + x^2 + 1</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>怎么拓展为 17 位的多项式</strong></p>
<p>将一个16位数据扩展为17位的多项式，可以在16位数据的最高位（即最左侧位）添加一个0，并将该0视为一次幂为16的项。</p>
<p>例如，假设要将16位数据1101101011001101扩展为一个17位的多项式，可以在左侧添加一个0，得到：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1101101011001101</span><br></pre></td></tr></table></figure></div>

<p>这样就得到了一个17位的多项式，其中最高位为一次幂为16的项。</p>
<p>在进行CRC运算时，这个17位的多项式将与生成多项式进行除法运算，得到余数。余数的位数通常比生成多项式的次数小1，因此余数通常是16位的。将余数添加到原始数据末尾作为CRC校验码，就组成了一个包含17位的数据包。</p>
<p>需要注意的是，数据的扩展方式可能会影响CRC运算的结果。因此，在进行CRC运算时，需要使用与发送方相同的扩展方式。通常情况下，数据的扩展方式是由通信协议规定的，接收方需要遵守相应的规定进行数据处理。</p>
<p>总的来说，将一个16位数据扩展为17位的多项式，只需要在最高位添加一个0，并将该0视为一次幂为16的项。在进行CRC运算时，需要使用与发送方相同的扩展方式，以保证CRC校验的正确性。</p>
</blockquote>
<p>然后，发送方将该多项式与生成多项式进行除法运算，得到余数：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x^3 + x^2 + 1</span><br></pre></td></tr></table></figure></div>

<p>发送方将余数添加到数据末尾，组成一个20位的数据包：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1101101011001101 110</span><br></pre></td></tr></table></figure></div>

<p>在接收方，接收到数据后，也将数据看作一个多项式，并对该多项式进行除法运算，得到余数。如果余数为0，说明数据传输正确。否则，接收方会请求发送方重新发送数据。</p>
<blockquote>
<p><strong>怎么对 多项式进行除法运算，得到余数</strong></p>
<p>在CRC中，除法运算是指将多项式除以一个固定的生成多项式，得到的余数就是CRC校验码。下面简要介绍如何对多项式进行除法，得到余数。</p>
<p>假设要对一个16位的多项式P(x)除以一个8位的生成多项式G(x)，得到的余数为R(x)。除法运算的过程可以表示为：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(x) / G(x) = Q(x) ... R(x)</span><br></pre></td></tr></table></figure></div>

<p>其中，Q(x)表示商多项式，R(x)表示余数多项式。除法运算的过程是逐步将P(x)减去G(x)的倍数，直到无法继续减为止。</p>
<p>具体的操作步骤如下：</p>
<ol>
<li><p>将P(x)的次数扩展到与G(x)相同，并将P(x)和G(x)对齐，使得P(x)的最高位对齐G(x)的最高位。</p>
</li>
<li><p>将P(x)的最高位与G(x)的最高位对齐，计算它们的差，得到一个新的多项式。</p>
</li>
<li><p>如果新的多项式的次数高于或等于G(x)的次数，则将G(x)左移一位，再将新的多项式与G(x)进行异或运算。如果新的多项式的次数低于G(x)的次数，则将G(x)右移一位，然后继续执行步骤2。</p>
</li>
<li><p>重复执行步骤2和步骤3，直到P(x)的次数小于G(x)的次数为止。此时，P(x)的系数就是余数多项式R(x)的系数。</p>
</li>
</ol>
<p>例如，假设要对多项式P(x)&#x3D;x^6 + x^5 + x^3 + x + 1除以生成多项式G(x)&#x3D;x^4 + x + 1，得到余数R(x)。除法运算的过程如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x^6 + x^5 + x^3 + x + 1 / x^4 + x + 1 = x^2</span><br><span class="line"></span><br><span class="line">x^6 + x^5 + x^3 + x + 1 - x^6 - x^5 - x^3 - x^2 - x = 1</span><br><span class="line"></span><br><span class="line">x^2 / x^4 + x + 1 = 0</span><br><span class="line"></span><br><span class="line">1 / x^4 + x + 1 = x^3 + x^2</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>余数R(x)为1。</p>
<p>因此，多项式P(x)除以生成多项式G(x)的余数为R(x)&#x3D;1。</p>
<p>总的来说，CRC校验的核心是多项式除法运算。在进行除法运算时，需要将多项式对齐，并将多项式的最高位与生成多项式的最高位对齐。然后，逐步将多项式减去生成多项式的倍数，直到无法继续减为止。最后剩下的多项式就是余数，即CRC校验码。</p>
</blockquote>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518195324010.png"
                      alt="image-20230518195324010" style="zoom:50%;" 
                >

<p>CRC可以检测多比特错误，并且可以纠正少量的错误。但是，CRC的性能取决于生成多项式的选择。不同的生成多项式可以提供不同的性能，如检测能力、纠错能力等。因此，在实际应用中，需要根据具体的场景选择合适的生成多项式。</p>
<p>总的来说，CRC是一种常用的差错检测技术，它可以检测数据传输中的多比特错误，并且可以纠正少量的错误。在实际应用中，CRC的性能取决于生成多项式的选择。</p>
<h5 id="CRC-性能分析"><a href="#CRC-性能分析" class="headerlink" title="CRC 性能分析"></a>CRC 性能分析</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518195402422.png"
                      alt="image-20230518195402422" style="zoom:50%;" 
                >

<h3 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h3><hr>
<p>两种类型的链路（一个子网内部链路连接方式）</p>
<ul>
<li>点到点<ul>
<li>拨号访问的 PPP</li>
<li>以太网交换机和主机之间的点到点链路</li>
</ul>
</li>
<li>广播（共享线路或媒体）<ul>
<li>传统以太网<ul>
<li>HFC 上行链路</li>
<li>802.11 无线局域网</li>
</ul>
</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518195858998.png"
                      alt="image-20230518195858998" style="zoom:50%;" 
                >

<p>多路访问（Multiple Access）是指多个用户共享同一通信链路的技术。在多路访问链路中，多个用户可以同时访问同一链路，实现数据的交换和传输。</p>
<blockquote>
<p>因为所有的节点都能够传输帧，所以多个节点可能会同时传输帧。当发生这种情况时，所有节点同时接到多个帧；这就是说，<strong>传输的帧在所有的接收方处碰撞（collide)了</strong>。通常，当<strong>碰撞发生时</strong>，<strong>没有一个接收节点能够有效地获得任何传输的帧</strong>；在某种意义下，碰撞帧的信号纠缠在一起。因此，涉及此次碰撞的所有帧都丢失了，在碰撞时间间隔中的广播信道被浪费了。显然，**如果许多节点要频繁地传输帧，许多传输将导致碰撞，广播信道的大量带宽将被浪费掉。</p>
</blockquote>
<p>为了保证多个用户之间的数据传输不会互相干扰，需要使用多路访问协议来控制用户的访问。</p>
<p>多路访问协议是用于控制多个用户在同一链路上访问的协议。</p>
<ul>
<li>单个共享的广播型链路</li>
<li>2 个 或更多站点同时传送： <font color='red'><strong>冲突（collision）</strong></font><ul>
<li>多个节点在同一时刻发送，则会收到2个或多个信号叠加</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>多路访问协议（介质访问控制协议：MAC）</strong></font></p>
<ul>
<li>分布式算法 - 决定节点如何使用 共享信道，即：决定节点什么时候可以发送</li>
<li>关于共享控制的通信信道必须借助信道本身进行传输<ul>
<li>没有带外的信道，各节点使用其协调信道使用</li>
<li>用于传输控制信息</li>
</ul>
</li>
</ul>
<p><font color='cornflowerblue'><strong>理想的多路访问协议</strong></font></p>
<p><font color='red'>给定：</font> Rbps 的广播信道</p>
<p><font color='red'>必要条件：</font></p>
<ol>
<li>当一个节点要发送的时候，可以用  R 速率发送</li>
<li>当 M 个节点要发送时，每个可以平均 R&#x2F;M 的平均速率发送</li>
<li>完全分布的<ul>
<li>没有特殊节点 协调发送</li>
<li>没有时钟和时隙的同步</li>
</ul>
</li>
<li>简单</li>
</ol>
<p><strong>三大类</strong></p>
<ul>
<li><font color='red'><strong>信道划分</strong></font><ul>
<li>把信道划分成小片（时间、频率、编码）</li>
<li>分配片给每个节点使用</li>
</ul>
</li>
<li><font color='red'><strong>随机访问</strong></font><ul>
<li>信道不划分，允许冲突</li>
<li>冲突后恢复</li>
</ul>
</li>
<li><font color='red'><strong>依次轮流</strong></font><ul>
<li>节点依次轮流</li>
<li>但是有很多数据传输的节点可以获得较长时间的信道使用权</li>
</ul>
</li>
</ul>
<p><strong>常用的多路访问协议</strong>包括以下几种：</p>
<ol>
<li><strong>ALOHA协议</strong>：ALOHA协议是一种最早用于卫星通信的多路访问协议。在ALOHA协议中，用户可以随时发送数据，但是如果多个用户同时发送数据，就会发生冲突。为了解决冲突问题，ALOHA协议引入了一种随机重传机制，即发送方在发送数据后，等待一段时间后再次发送数据，如果重传的数据仍然发生冲突，则等待更长的时间再次重传，直到数据发送成功。</li>
<li><strong>CSMA&#x2F;CD协议</strong>：CSMA&#x2F;CD协议是一种用于局域网的多路访问协议。在CSMA&#x2F;CD协议中，用户在发送数据前先监听链路，如果链路空闲，则可以发送数据。如果多个用户同时发送数据，就会发生冲突。为了解决冲突问题，CSMA&#x2F;CD协议引入了一种冲突检测机制，即发送方在发送数据时，同时监听链路，如果检测到数据冲突，则停止发送数据，并等待一段时间后重新发送数据。</li>
<li><strong>TDMA协议</strong>：TDMA协议是一种用于无线通信的多路访问协议。在TDMA协议中，时间被分成若干个时隙，每个用户在一个时隙内发送数据。不同用户的时隙不同，因此可以避免数据冲突。TDMA协议需要在发送方和接收方之间进行协调，以保证每个用户在正确的时隙发送数据。</li>
<li><strong>CDMA协议</strong>：CDMA协议是一种用于无线通信的多路访问协议。在CDMA协议中，每个用户使用不同的码片对数据进行编码，不同用户的码片不同，因此可以避免数据冲突。CDMA协议需要在发送方和接收方之间进行协调，以保证每个用户的码片不同。</li>
<li><strong>FDMA协议</strong>: 频分多路复用（FDMA）是一种多路访问技术，将可用的频带分成多个频段，每个用户占用不同的频段进行通信。FDMA技术广泛应用于无线通信系统中，如AM广播、调频广播、蜂窝移动通信等。FDMA将频带分成多个频段，每个频段对应一个用户，可以有效地避免数据冲突和干扰，实现多个用户同时使用同一通信链路的目的。</li>
</ol>
<p>总的来说，多路访问链路和协议是用于控制多个用户在同一链路上访问的技术和协议。不同的多路访问协议有不同的特点和适用范围，需要根据具体的应用场景选择合适的协议。</p>
<h4 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h4><p>时分多路复用（TDM） 和 频分多路复用（FDM） 是两种能够用于在所有共享信道节点之间划分广播信道带宽的技术。举例来说，假设一个支持 N  个节点的信道且信道的传输速率为Rbps。TDM将时间划分为时间帧（timeframe),并进一步划分每个时间帧为N个<strong>时隙（slot)</strong>。（不应当把TDM时间帧与在发送和接收适配器之间交换的链路层数据单元相混淆，后者也被称为帧。为了减少混乱，在本小节中我们将链路层交换的数据单元称为分组。）然后把每个时隙分配给N个节点中的一个。无论何时某个节点在有分组要发送的时候，它在循环的TDM帧中指派给它的时隙内传输分组比特。通常，选择的时隙长度应使一个时隙内能够传输单个分组。</p>
<p>信道划分协议是用于控制多个用户在同一通信链路上访问的一种协议。信道划分协议将通信链路划分为多个子信道或时隙，在不同的子信道或时隙上分配给不同的用户进行数据传输。常见的信道划分协议包括以下几种：</p>
<ol>
<li><p>频分多路复用（FDMA）：FDMA技术将可用的频带分成多个频段，每个用户占用不同的频段进行通信。FDMA技术广泛应用于无线通信系统中，如AM广播、调频广播、蜂窝移动通信等。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518210522056.png"
                      alt="image-20230518210522056" style="zoom:50%;" 
                >
</li>
<li><p>时分多路复用（TDMA）：TDMA技术将通信时段分成若干个时隙，每个用户在一个时隙内发送数据。不同用户的时隙不同，因此可以避免数据冲突。TDMA技术广泛应用于数字通信系统中，如GSM、PDC等。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518210256756.png"
                      alt="image-20230518210256756" style="zoom:50%;" 
                >
</li>
<li><p>码分多路复用（CDMA）：CDMA技术将用户数据进行编码，不同用户使用不同的码片进行编码，因此可以避免数据冲突。CDMA技术广泛应用于无线通信系统中，如CDMA2000、WCDMA等。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518210606420.png"
                      alt="image-20230518210606420" style="zoom:50%;" 
                ></li>
</ol>
<h4 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h4><p>随机接入协议是一种多路访问协议，用于控制多个用户在同一通信链路上访问的一种协议。在随机接入协议中，用户可以随时发送数据，一个节点总是<strong>以信道的全部速率</strong>（即 Rbps ） 进行发送，但是如果<strong>多个用户同时发送数据</strong>，<strong>就会发生冲突</strong>。当有碰撞时，涉及碰撞的每个节点反复地重发它的帧（也就是分组），直到该帧无碰撞为止。 但是当一个节点经历一次碰撞时，他不必立即重发该帧。相反，<strong>他在重发该帧之前 等待一个随机时延</strong>。涉及碰撞的每个节点 <strong>独立的</strong>  选择时延 。 换言之，<strong>为了解决冲突问题，随机接入协议引入了一种随机机制，即发送方在发送数据前随机选择一个时隙或码片进行数据传输</strong>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518211423709.png"
                      alt="image-20230518211423709" style="zoom:50%;" 
                >

<p>常见的随机接入协议包括以下几种：</p>
<ol>
<li><p>ALOHA协议：ALOHA协议是一种最早用于卫星通信的随机接入协议。在ALOHA协议中，用户可以随时发送数据，但是如果多个用户同时发送数据，就会发生冲突。为了解决冲突问题，ALOHA协议引入了一种随机重传机制，即发送方在发送数据后，等待一段时间后再次发送数据，如果重传的数据仍然发生冲突，则等待更长的时间再次重传，直到数据发送成功。</p>
</li>
<li><p>CSMA&#x2F;CA协议：CSMA&#x2F;CA协议是一种用于无线局域网的随机接入协议。在CSMA&#x2F;CA协议中，用户在发送数据前先监听链路，如果链路空闲，则可以发送数据。如果多个用户同时发送数据，就会发生冲突。为了解决冲突问题，CSMA&#x2F;CA协议引入了一种碰撞避免机制，即发送方在发送数据时，等待一段时间后再次监听链路，如果链路仍然空闲，则发送数据，否则等待更长的时间后再次尝试发送数据。</p>
</li>
<li><p>CDMA协议：CDMA协议是一种用于无线通信的随机接入协议。在CDMA协议中，每个用户使用不同的码片对数据进行编码，不同用户的码片不同，因此可以避免数据冲突。CDMA协议需要在发送方和接收方之间进行协调，以保证每个用户的码片不同。</p>
</li>
</ol>
<p>总的来说，随机接入协议是一种用于控制多个用户在同一通信链路上访问的协议。随机接入协议可以灵活地分配通信资源，但是由于存在数据冲突和干扰问题，需要引入一些机制来解决这些问题。不同的随机接入协议有不同的特点和适用范围，需要根据具体的应用场景选择合适的协议。</p>
<h5 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h5><p>ALOHA是一种最早用于卫星通信的随机接入协议。在ALOHA协议中，用户可以随时发送数据，但是如果多个用户同时发送数据，就会发生冲突。为了解决冲突问题，<strong>ALOHA协议引入了一种随机重传机制，即发送方在发送数据后，等待一段时间后再次发送数据，如果重传的数据仍然发生冲突，则等待更长的时间再次重传，直到数据发送成功</strong>。</p>
<blockquote>
<p>ALOHA协议的操作步骤如下：</p>
<ol>
<li><p>发送方发送数据：发送方在任何时刻都可以发送数据。</p>
</li>
<li><p>碰撞检测：当有多个发送方同时发送数据时，就会发生碰撞。每个发送方在发送完数据后会监听链路，如果检测到链路上有数据传输，则表示发生碰撞。</p>
</li>
<li><p>随机重传：发生碰撞后，每个发送方会等待一段随机时间后再次发送数据，重传时间是随机的，并且会根据网络负载情况动态调整。如果重传的数据仍然发生碰撞，则等待更长的时间再次重传，直到数据发送成功。</p>
</li>
<li><p>接收方确认：接收方收到数据后会发送确认信号，通知发送方数据已经成功接收。</p>
</li>
</ol>
<p>ALOHA协议的操作非常简单，没有任何复杂的控制机制。发送方可以随时发送数据，如果发生碰撞，则随机重传，直到数据发送成功。接收方在接收到数据后会发送确认信号，以保证数据传输的可靠性。虽然ALOHA协议存在冲突和干扰问题，但是通过随机重传机制可以一定程度上解决这个问题。</p>
</blockquote>
<p>如果 有碰撞，该节点在时隙结束之前检测到这次碰撞。该节点 以  概率 P 在后续的每个时隙中重传，直到无碰撞</p>
<p>我们说以概率p重传，是指某节点有效地投挪一个有偏倚的硬币；硬币正面事件对应着重传，而重传出现的概率为p。硬币反面事件对应着“跳过这个时隙，在下个时隙再挪硬币”；这个事件以概率（1-p)出现。所有涉及碰撞的节点独立地投挪它们的硬币。	</p>
<p>时隙ALOHA看起来有很多优点。与信道划分不同，当某节点是唯一活跃的节点时(一个节点如果有帧要发送就认为它是活跃的）,时隙ALOHA允许该节点以全速R连续传输。时隙ALOHA也是高度分散的，因为每个节点检测碰撞并独立地决定什么时候重传。(然而，时隙ALOHA的确需要在节点中对时隙同步；我们很快将讨论ALOHA协议的一个不分时隙的版本以及CSMA协议，这两种协议都不需要这种同步。）时隙ALOHA也是一个极为简单的协议。</p>
<p>当只有一个活跃节点时，时隙ALOHA工作出色，但是当有多个活跃节点时效率又将如何呢？这里有两个可能要考虑的效率问题。首先，当有多个活跃节点时，一部分时隙将有碰撞，因此将被**“浪费”<strong>掉了。第二个考虑是，时隙的另一部分</strong>将是空闲的**，因为所有活跃节点由于概率传输策略会节制传输。<strong>唯一“未浪费的”时隙是那些刚好有一个节点传输的时隙</strong>。刚好有一个节点传输的时隙称为一个成功时隙（successful slot)。时隙多路访问协议的效率（efficiency)定义为：<strong>当有大量的活跃节点且每个节点总有大量的帧要发送时，长期运行中成功时隙的份额。注意到如果不使用某种形式的访问控制，而且每个节点都在每次碰撞之后立即重传，这个效率将为零</strong>。时隙ALOHA显然增加了它的效率，使之大于零，但是效率增加了多少呢？</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519123122157.png"
                      alt="image-20230519123122157" style="zoom:50%;" 
                >

<p>当有 N 个活跃节点时 ，时隙 ALOHA的 效率为  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230518212846010.png"
                      alt="image-20230518212846010" style="zoom:50%;" 
                >，即 <strong>37%</strong></p>
<h5 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519123152102.png"
                      alt="image-20230519123152102" style="zoom:50%;" 
                >

<p>当 节点 i 在传输时，其他节点不能开始传输，因为 这种传输将与节点 i 传输的后面部分相重叠。通过这种方式，我们求得 纯 ALOHA协议的 最大效率是 </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519091813691.png"
                      alt="image-20230519091813691" style="zoom:50%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519123223474.png"
                      alt="image-20230519123223474" style="zoom:50%;" 
                >

<p>仅为 <strong>17.5%</strong>，这就是完全分散的 ALOHA 协议所需要付出的代价</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519091935845.png"
                      alt="image-20230519091935845" style="zoom: 33%;" 
                >



<h5 id="载波侦听多路访问协议-CSMA"><a href="#载波侦听多路访问协议-CSMA" class="headerlink" title="载波侦听多路访问协议 CSMA"></a>载波侦听多路访问协议 CSMA</h5><p>在时隙和 ALOHA协议中，一个节点传输的决定独立于连接到这个广播 信道上的其他节点的活动。特别是， <strong>一个节点不关心在他传输的时候是否有其他节点碰巧在传输，而且即使有另一个节点在干扰他的传输也不会停止传输</strong></p>
<p>两种规则</p>
<ul>
<li>说话之前先听。如果有其他人正在说话，等到他们说完为止。在网络领域中，被称为 <strong>载波侦听（carrier sensing）</strong>，即  一个节点在传输前先听 信道，如果有来自另一个节点的帧正向信道中发送，节点则等待 直到 检测到一小段时间没有传输，然后开始传输</li>
<li>如果与其他人同时开始说话，停止说话。这在网络领域 被称为 <strong>碰撞检测（collision detection）</strong>，即  当一个传输节点在传输时一直 侦听此信道。 如果他检测到 另一个节点正在传输干扰帧，他就停止传输，在重复 “侦听 - 当空闲时传输” 循环之前等待一段随机时间</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519123317685.png"
                      alt="image-20230519123317685" style="zoom:40%;" 
                >

<p>载波侦听多路访问协议（Carrier Sense Multiple Access ，CSMA）是一种用于控制多个用户在同一通信链路上访问的协议。<strong>在CSMA协议中，用户在发送数据前先监听链路，如果链路空闲，则可以发送数据。如果多个用户同时发送数据，就会发生冲突。为了解决冲突问题，CSMA协议引入了一种碰撞检测机制，即发送方在发送数据后会继续监听链路，如果检测到链路上有数据传输，则表示发生碰撞，需要等待一段时间后再次尝试发送数据。</strong></p>
<p>这两个规则包含在载波侦听多路访问（Carrier Sense Multiple Access,CSMA)和具有碰撞检测的CSMA(CSMA with Collision Detection,CSMA&#x2F;CD)协议族中</p>
<p>CSMA协议的缺点是存在隐藏终端问题和暴露终端问题。隐藏终端问题是指当两个发送方之间存在一个接收方，但是由于距离或障碍物阻挡等原因，发送方无法检测到对方的存在，从而导致碰撞。暴露终端问题是指某些发送方可能由于距离远或信号弱而无法感知到其他发送方的存在，从而导致空闲的链路被浪费。</p>
<p>总的来说，CSMA协议是一种常用的多路访问协议，具有灵活的资源分配、动态调整和分布式控制等优点。然而，它仍然存在某些缺陷，需要在具体场景中选择合适的协议来保证网络的性能和可靠性。</p>
<h6 id="CSMA-冲突"><a href="#CSMA-冲突" class="headerlink" title="CSMA 冲突"></a>CSMA 冲突</h6><p><font color='red'><strong>冲突可能仍然发生</strong></font></p>
<p>由传播延迟造成：两个节点可能侦听不到正在进行的传输</p>
<p><font color='red'><strong>冲突</strong></font></p>
<p>整个冲突帧的传输时间都被浪费了，是无效的传输</p>
<p><font color='red'><strong>注意</strong></font></p>
<p>传播延迟（距离）决定了冲突的概率</p>
<blockquote>
<p>节点根据本地的信道使用情况来判断全部信道的使用情况</p>
</blockquote>
<h5 id="具有碰撞检测的载波侦听多路访问协议（CSMA-CD"><a href="#具有碰撞检测的载波侦听多路访问协议（CSMA-CD" class="headerlink" title="具有碰撞检测的载波侦听多路访问协议（CSMA&#x2F;CD)"></a>具有碰撞检测的载波侦听多路访问协议（CSMA&#x2F;CD)</h5><p>CSMA&#x2F;CD是一种基于载波侦听多路访问协议（CSMA）的协议，它引入了碰撞检测（Collision Detection，CD）机制，用于检测和解决数据碰撞问题。在CSMA&#x2F;CD协议中，发送方在发送数据前先监听链路，如果链路空闲，则可以发送数据。如果多个用户同时发送数据，就会发生碰撞。为了解决碰撞问题，CSMA&#x2F;CD协议引入了碰撞检测机制，即发送方在发送数据的同时，继续监听链路，如果检测到碰撞，则立即停止发送数据，并等待随机时间后再次尝试发送数据。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519124319554.png"
                      alt="image-20230519124319554" style="zoom:50%;" 
                >

<p>CSMA&#x2F;CD协议的操作步骤如下：</p>
<ol>
<li>发送数据：发送方在监听到链路空闲后，立即发送数据。</li>
<li>碰撞检测：发送方在发送数据的同时，继续监听链路，如果检测到碰撞，则立即停止发送数据，并等待随机时间后再次尝试发送数据。</li>
<li>重传数据：发送方在等待一段随机时间后，重新发送数据。如果多次重传仍然无法成功发送数据，则放弃发送。</li>
<li>接收确认：接收方收到数据后发送确认信号，通知发送方数据已经成功接收。</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519124518094.png"
                      alt="image-20230519124518094" style="zoom:50%;" 
                >

<p>对信道的浪费变少了</p>
<p>总的来说，CSMA&#x2F;CD协议是一种常用的多路访问协议，具有良好的性能和可靠性。然而，随着网络技术的不断发展，CSMA&#x2F;CD协议已经逐渐被更先进的协议所替代，如以太网的802.3标准等。</p>
<h6 id="以太网-CSMA-CD-算法"><a href="#以太网-CSMA-CD-算法" class="headerlink" title="以太网 CSMA&#x2F;CD  算法"></a>以太网 CSMA&#x2F;CD  算法</h6><ol>
<li><p>适配器获取数据报，创建帧</p>
</li>
<li><p>发送前：侦听信道 CS</p>
<ol>
<li>闲：开始传输帧</li>
<li>忙：一直等到闲再发送</li>
</ol>
</li>
<li><p>发送过程中，冲突检测 CD</p>
<ol>
<li>没有冲突：成功</li>
<li>检测到冲突：放弃，之后尝试重发</li>
</ol>
</li>
<li><p>发送方适配器检测到冲突，除放弃外，还发送一个 Jam  信号，所有听到 冲突的适配器也是如此</p>
<p><font color='red'>强化冲突：让所有站点都知道冲突</font></p>
</li>
<li><p>如果放弃，适配器进入 指数退避状态</p>
<p>在 第 m 次失败后，适配器随机选择一个 {0，1,2，…,$$2^{m-1}$$} 中 的K，等待 K * 512 位时，然后转到步骤2</p>
<blockquote>
<p><font color='red'><strong>二进制指数退避算法</strong></font></p>
<p>binary exponential backoff </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519130245200.png"
                      alt="image-20230519130245200" style="zoom:50%;" 
                >

<p>在实现二进制指数退避算法时，适配器进入指数退避状态后，需要进行等待和重传数据的操作。具体来说，适配器进入指数退避状态的过程如下：</p>
<ol>
<li><p>发送数据：适配器在发送数据前先监听网络，如果网络空闲，则可以发送数据。</p>
</li>
<li><p>发生冲突：如果多个适配器同时发送数据，则会发生冲突。发生冲突后，每个适配器都会停止发送数据，并进入指数退避状态。</p>
</li>
<li><p>计算等待时间：在进入指数退避状态后，适配器需要计算下一次重传数据需要等待的时间。第一次重传时，等待时间是一个随机数，之后每次等待时间前一次等待时间的两倍。</p>
</li>
<li><p>等待时间：适配器在计算出下一次重传需要等待的时间后，需要等待这段时间后再次发送数据。适配器可以使用计数器或定时器等机制来实现等待时间的计算和控制。</p>
</li>
<li><p>重传数据：在等待时间后，适配器重新发送数据。如果再次发生冲突，则适配器需要重新计算下一次重传需要等待的时间，并进行等待和重传数据的操作。</p>
</li>
<li><p>最大重传次数：如果适配器重传数据次数超过了最大重传次数，则放弃发送数据。</p>
</li>
</ol>
<p>需要注意的是，适配器在进入指数退避状态后，需要按照指数级递增的方式计算等待时间，以避免多个适配器在同一时间重传数据导致新的冲突。在具体实现中，等待时间需要满足一定的约束条件，如等待时间不能超过一个预设的最大值，以避免适配器等待时间过长导致网络资源浪费的问题。此外，在等待时间的计算中还可以引入一些随机性，以避免多个适配器在同一时间重传数据，从而导致新的冲突。</p>
<p>总的来说，适配器进入指数退避状态后，需要进行等待和重传数据的操作，以避免网络冲突。具体实现中，适配器需要计算和控制等待时间，并在等待时间后重新发送数据。适配器可以使用计数器或定时器等机制来实现等待时间的计算和控制。在具体实现中，需要注意等待时间的计算和约束条件，以避免适配器等待时间过长导致网络资源浪费的问题。</p>
</blockquote>
</li>
</ol>
<h6 id="CSMA-CD-效率"><a href="#CSMA-CD-效率" class="headerlink" title="CSMA&#x2F;CD 效率"></a>CSMA&#x2F;CD 效率</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519134021940.png"
                      alt="image-20230519134021940" style="zoom:50%;" 
                >



<h5 id="无线局域网中的-MAC：CSMA-CA"><a href="#无线局域网中的-MAC：CSMA-CA" class="headerlink" title="无线局域网中的 MAC：CSMA&#x2F;CA"></a>无线局域网中的 MAC：CSMA&#x2F;CA</h5><p>CSMA&#x2F;CA是载波监听多路访问&#x2F;碰撞避免（Carrier Sense Multiple Access&#x2F;Collision Avoidance）的一种协议，主要用于无线局域网（WLAN）中，用于解决在无线网络中的冲突问题。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519134250747.png"
                      alt="image-20230519134250747" style="zoom:50%;" 
                >

<p>CSMA&#x2F;CA协议的工作原理如下：</p>
<ol>
<li>载波监听：在发送数据前，设备需要先监听信道，检测是否有其他设备正在发送数据。如果信道空闲，设备才可以开始发送数据。</li>
<li>随机等待：如果信道被占用，设备需要等待一段随机时间后再次进行载波监听。随机等待的时间是根据指数退避算法计算得出的，以避免多个设备在同一时间重试发送数据。</li>
<li>帧传输：如果经过若干次随机等待后，信道仍然空闲，则设备可以开始传输数据帧。在数据传输过程中，设备将使用帧序列控制（Frame Sequence Control）字段来协调数据的传输，以避免数据的冲突和丢失。</li>
<li>确认应答：当一个设备成功接收到数据帧后，会发送一个确认应答帧以告知发送方数据已经成功接收，从而防止数据重传和冲突。</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519134530493.png"
                      alt="image-20230519134530493" style="zoom:50%;" 
                >



<p>需要注意的是，CSMA&#x2F;CA协议主要用于无线网络中，由于无线信号的特性，数据传输容易受到干扰和衰减，因此需要使用一些特殊的技术来避免冲突和丢失。CSMA&#x2F;CA协议是其中一种常用的技术，能够有效地提高无线网络的性能和可靠性。</p>
<p>总的来说，CSMA&#x2F;CA是一种用于无线网络中的多路访问和碰撞避免的协议，通过载波监听、随机等待、帧传输和确认应答等机制，能够有效地避免数据的冲突和丢失，提高无线网络的性能和可靠性。</p>
<h6 id="IEEE-802-11-MAC-协议：CSMA-CA"><a href="#IEEE-802-11-MAC-协议：CSMA-CA" class="headerlink" title="IEEE 802.11 MAC 协议：CSMA&#x2F;CA"></a>IEEE 802.11 MAC 协议：CSMA&#x2F;CA</h6><ul>
<li><p>在 count down 时，侦听到了 信道空闲为什么不发送，而要 等到 0 时 才发送</p>
<ul>
<li>2 个站点有数据帧需要发送，第三个节点正在发送</li>
<li><font color='cornflowerblue'>LAN CD：让 2 者 听完 第三个节点发完，立即发送</font><ul>
<li><font color='cornflowerblue'>冲突：放弃当前的发送，避免了信道的浪费于无用冲突帧的发送</font></li>
<li><font color='cornflowerblue'>代价并不昂贵</font></li>
</ul>
</li>
<li><strong>WLAN：CA</strong><ul>
<li>无法 CD，一旦发送就必须发完，如冲突信道浪费，代价昂贵</li>
<li>思想： 尽量 <strong>事先避免</strong> 冲突，而不是发生冲突时放弃然后重发</li>
<li>听到发送的站点，分别选择 随机值，回退到 0 发送<ul>
<li>不同的随机值，一个站点会胜利</li>
<li>失败站点会冻结计数器，当胜利节点发完再发</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>无法完全避免冲突</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519135703708.png"
                      alt="image-20230519135703708"
                ></p>
<ul>
<li>两个节点相互隐藏<ul>
<li>AB 相互隐藏，C在传输</li>
<li>AB 选择了随机回退值</li>
<li>一个 节点 如A胜利了，发送</li>
<li>而 B 节点收不到，顺利 count down 到 0 发送</li>
<li>AB 的发送在 C 附近形成了 干扰</li>
</ul>
</li>
<li>选择了非常 靠近的 随机回退值<ul>
<li>AB 的选择非常近</li>
<li>A 到 0 发送</li>
<li>但是这个信号还没到 B 时</li>
<li>B 也到 0 了，发送</li>
<li>冲突</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>冲突避免</strong></p>
<p><font color='red'><strong>思想</strong></font>：允许发送方  “预约” 信道，而不是随机访问信道：避免了长数据帧的浪费</p>
<ul>
<li><p>发送方首先使用  CSMA 向 BS 发送一个小的 RTS分组</p>
<ul>
<li>RTS 可能会冲突（但是由于比较短，浪费信道较少）</li>
</ul>
<blockquote>
<p>**RTS（Request to Send）**分组是一种用于无线局域网（WLAN）中的数据帧类型之一，用于在发送数据前请求接收方的许可。RTS帧通常与CTS（Clear to Send）帧一起使用，以确保数据的可靠传输和避免数据冲突。</p>
<p>在发送数据前，发送方首先发送一个RTS帧给接收方，请求接收方的许可。RTS帧包含了一些关键信息，如发送方的地址、接收方的地址、数据长度等。接收方在接收到RTS帧后，会发送一个CTS帧给发送方，告知发送方可以开始发送数据。CTS帧中也包含了一些关键信息，如接收方的地址、发送方的地址、数据长度等。</p>
<p>通过RTS&#x2F;CTS机制，可以避免数据冲突和丢失。具体来说，RTS&#x2F;CTS机制可以实现以下几个功能：</p>
<ol>
<li><p>碰撞避免：由于使用了RTS&#x2F;CTS机制，发送方和接收方可以在发送数据前进行协调，避免多个设备在同一时间发送数据，从而避免数据冲突和丢失。</p>
</li>
<li><p>优先级控制：由于RTS&#x2F;CTS机制需要消耗一定的网络资源，发送方可以根据需要进行优先级控制，选择是否使用RTS&#x2F;CTS机制，以充分利用网络资源。</p>
</li>
<li><p>数据传输可靠性：通过RTS&#x2F;CTS机制，可以保证数据的可靠传输，避免数据的重传和丢失。</p>
</li>
</ol>
<p>需要注意的是，RTS&#x2F;CTS机制虽然能够提高数据传输的可靠性，但是也会增加网络的负担和延迟。因此，在具体应用中，需要根据网络环境和应用场景进行选择，以平衡性能和可靠性的需求。</p>
<p>总之，RTS分组是一种用于无线局域网中的数据帧类型，通过与CTS帧一起使用，可以实现碰撞避免、优先级控制和数据传输可靠性的功能，提高网络的性能和可靠性。</p>
</blockquote>
</li>
<li><p>BS 广播 clear - to - send CTS ，作为 RTS 的响应</p>
</li>
<li><p>CTS 能够被所有涉及到的 节点听到</p>
<ul>
<li>发送方发送数据帧</li>
<li>其他节点抑制发送</li>
</ul>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519140543965.png"
                      alt="image-20230519140543965" style="zoom: 50%;" 
                >

<blockquote>
<p><strong>采用小的 预约分组，可以完全避免数据帧的冲突</strong></p>
</blockquote>
<h4 id="轮流协议（Taking-Turns-MAC-协议"><a href="#轮流协议（Taking-Turns-MAC-协议" class="headerlink" title="轮流协议（Taking Turns ) MAC 协议"></a>轮流协议（Taking Turns ) MAC 协议</h4><p><font color='cornflowerblue'>信道划分 MAC 协议</font>：</p>
<ul>
<li>共享信道 在高负载 时是 有效和公平的</li>
<li>在低负载时  效率较低<ul>
<li>只能等到自己的时隙开始发送或者 利用 1&#x2F;N 的 信道频率发送</li>
<li>当只有一个节点有帧发送时，也只能够得到 1&#x2F;N 带宽分配</li>
</ul>
</li>
</ul>
<p><font color='cornflowerblue'>随机访问 MAC 协议</font></p>
<ul>
<li>在低负载时效率高：单个节点可以利用信道的全部带宽</li>
<li>高负载时：冲突开销较大，效率极低，时间很多都浪费了</li>
</ul>
<p><font color='red'>轮流协议：</font></p>
<p>有两者的优点</p>
<h5 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h5><p><font color='red'><strong>轮询</strong></font></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519142248506.png"
                      alt="image-20230519142248506" style="zoom:50%;" 
                >

<ul>
<li>主节点邀请从节点依次发送</li>
<li>从节点一般比较 “dump”</li>
<li>缺点：<ul>
<li>轮询开销：轮询本身消耗信道带宽</li>
<li>等待时间：每个节点需等到主节点轮询后开始传输，即使 只有一个节点，也需要 轮询一周后才能发送</li>
<li>单点故障：主节点失效时造成整个系统无法 工作</li>
</ul>
</li>
</ul>
<p><font color='red'><strong>令牌传递</strong></font></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519142527818.png"
                      alt="image-20230519142527818" style="zoom:50%;" 
                >

<ul>
<li>控制 <strong>令牌（token）</strong>  循环从一个节点到下一个节点 的传递</li>
<li>令牌报文：特殊的帧</li>
<li>缺点：<ul>
<li>令牌开销：本身消耗带宽</li>
<li>延迟：只有等到抓到令牌，才可传输</li>
<li>单点故障（token）：<ul>
<li>令牌丢失 系统级故障，整个系统无法传输</li>
<li>复杂机制重新生成令牌</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="DOCSIS：线缆接入网络"><a href="#DOCSIS：线缆接入网络" class="headerlink" title="DOCSIS：线缆接入网络"></a>DOCSIS：线缆接入网络</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519141059662.png"
                      alt="image-20230519141059662" style="zoom:50%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519141300497.png"
                      alt="image-20230519141300497" style="zoom:50%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519141318780.png"
                      alt="image-20230519141318780" style="zoom:50%;" 
                ></p>
<h4 id="MAC-协议总结"><a href="#MAC-协议总结" class="headerlink" title="MAC 协议总结"></a>MAC 协议总结</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519142629241.png"
                      alt="image-20230519142629241" style="zoom:50%;" 
                >



<h3 id="LANs"><a href="#LANs" class="headerlink" title="LANs"></a>LANs</h3><hr>
<p>图6-15显示了一个交换局域网连接了3个部门，两台服务器和一台与4台交换机连接的路由器。因为这些交换机运行在链路层，所以它们交换链路层帧（而不是网络层数据报）,不识别网络层地址，不使用如RIP或OSPF这样的路由选择算法来确定通过第二层交换机网络的路径。我们马上就会看到，它们使用链路层地址而不是IP地址来转发链路层帧通过交换机网络。我们首先以讨论<strong>链路层寻址</strong>来开始对<strong>交换机局域网的学习</strong>。然后仔细学习<strong>著名的以太网协议</strong>。在仔细学习链路层寻址和以太网后，我们将考察<strong>链路层交换机的工作方式</strong>,并随后考察通常是如何用这些交换机<strong>构建大规模局域网</strong>的。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519144724251.png"
                      alt="image-20230519144724251" style="zoom:50%;" 
                >

<h4 id="链路层寻址和-ARP"><a href="#链路层寻址和-ARP" class="headerlink" title="链路层寻址和 ARP"></a>链路层寻址和 ARP</h4><ul>
<li>32bit IP 地址<ul>
<li>网络层地址</li>
<li>前n-1 跳：用于使数据报到达目的 IP 子网</li>
<li>最后一跳：到达子网中的目标节点</li>
</ul>
</li>
<li>LAN（MAC&#x2F;物理&#x2F;以太网）地址：<ul>
<li>用于使帧从一个网卡传递到与其物理连接的另一个网卡（在同一物理网络中）</li>
<li>48 bit MAC 地址固化在适配器的 ROM，有时也可以通过软件设定</li>
<li>理论上 全球任何两个网卡的 MAC 地址都不相同</li>
</ul>
</li>
</ul>
<h5 id="网络地址和-Mac-地址分离"><a href="#网络地址和-Mac-地址分离" class="headerlink" title="网络地址和 Mac 地址分离"></a>网络地址和 Mac 地址分离</h5><ol>
<li>IP地址和 MAC 地址的作用不同<ol>
<li>IP 地址是分层的<ul>
<li>一个子网所有站点网络号一致，路由聚集，减少路由表<ul>
<li>需要一个网络中的站点地址 网络号一致，如果 捆绑需要定制网卡非常麻烦</li>
</ul>
</li>
<li>希望网络层地址是配置的；IP地址完成网络到网络的交付</li>
</ul>
</li>
</ol>
</li>
<li>MAC地址是一个 <strong>平面</strong> 的<ul>
<li>网卡在 生产时不知道被用于那个网络，因此 给网卡一个唯一的标识，用于区分一个网络内部 不同的网卡</li>
<li>可以完成一个物理网络内部的节点到节点的数据交付网卡</li>
</ul>
</li>
<li>分离的好处<ul>
<li>网卡坏了，IP 不变，可以捆绑到另外一个网卡的 Mac 上</li>
<li>物理网络还可以除 IP 之外支持其他网络层协议，链路协议为任意上层网络协议</li>
</ul>
</li>
<li>捆绑的问题<ul>
<li>如果仅仅使用 IP 地址，不用 MAC 地址，那么它 仅支持 IP协议</li>
<li>每次上电都要重新写入网卡 IP 地址</li>
<li>另外一个选择就是不使用任何地址；不用 MAC地址，则每到来一个帧都要上传到 IP 层次，由他判断是不是要接受，干扰一次</li>
</ul>
</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519150755668.png"
                      alt="image-20230519150755668" style="zoom:50%;" 
                >

<ul>
<li>MAC地址由 IEEE 管理和分配</li>
<li>制造商购入 MAC地址空间（保证唯一性）</li>
<li>类比<ul>
<li>Mac 地址：社会安全号</li>
<li>IP 地址：通讯地址</li>
</ul>
</li>
<li>MAC 平面地址 -&gt; 支持移动<ul>
<li>可以将网卡接到其他网络</li>
</ul>
</li>
<li>IP 地址有层次 -&gt; 不能移动<ul>
<li>依赖于节点连接的IP 子网，与子网的网络号相同（有与其相连的子网相同的网络前缀)</li>
</ul>
</li>
</ul>
<h5 id="地址解析协议-ARP-Address-Resolution-Protocol"><a href="#地址解析协议-ARP-Address-Resolution-Protocol" class="headerlink" title="地址解析协议 ARP Address Resolution Protocol"></a>地址解析协议 ARP Address Resolution Protocol</h5><p>因为存在 网络层地址（IP 地址）和 链路层地址（Mac地址），所以需要在他们之间进行转换。对于 Internet 来说，这就是 地址解析协议 ARP</p>
<p>ARP（Address Resolution Protocol）是一种用于将IP地址解析为MAC地址的协议，常用于局域网中。ARP协议的主要作用是将目标IP地址转换为相应的MAC地址，以便在局域网中进行数据传输。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519151559255.png"
                      alt="image-20230519151559255" style="zoom:50%;" 
                >

<p>当一个设备需要向局域网中的其他设备发送数据时，需要先获取目标设备的MAC地址。此时，设备会首先查询本地的ARP缓存表，检查是否有目标设备的IP地址对应的MAC地址。如果有，则可以直接使用该MAC地址进行数据传输；如果没有，则需要发送一个ARP请求广播，请求目标设备回应其MAC地址。收到ARP请求广播后，目标设备将会回应自己的MAC地址，发送方将收到该回应并将其缓存到本地的ARP缓存表中，以便下次快速获取目标设备的MAC地址。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519151440544.png"
                      alt="image-20230519151440544" style="zoom:50%;" 
                >



<p>需要注意的是，ARP协议只适用于同一局域网内的设备之间的通信，因为在不同的局域网中，不同的设备可能使用不同的物理地址和网络协议，因此需要使用更为复杂的协议，如路由协议等。</p>
<p>总之，ARP协议是一种用于将IP地址解析为MAC地址的协议，通过查询本地的ARP缓存表或发送ARP请求广播，可以获取目标设备的MAC地址，以便在局域网中进行数据传输。ARP协议是局域网中数据传输的基础，能够实现快速、可靠的数据传输。</p>
<h6 id="路由到其他-LAN"><a href="#路由到其他-LAN" class="headerlink" title="路由到其他 LAN"></a>路由到其他 LAN</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519151815000.png"
                      alt="image-20230519151815000" style="zoom:50%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519151842744.png"
                      alt="image-20230519151842744" style="zoom:50%;" 
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519151907707.png"
                      alt="image-20230519151907707" style="zoom:50%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519151924256.png"
                      alt="image-20230519151924256" style="zoom:50%;" 
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519151955518.png"
                      alt="image-20230519151955518" style="zoom:50%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519152010017.png"
                      alt="image-20230519152010017" style="zoom:50%;" 
                ></p>
<h4 id="以太网-Ethernet"><a href="#以太网-Ethernet" class="headerlink" title="以太网 Ethernet"></a>以太网 Ethernet</h4><p>Ethernet是一种常用的局域网（LAN）技术，是一种基于CSMA&#x2F;CD协议的数据传输协议。Ethernet最初由Xerox公司开发，后来被Intel、Digital和Xerox合作推出，并逐渐成为局域网中的标准技术之一。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519152314818.png"
                      alt="image-20230519152314818" style="zoom:50%;" 
                >

<p>Ethernet的基本原理是通过物理介质（如双绞线、光纤等）连接设备，使用CSMA&#x2F;CD协议来协调设备之间的数据传输，以实现数据的高速、可靠传输。在Ethernet中，每个设备都有一个唯一的物理地址（MAC地址），用于在网络中进行通信。Ethernet支持多种传输速率和距离，如10Mbps、100Mbps、1000Mbps等，以及10米、100米、1000米等传输距离，可以根据具体的需求进行选择。</p>
<p>在Ethernet中，每个设备都可以发送或接收数据帧（Frame），数据帧由多个字段组成，包括目标地址、源地址、数据长度、数据内容等。数据帧通过物理介质传输，经过物理层的编码和解码处理后，到达数据链路层，进行MAC地址的寻址和帧的处理。如果在传输过程中发生了冲突，设备会通过CSMA&#x2F;CD协议进行协调，以避免数据的丢失和冲突。</p>
<p>总之，Ethernet是一种常用的局域网技术，基于CSMA&#x2F;CD协议，通过物理介质连接设备，实现数据的高速、可靠传输。Ethernet具有灵活性、可靠性和可扩展性等优点，在局域网中得到了广泛应用。</p>
<h5 id="以太网：物理拓扑"><a href="#以太网：物理拓扑" class="headerlink" title="以太网：物理拓扑"></a>以太网：物理拓扑</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519155906071.png"
                      alt="image-20230519155906071" style="zoom:50%;" 
                >

<ul>
<li><font color='red'><strong>总线</strong></font>：<ul>
<li>所有节点在一个碰撞域中，一次只允许一个节点发送</li>
<li>可靠性差，如果介质破损，截面形成信号的反射，发送节点误以为是冲突，总是冲突</li>
</ul>
</li>
<li><font color='red'><strong>星型：</strong></font> 目前主流<ul>
<li>连接选择： hub 或者 Switch</li>
<li>现在一般是交换机在中心</li>
<li>每个节点以及相连的交换机端口使用（独立的）以太网协议（不会和其他节点的发送产生碰撞）</li>
</ul>
</li>
</ul>
<h5 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h5><p>发送方适配器在 <strong>以太网帧</strong> 中封装 IP 数据报或者其他的网络层协议数据单元</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519160038074.png"
                      alt="image-20230519160038074" style="zoom:50%;" 
                >

<ul>
<li><p><font color='red'>地址：</font> 6字节 源Mac 地址，目标 Mac 地址</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519160129504.png"
                      alt="image-20230519160129504" style="zoom:50%;" 
                >
</li>
<li><p><font color='red'>类型：</font>指出高层协议（大多情况下是 IP，但也支持其他网络层协议）</p>
</li>
<li><p><font color='red'>CRC</font>：在接收方检验</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519160310094.png"
                      alt="image-20230519160310094" style="zoom:50%;" 
                ></li>
</ul>
<h5 id="以太网：无连接、不可靠的服务"><a href="#以太网：无连接、不可靠的服务" class="headerlink" title="以太网：无连接、不可靠的服务"></a>以太网：无连接、不可靠的服务</h5><ul>
<li><p><font color='red'>无连接：</font>帧传输前，发送方和接收方之间没有握手</p>
</li>
<li><p><font color='red'>不可靠</font>：接收方适配器不发送 ACKs 或 NAKs 给发送方</p>
<ul>
<li><p>递交给网络层的 数据报流可能有 gap</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519160502819.png"
                      alt="image-20230519160502819" style="zoom:50%;" 
                ></li>
</ul>
</li>
<li><p>以太网的  MAC 协议：采用 **二进制退避的 CSMA&#x2F;CD ** 介质访问协议</p>
</li>
</ul>
<h5 id="Hubs"><a href="#Hubs" class="headerlink" title="Hubs"></a>Hubs</h5><p>hub 本质上是物理层的中继器</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519160756054.png"
                      alt="image-20230519160756054" style="zoom:50%;" 
                >

<ul>
<li>从一个端口收，转发到其他所有端口</li>
<li>速率一致</li>
<li>没有帧的缓存</li>
<li>在 hub 端口上 没有 CSMA&#x2F;CD 机制：适配器检测冲突</li>
<li>提供网络管理功能</li>
</ul>
<h5 id="Manchester-编码"><a href="#Manchester-编码" class="headerlink" title="Manchester 编码"></a>Manchester 编码</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519161139807.png"
                      alt="image-20230519161139807" style="zoom:50%;" 
                >



<h5 id="千兆以太网"><a href="#千兆以太网" class="headerlink" title="千兆以太网"></a>千兆以太网</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519161208818.png"
                      alt="image-20230519161208818" style="zoom:50%;" 
                >



<h4 id="switches"><a href="#switches" class="headerlink" title="switches"></a>switches</h4><h5 id="Hub：集线器"><a href="#Hub：集线器" class="headerlink" title="Hub：集线器"></a>Hub：集线器</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519161632436.png"
                      alt="image-20230519161632436" style="zoom:50%;" 
                >

<ul>
<li>网段（LAN segment）：可以允许一个站点发送的网络范围<ul>
<li>在一个碰撞域，同时只允许一个站点发送</li>
<li>如果有两个节点发送，则会碰撞</li>
<li>通常拥有相同的前缀，比 IP子网更详细的前缀</li>
</ul>
</li>
<li>所有 以 hub 连在一起的站点处在一个 网段，处在一个碰撞域<ul>
<li>骨干hub 将所有网段连到了一起</li>
</ul>
</li>
<li>通过 hub 可扩展节点之间的最大距离</li>
<li>通过hub，不能将 10 BaseT 和  100 BaseT 的网络连接在一起</li>
</ul>
<h5 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h5><ul>
<li><font color='red'>链路层设备：扮演主动角色（端口执行以太网协议）</font><ul>
<li>对帧进行存储和转发</li>
<li>对于到来的帧，检查帧头，根据目标 MAC 地址进行 <strong>选择性转发</strong></li>
<li>当 帧需要向某个（些） 网段进行 转发，需要使用 CSMA&#x2F;CD 进行接入控制</li>
<li>通常一个交换机端口一个独立网段</li>
</ul>
</li>
<li><font color='red'>透明</font>：主机对交换机的存在可以不关心<ul>
<li>通过交换机相连的各节点 好像这些站点是直接相连的一样</li>
<li>有 MAC 地址；无 IP 地址</li>
</ul>
</li>
<li><font color='red'>即插即用，自学习</font><ul>
<li>交换机无需配置</li>
</ul>
</li>
</ul>
<h6 id="交换机：多路同时传输"><a href="#交换机：多路同时传输" class="headerlink" title="交换机：多路同时传输"></a>交换机：多路同时传输</h6><ul>
<li><p>主机有一个 <strong>专用</strong> 和 <strong>直接</strong> 到交换机的连接</p>
</li>
<li><p>交换机缓存到来的帧</p>
</li>
<li><p>对每个帧进入的链路使用 以太网协议，没有碰撞；全双工</p>
<ul>
<li>每条链路都是一个独立的碰撞域</li>
<li>MAC 地址在其中的作用 太弱化了</li>
</ul>
</li>
<li><p><font color='red'>交换</font>：A - to -A’  和 B - to - B‘ 可以同时传输，没有碰撞</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519162326860.png"
                      alt="image-20230519162326860" style="zoom:50%;" 
                ></li>
</ul>
<h6 id="交换机转发表"><a href="#交换机转发表" class="headerlink" title="交换机转发表"></a>交换机转发表</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519162418327.png"
                      alt="image-20230519162418327" style="zoom:50%;" 
                >



<h6 id="交换机自学习"><a href="#交换机自学习" class="headerlink" title="交换机自学习"></a>交换机自学习</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519162456469.png"
                      alt="image-20230519162456469" style="zoom:50%;" 
                >







<h6 id="交换机：过滤、转发"><a href="#交换机：过滤、转发" class="headerlink" title="交换机：过滤、转发"></a>交换机：过滤、转发</h6><p>当交换机收到一个 帧时 ：</p>
<ol>
<li><p>记录进入链路，发送主机 的 MAC地址</p>
</li>
<li><p>使用 目标 MAC地址对交换表进行 索引</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519162647186.png"
                      alt="image-20230519162647186" style="zoom:50%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519162708785.png"
                      alt="image-20230519162708785" style="zoom:50%;" 
                ></li>
</ol>
<h6 id="交换机级联"><a href="#交换机级联" class="headerlink" title="交换机级联"></a>交换机级联</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519163536652.png"
                      alt="image-20230519163536652" style="zoom:50%;" 
                >



<h6 id="交换机-VS-路由器"><a href="#交换机-VS-路由器" class="headerlink" title="交换机 VS 路由器"></a>交换机 VS 路由器</h6><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519163606927.png"
                      alt="image-20230519163606927" style="zoom:50%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519163638308.png"
                      alt="image-20230519163638308" style="zoom:50%;" 
                >



<h4 id="VLANs"><a href="#VLANs" class="headerlink" title="VLANs"></a>VLANs</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519163751605.png"
                      alt="image-20230519163751605" style="zoom:50%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519163809778.png"
                      alt="image-20230519163809778" style="zoom:50%;" 
                >

<p>VLAN（Virtual Local Area Network）是一种虚拟局域网技术，可以将一个物理局域网划分成多个逻辑上的虚拟局域网，从而实现更好的网络管理和安全控制。</p>
<p>在传统的局域网中，所有设备都连接在同一个物理网络中，因此，不同的设备可以直接通信，缺乏有效的隔离和安全控制。而在VLAN中，可以将不同的设备划分到不同的虚拟网络中，各个虚拟网络之间相互隔离，从而提高网络的安全性和可管理性。</p>
<p>VLAN的实现方式通常是通过交换机和路由器进行管理。交换机可以将不同的端口划分到不同的VLAN中，从而实现不同VLAN之间的隔离。路由器可以对不同的VLAN进行路由转发，实现不同VLAN之间的通信。</p>
<p>使用VLAN技术可以带来以下优点：</p>
<ol>
<li><p>提高网络的安全性：VLAN可以将不同的设备划分到不同的虚拟网络中，各个虚拟网络之间相互隔离，从而提高网络的安全性。可以根据不同的安全级别对不同的设备进行划分，减少网络攻击的风险。</p>
</li>
<li><p>提高网络的可管理性：使用VLAN技术可以更好地管理网络资源，可以根据不同的部门、功能或需求来划分VLAN，方便网络管理员对网络进行管理和监控。同时，VLAN可以减少广播和数据流量，提高网络的性能和可靠性。</p>
</li>
<li><p>提高网络的灵活性：使用VLAN技术可以根据需要随时添加、删除或修改VLAN，方便网络的调整和扩展。同时，VLAN可以跨越多个交换机和路由器，实现更大规模的网络管理和控制。</p>
</li>
</ol>
<p>需要注意的是，使用VLAN技术需要进行一定的规划和配置，同时需要保证交换机和路由器的兼容性和互操作性。此外，VLAN的划分需要根据实际需求和网络拓扑结构进行优化，否则可能会影响网络的性能和可靠性。</p>
<p>总之，VLAN是一种虚拟局域网技术，可以将一个物理局域网划分为多个逻辑上的虚拟局域网，实现更好的网络管理和安全控制。VLAN具有提高网络安全性、可管理性和灵活性等优点，是现代网络中常用的管理和控制技术。</p>
<h5 id="基于端口的-VLAN"><a href="#基于端口的-VLAN" class="headerlink" title="基于端口的 VLAN"></a>基于端口的 VLAN</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519163838329.png"
                      alt="image-20230519163838329" style="zoom:50%;" 
                >



<h5 id="VLANs-互连多个交换机"><a href="#VLANs-互连多个交换机" class="headerlink" title="VLANs 互连多个交换机"></a>VLANs 互连多个交换机</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519163919687.png"
                      alt="image-20230519163919687" style="zoom:50%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519163952018.png"
                      alt="image-20230519163952018" style="zoom:50%;" 
                >

<h4 id="a-day-in-the-life-of-web-request"><a href="#a-day-in-the-life-of-web-request" class="headerlink" title="a day in the life of web request"></a>a day in the life of web request</h4><p>以一个 web 页面请求的例子： 综述</p>
<ul>
<li><font color='red'>目标：</font>标示、回顾和理解涉及到的协议（所有层次），以一个看似简单的场景： 请求web 页面</li>
<li><font color='red'>场景：</font>学生在校园内启动一台笔记本电脑：请求和 接收<a class="link"   target="_blank" rel="noopener" href="http://www.google.com/" >www.google.com<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519164348636.png"
                      alt="image-20230519164348636" style="zoom:50%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519164414629.png"
                      alt="image-20230519164414629" style="zoom:50%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519164443416.png"
                      alt="image-20230519164443416" style="zoom:50%;" 
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519164501058.png"
                      alt="image-20230519164501058" style="zoom:50%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519164515525.png"
                      alt="image-20230519164515525" style="zoom:50%;" 
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519164531860.png"
                      alt="image-20230519164531860" style="zoom:50%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cs7eric-image.oss-cn-hangzhou.aliyuncs.com/images/image-20230519164544180.png"
                      alt="image-20230519164544180" style="zoom:50%;" 
                ></p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul>
<li>数据链路层服务背后的原理<ul>
<li>检错、纠错</li>
<li>共享式广播信道：多路访问</li>
<li>链路编址</li>
</ul>
</li>
<li>各种链路层技术的实现和实例<ul>
<li>Ethernet</li>
<li>交换式 LANs、VLANs</li>
<li>虚拟成 链路层的 网络 MPLS</li>
</ul>
</li>
<li>综合 ：一个 web 页面请求的日常场景</li>
</ul>
<p>​	</p>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> 计算机网络</li>
        <li><strong>Author:</strong> cccs7</li>
        <li><strong>Created at
                :</strong> 2023-01-03 15:38:21</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2024-09-13 11:07:59
            </li>
        
        <li>
            <strong>Link:</strong> https://cs7eric.github.io/2023/01/03/计算机网络/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">#计算机网络</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2023/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">操作系统</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2023/01/01/MyBatis-plus/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">MyBatis-plus</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="waline"></div>
    <script type="module" data-swup-reload-script>
      import { init } from '/js/libs/waline.mjs';

      function loadWaline() {
        init({
          el: '#waline',
          serverURL: 'https://example.example.com',
          lang: 'zh-CN',
          dark: 'body[class~="dark-mode"]',
          reaction: false,
          requiredMeta: ['nick', 'mail'],
          emoji: [],
          
          
        });
      }

      if (typeof swup !== 'undefined') {
        loadWaline();
      } else {
        window.addEventListener('DOMContentLoaded', loadWaline);
      }
    </script>



        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">计算机网络</div>
		<ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%9B%A0%E7%89%B9%E7%BD%91"><span class="nav-text">计算机网络与因特网</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Internet%EF%BC%9F"><span class="nav-text">什么是 Internet？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84"><span class="nav-text">网络结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%BE%B9%E7%BC%98"><span class="nav-text">网络边缘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83"><span class="nav-text">网络核心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%85%A5%E7%BD%91%E5%92%8C%E7%89%A9%E7%90%86%E5%AA%92%E4%BD%93"><span class="nav-text">接入网和物理媒体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Internet-%E7%BB%93%E6%9E%84-%E5%92%8C-ISP"><span class="nav-text">Internet 结构 和 ISP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E5%BB%B6%E6%97%B6%E3%80%81%E4%B8%A2%E5%A4%B1%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-text">分组延时、丢失和吞吐量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E5%B1%82%E6%AC%A1%E5%8F%8A%E6%9C%8D%E5%8A%A1%E7%B1%BB%E5%9E%8B"><span class="nav-text">协议层次及服务类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-text">应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86"><span class="nav-text">应用层协议原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web-and-HTTP"><span class="nav-text">Web and HTTP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FTP"><span class="nav-text">FTP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Email"><span class="nav-text">Email</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS"><span class="nav-text">DNS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#P2P-%E5%BA%94%E7%94%A8"><span class="nav-text">P2P 应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CDN"><span class="nav-text">CDN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Socket-%E7%BC%96%E7%A8%8B"><span class="nav-text">Socket 编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="nav-text">传输层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BC%A0%E8%BE%93%E5%B1%82%E6%9C%8D%E5%8A%A1"><span class="nav-text">概述和传输层服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8E%E8%A7%A3%E5%A4%8D%E7%94%A8"><span class="nav-text">多路复用与解复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E8%BF%9E%E6%8E%A5%E4%BC%A0%E8%BE%93%EF%BC%9AUDP"><span class="nav-text">无连接传输：UDP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-rdt-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-text">可靠数据传输(rdt)的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93%EF%BC%9ATCP"><span class="nav-text">面向连接的传输：TCP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86"><span class="nav-text">拥塞控制原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-text">TCP  拥塞控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-text">网络层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0"><span class="nav-text">网络层概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2"><span class="nav-text">网络层：数据平面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2"><span class="nav-text">网络层：控制平面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="nav-text">链路层和局域网</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E6%A6%82%E8%BF%B0"><span class="nav-text">链路层概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B%E5%92%8C%E7%BA%A0%E6%AD%A3"><span class="nav-text">差错检测和纠正</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE%E9%93%BE%E8%B7%AF%E5%92%8C%E5%8D%8F%E8%AE%AE"><span class="nav-text">多路访问链路和协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LANs"><span class="nav-text">LANs</span></a></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2022</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">cccs7</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        71 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>








    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





	
</body>

</html>